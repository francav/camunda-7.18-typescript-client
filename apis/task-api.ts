/* tslint:disable */
/* eslint-disable */
/**
 * Camunda Platform REST API
 * OpenApi Spec for Camunda Platform REST API.
 *
 * OpenAPI spec version: 7.18.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { AuthorizationExceptionDto } from '../models';
import { CompleteTaskDto } from '../models';
import { CountResultDto } from '../models';
import { ExceptionDto } from '../models';
import { FormDto } from '../models';
import { TaskBpmnErrorDto } from '../models';
import { TaskDto } from '../models';
import { TaskEscalationDto } from '../models';
import { TaskQueryDto } from '../models';
import { UserIdDto } from '../models';
import { VariableValueDto } from '../models';
/**
 * TaskApi - axios parameter creator
 * @export
 */
export const TaskApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Claims a task for a specific user.  **Note:** The difference with the [Set Assignee](https://docs.camunda.org/manual/7.18/reference/rest/task/post-assignee/) method is that here a check is performed to see if the task already has a user assigned to it.
         * @summary Claim
         * @param {string} id The id of the task to claim.
         * @param {UserIdDto} [body] Provide the id of the user that claims the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claim: async (id: string, body?: UserIdDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling claim.');
            }
            const localVarPath = `/task/{id}/claim`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Completes a task and updates process variables.
         * @summary Complete
         * @param {string} id The id of the task to complete.
         * @param {CompleteTaskDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        complete: async (id: string, body?: CompleteTaskDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling complete.');
            }
            const localVarPath = `/task/{id}/complete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new task.
         * @summary Create
         * @param {TaskDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTask: async (body?: TaskDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/task/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Delegates a task to another user.
         * @summary Delegate
         * @param {string} id The id of the task to delegate.
         * @param {UserIdDto} [body] Provide the id of the user that the task should be delegated to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegateTask: async (id: string, body?: UserIdDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling delegateTask.');
            }
            const localVarPath = `/task/{id}/delegate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a task by id.
         * @summary Delete
         * @param {string} id The id of the task to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTask: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteTask.');
            }
            const localVarPath = `/task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the deployed form that is referenced from a given task. For further information please refer to the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Form
         * @param {string} id The id of the task to get the deployed form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedForm: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDeployedForm.');
            }
            const localVarPath = `/task/{id}/deployed-form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the form key for a task. The form key corresponds to the `FormData#formKey` property in the engine. This key can be used to do task-specific form rendering in client applications. Additionally, the context path of the containing process application is returned.
         * @summary Get Form Key
         * @param {string} id The id of the task to retrieve the form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForm: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getForm.');
            }
            const localVarPath = `/task/{id}/form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the form variables for a task. The form variables take form data specified on the task into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Task Form Variables
         * @param {string} id The id of the task to retrieve the variables for.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFormVariables: async (id: string, variableNames?: string, deserializeValues?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getFormVariables.');
            }
            const localVarPath = `/task/{id}/form-variables`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (variableNames !== undefined) {
                localVarQueryParameter['variableNames'] = variableNames;
            }

            if (deserializeValues !== undefined) {
                localVarQueryParameter['deserializeValues'] = deserializeValues;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the rendered form for a task. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Form
         * @param {string} id The id of the task to get the rendered form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRenderedForm: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRenderedForm.');
            }
            const localVarPath = `/task/{id}/rendered-form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a task by id.
         * @summary Get
         * @param {string} id The id of the task to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getTask.');
            }
            const localVarPath = `/task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for tasks that fulfill a given filter. The size of the result set can be retrieved by using the Get Task Count method.  **Security Consideration:** There are several query parameters (such as assigneeExpression) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations](https://docs.camunda.org/manual/7.18/user-guide/process-engine/securing-custom-code/) for custom code in the user guide for details.
         * @summary Get List
         * @param {string} [taskId] Restrict to task with the given id.
         * @param {string} [taskIdIn] Restrict to tasks with any of the given ids.
         * @param {string} [processInstanceId] Restrict to tasks that belong to process instances with the given id.
         * @param {string} [processInstanceIdIn] Restrict to tasks that belong to process instances with the given ids.
         * @param {string} [processInstanceBusinessKey] Restrict to tasks that belong to process instances with the given business key.
         * @param {string} [processInstanceBusinessKeyExpression] Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {string} [processInstanceBusinessKeyIn] Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
         * @param {string} [processInstanceBusinessKeyLike] Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
         * @param {string} [processInstanceBusinessKeyLikeExpression] Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [processDefinitionId] Restrict to tasks that belong to a process definition with the given id.
         * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
         * @param {string} [processDefinitionKeyIn] Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
         * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
         * @param {string} [processDefinitionNameLike] Restrict to tasks that have a process definition name that has the parameter value as  a substring.
         * @param {string} [executionId] Restrict to tasks that belong to an execution with the given id.
         * @param {string} [caseInstanceId] Restrict to tasks that belong to case instances with the given id.
         * @param {string} [caseInstanceBusinessKey] Restrict to tasks that belong to case instances with the given business key.
         * @param {string} [caseInstanceBusinessKeyLike] Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
         * @param {string} [caseDefinitionId] Restrict to tasks that belong to a case definition with the given id.
         * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
         * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
         * @param {string} [caseDefinitionNameLike] Restrict to tasks that have a case definition name that has the parameter value as a  substring.
         * @param {string} [caseExecutionId] Restrict to tasks that belong to a case execution with the given id.
         * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
         * @param {string} [tenantIdIn] Only include tasks which belong to one of the passed and comma-separated  tenant ids.
         * @param {boolean} [withoutTenantId] Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
         * @param {string} [assignee] Restrict to tasks that the given user is assigned to.
         * @param {string} [assigneeExpression] Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeLike] Restrict to tasks that have an assignee that has the parameter  value as a substring.
         * @param {string} [assigneeLikeExpression] Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeIn] Only include tasks which are assigned to one of the passed and  comma-separated user ids.
         * @param {string} [assigneeNotIn] Only include tasks which are not assigned to one of the passed and comma-separated user ids.
         * @param {string} [owner] Restrict to tasks that the given user owns.
         * @param {string} [ownerExpression] Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateGroup] Only include tasks that are offered to the given group.
         * @param {string} [candidateGroupExpression] Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateUser] Only include tasks that are offered to the given user or to one of his groups.
         * @param {string} [candidateUserExpression] Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {boolean} [includeAssignedTasks] Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
         * @param {string} [involvedUser] Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
         * @param {string} [involvedUserExpression] Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
         * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
         * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
         * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
         * @param {string} [taskDefinitionKeyLike] Restrict to tasks that have a key that has the parameter value as a substring.
         * @param {string} [name] Restrict to tasks that have the given name.
         * @param {string} [nameNotEqual] Restrict to tasks that do not have the given name.
         * @param {string} [nameLike] Restrict to tasks that have a name with the given parameter value as substring.
         * @param {string} [nameNotLike] Restrict to tasks that do not have a name with the given parameter value as substring.
         * @param {string} [description] Restrict to tasks that have the given description.
         * @param {string} [descriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
         * @param {number} [priority] Restrict to tasks that have the given priority.
         * @param {number} [maxPriority] Restrict to tasks that have a lower or equal priority.
         * @param {number} [minPriority] Restrict to tasks that have a higher or equal priority.
         * @param {string} [dueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [dueDateExpression] Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
         * @param {string} [dueAfterExpression] Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
         * @param {string} [dueBeforeExpression] Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {boolean} [withoutDueDate] Only include tasks which have no due date. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
         * @param {string} [followUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [followUpDateExpression] Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
         * @param {string} [followUpAfterExpression] Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
         * @param {string} [followUpBeforeExpression] Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBeforeOrNotExistent] Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
         * @param {string} [followUpBeforeOrNotExistentExpression] Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdOn] Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
         * @param {string} [createdOnExpression] Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdAfter] Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [createdAfterExpression] Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdBefore] Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
         * @param {string} [createdBeforeExpression] Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [updatedAfter] Restrict to tasks that were updated after the given date. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.18/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
         * @param {string} [updatedAfterExpression] Restrict to tasks that were updated after the date described by the given expression. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.18/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [delegationState] Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
         * @param {string} [candidateGroups] Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
         * @param {string} [candidateGroupsExpression] Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
         * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withCandidateUsers] Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateUsers] Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;; &#x60;notLike&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [caseInstanceVariables] Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
         * @param {string} [parentTaskId] Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks: async (taskId?: string, taskIdIn?: string, processInstanceId?: string, processInstanceIdIn?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyExpression?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, processInstanceBusinessKeyLikeExpression?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionName?: string, processDefinitionNameLike?: string, executionId?: string, caseInstanceId?: string, caseInstanceBusinessKey?: string, caseInstanceBusinessKeyLike?: string, caseDefinitionId?: string, caseDefinitionKey?: string, caseDefinitionName?: string, caseDefinitionNameLike?: string, caseExecutionId?: string, activityInstanceIdIn?: string, tenantIdIn?: string, withoutTenantId?: boolean, assignee?: string, assigneeExpression?: string, assigneeLike?: string, assigneeLikeExpression?: string, assigneeIn?: string, assigneeNotIn?: string, owner?: string, ownerExpression?: string, candidateGroup?: string, candidateGroupExpression?: string, candidateUser?: string, candidateUserExpression?: string, includeAssignedTasks?: boolean, involvedUser?: string, involvedUserExpression?: string, assigned?: boolean, unassigned?: boolean, taskDefinitionKey?: string, taskDefinitionKeyIn?: string, taskDefinitionKeyLike?: string, name?: string, nameNotEqual?: string, nameLike?: string, nameNotLike?: string, description?: string, descriptionLike?: string, priority?: number, maxPriority?: number, minPriority?: number, dueDate?: string, dueDateExpression?: string, dueAfter?: string, dueAfterExpression?: string, dueBefore?: string, dueBeforeExpression?: string, withoutDueDate?: boolean, followUpDate?: string, followUpDateExpression?: string, followUpAfter?: string, followUpAfterExpression?: string, followUpBefore?: string, followUpBeforeExpression?: string, followUpBeforeOrNotExistent?: string, followUpBeforeOrNotExistentExpression?: string, createdOn?: string, createdOnExpression?: string, createdAfter?: string, createdAfterExpression?: string, createdBefore?: string, createdBeforeExpression?: string, updatedAfter?: string, updatedAfterExpression?: string, delegationState?: string, candidateGroups?: string, candidateGroupsExpression?: string, withCandidateGroups?: boolean, withoutCandidateGroups?: boolean, withCandidateUsers?: boolean, withoutCandidateUsers?: boolean, active?: boolean, suspended?: boolean, taskVariables?: string, processVariables?: string, caseInstanceVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, parentTaskId?: string, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/task`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (taskId !== undefined) {
                localVarQueryParameter['taskId'] = taskId;
            }

            if (taskIdIn !== undefined) {
                localVarQueryParameter['taskIdIn'] = taskIdIn;
            }

            if (processInstanceId !== undefined) {
                localVarQueryParameter['processInstanceId'] = processInstanceId;
            }

            if (processInstanceIdIn !== undefined) {
                localVarQueryParameter['processInstanceIdIn'] = processInstanceIdIn;
            }

            if (processInstanceBusinessKey !== undefined) {
                localVarQueryParameter['processInstanceBusinessKey'] = processInstanceBusinessKey;
            }

            if (processInstanceBusinessKeyExpression !== undefined) {
                localVarQueryParameter['processInstanceBusinessKeyExpression'] = processInstanceBusinessKeyExpression;
            }

            if (processInstanceBusinessKeyIn !== undefined) {
                localVarQueryParameter['processInstanceBusinessKeyIn'] = processInstanceBusinessKeyIn;
            }

            if (processInstanceBusinessKeyLike !== undefined) {
                localVarQueryParameter['processInstanceBusinessKeyLike'] = processInstanceBusinessKeyLike;
            }

            if (processInstanceBusinessKeyLikeExpression !== undefined) {
                localVarQueryParameter['processInstanceBusinessKeyLikeExpression'] = processInstanceBusinessKeyLikeExpression;
            }

            if (processDefinitionId !== undefined) {
                localVarQueryParameter['processDefinitionId'] = processDefinitionId;
            }

            if (processDefinitionKey !== undefined) {
                localVarQueryParameter['processDefinitionKey'] = processDefinitionKey;
            }

            if (processDefinitionKeyIn !== undefined) {
                localVarQueryParameter['processDefinitionKeyIn'] = processDefinitionKeyIn;
            }

            if (processDefinitionName !== undefined) {
                localVarQueryParameter['processDefinitionName'] = processDefinitionName;
            }

            if (processDefinitionNameLike !== undefined) {
                localVarQueryParameter['processDefinitionNameLike'] = processDefinitionNameLike;
            }

            if (executionId !== undefined) {
                localVarQueryParameter['executionId'] = executionId;
            }

            if (caseInstanceId !== undefined) {
                localVarQueryParameter['caseInstanceId'] = caseInstanceId;
            }

            if (caseInstanceBusinessKey !== undefined) {
                localVarQueryParameter['caseInstanceBusinessKey'] = caseInstanceBusinessKey;
            }

            if (caseInstanceBusinessKeyLike !== undefined) {
                localVarQueryParameter['caseInstanceBusinessKeyLike'] = caseInstanceBusinessKeyLike;
            }

            if (caseDefinitionId !== undefined) {
                localVarQueryParameter['caseDefinitionId'] = caseDefinitionId;
            }

            if (caseDefinitionKey !== undefined) {
                localVarQueryParameter['caseDefinitionKey'] = caseDefinitionKey;
            }

            if (caseDefinitionName !== undefined) {
                localVarQueryParameter['caseDefinitionName'] = caseDefinitionName;
            }

            if (caseDefinitionNameLike !== undefined) {
                localVarQueryParameter['caseDefinitionNameLike'] = caseDefinitionNameLike;
            }

            if (caseExecutionId !== undefined) {
                localVarQueryParameter['caseExecutionId'] = caseExecutionId;
            }

            if (activityInstanceIdIn !== undefined) {
                localVarQueryParameter['activityInstanceIdIn'] = activityInstanceIdIn;
            }

            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }

            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }

            if (assignee !== undefined) {
                localVarQueryParameter['assignee'] = assignee;
            }

            if (assigneeExpression !== undefined) {
                localVarQueryParameter['assigneeExpression'] = assigneeExpression;
            }

            if (assigneeLike !== undefined) {
                localVarQueryParameter['assigneeLike'] = assigneeLike;
            }

            if (assigneeLikeExpression !== undefined) {
                localVarQueryParameter['assigneeLikeExpression'] = assigneeLikeExpression;
            }

            if (assigneeIn !== undefined) {
                localVarQueryParameter['assigneeIn'] = assigneeIn;
            }

            if (assigneeNotIn !== undefined) {
                localVarQueryParameter['assigneeNotIn'] = assigneeNotIn;
            }

            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }

            if (ownerExpression !== undefined) {
                localVarQueryParameter['ownerExpression'] = ownerExpression;
            }

            if (candidateGroup !== undefined) {
                localVarQueryParameter['candidateGroup'] = candidateGroup;
            }

            if (candidateGroupExpression !== undefined) {
                localVarQueryParameter['candidateGroupExpression'] = candidateGroupExpression;
            }

            if (candidateUser !== undefined) {
                localVarQueryParameter['candidateUser'] = candidateUser;
            }

            if (candidateUserExpression !== undefined) {
                localVarQueryParameter['candidateUserExpression'] = candidateUserExpression;
            }

            if (includeAssignedTasks !== undefined) {
                localVarQueryParameter['includeAssignedTasks'] = includeAssignedTasks;
            }

            if (involvedUser !== undefined) {
                localVarQueryParameter['involvedUser'] = involvedUser;
            }

            if (involvedUserExpression !== undefined) {
                localVarQueryParameter['involvedUserExpression'] = involvedUserExpression;
            }

            if (assigned !== undefined) {
                localVarQueryParameter['assigned'] = assigned;
            }

            if (unassigned !== undefined) {
                localVarQueryParameter['unassigned'] = unassigned;
            }

            if (taskDefinitionKey !== undefined) {
                localVarQueryParameter['taskDefinitionKey'] = taskDefinitionKey;
            }

            if (taskDefinitionKeyIn !== undefined) {
                localVarQueryParameter['taskDefinitionKeyIn'] = taskDefinitionKeyIn;
            }

            if (taskDefinitionKeyLike !== undefined) {
                localVarQueryParameter['taskDefinitionKeyLike'] = taskDefinitionKeyLike;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameNotEqual !== undefined) {
                localVarQueryParameter['nameNotEqual'] = nameNotEqual;
            }

            if (nameLike !== undefined) {
                localVarQueryParameter['nameLike'] = nameLike;
            }

            if (nameNotLike !== undefined) {
                localVarQueryParameter['nameNotLike'] = nameNotLike;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (descriptionLike !== undefined) {
                localVarQueryParameter['descriptionLike'] = descriptionLike;
            }

            if (priority !== undefined) {
                localVarQueryParameter['priority'] = priority;
            }

            if (maxPriority !== undefined) {
                localVarQueryParameter['maxPriority'] = maxPriority;
            }

            if (minPriority !== undefined) {
                localVarQueryParameter['minPriority'] = minPriority;
            }

            if (dueDate !== undefined) {
                localVarQueryParameter['dueDate'] = dueDate;
            }

            if (dueDateExpression !== undefined) {
                localVarQueryParameter['dueDateExpression'] = dueDateExpression;
            }

            if (dueAfter !== undefined) {
                localVarQueryParameter['dueAfter'] = dueAfter;
            }

            if (dueAfterExpression !== undefined) {
                localVarQueryParameter['dueAfterExpression'] = dueAfterExpression;
            }

            if (dueBefore !== undefined) {
                localVarQueryParameter['dueBefore'] = dueBefore;
            }

            if (dueBeforeExpression !== undefined) {
                localVarQueryParameter['dueBeforeExpression'] = dueBeforeExpression;
            }

            if (withoutDueDate !== undefined) {
                localVarQueryParameter['withoutDueDate'] = withoutDueDate;
            }

            if (followUpDate !== undefined) {
                localVarQueryParameter['followUpDate'] = followUpDate;
            }

            if (followUpDateExpression !== undefined) {
                localVarQueryParameter['followUpDateExpression'] = followUpDateExpression;
            }

            if (followUpAfter !== undefined) {
                localVarQueryParameter['followUpAfter'] = followUpAfter;
            }

            if (followUpAfterExpression !== undefined) {
                localVarQueryParameter['followUpAfterExpression'] = followUpAfterExpression;
            }

            if (followUpBefore !== undefined) {
                localVarQueryParameter['followUpBefore'] = followUpBefore;
            }

            if (followUpBeforeExpression !== undefined) {
                localVarQueryParameter['followUpBeforeExpression'] = followUpBeforeExpression;
            }

            if (followUpBeforeOrNotExistent !== undefined) {
                localVarQueryParameter['followUpBeforeOrNotExistent'] = followUpBeforeOrNotExistent;
            }

            if (followUpBeforeOrNotExistentExpression !== undefined) {
                localVarQueryParameter['followUpBeforeOrNotExistentExpression'] = followUpBeforeOrNotExistentExpression;
            }

            if (createdOn !== undefined) {
                localVarQueryParameter['createdOn'] = createdOn;
            }

            if (createdOnExpression !== undefined) {
                localVarQueryParameter['createdOnExpression'] = createdOnExpression;
            }

            if (createdAfter !== undefined) {
                localVarQueryParameter['createdAfter'] = createdAfter;
            }

            if (createdAfterExpression !== undefined) {
                localVarQueryParameter['createdAfterExpression'] = createdAfterExpression;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['createdBefore'] = createdBefore;
            }

            if (createdBeforeExpression !== undefined) {
                localVarQueryParameter['createdBeforeExpression'] = createdBeforeExpression;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updatedAfter'] = updatedAfter;
            }

            if (updatedAfterExpression !== undefined) {
                localVarQueryParameter['updatedAfterExpression'] = updatedAfterExpression;
            }

            if (delegationState !== undefined) {
                localVarQueryParameter['delegationState'] = delegationState;
            }

            if (candidateGroups !== undefined) {
                localVarQueryParameter['candidateGroups'] = candidateGroups;
            }

            if (candidateGroupsExpression !== undefined) {
                localVarQueryParameter['candidateGroupsExpression'] = candidateGroupsExpression;
            }

            if (withCandidateGroups !== undefined) {
                localVarQueryParameter['withCandidateGroups'] = withCandidateGroups;
            }

            if (withoutCandidateGroups !== undefined) {
                localVarQueryParameter['withoutCandidateGroups'] = withoutCandidateGroups;
            }

            if (withCandidateUsers !== undefined) {
                localVarQueryParameter['withCandidateUsers'] = withCandidateUsers;
            }

            if (withoutCandidateUsers !== undefined) {
                localVarQueryParameter['withoutCandidateUsers'] = withoutCandidateUsers;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (suspended !== undefined) {
                localVarQueryParameter['suspended'] = suspended;
            }

            if (taskVariables !== undefined) {
                localVarQueryParameter['taskVariables'] = taskVariables;
            }

            if (processVariables !== undefined) {
                localVarQueryParameter['processVariables'] = processVariables;
            }

            if (caseInstanceVariables !== undefined) {
                localVarQueryParameter['caseInstanceVariables'] = caseInstanceVariables;
            }

            if (variableNamesIgnoreCase !== undefined) {
                localVarQueryParameter['variableNamesIgnoreCase'] = variableNamesIgnoreCase;
            }

            if (variableValuesIgnoreCase !== undefined) {
                localVarQueryParameter['variableValuesIgnoreCase'] = variableValuesIgnoreCase;
            }

            if (parentTaskId !== undefined) {
                localVarQueryParameter['parentTaskId'] = parentTaskId;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the number of tasks that fulfill a provided filter. Corresponds to the size of the result set when using the [Get Tasks](https://docs.camunda.org/manual/7.18/reference/rest/task/) method.  **Security Consideration:** There are several query parameters (such as assigneeExpression) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations](https://docs.camunda.org/manual/7.18/user-guide/process-engine/securing-custom-code/) for custom code in the user guide for details.
         * @summary Get List Count
         * @param {string} [taskId] Restrict to task with the given id.
         * @param {string} [taskIdIn] Restrict to tasks with any of the given ids.
         * @param {string} [processInstanceId] Restrict to tasks that belong to process instances with the given id.
         * @param {string} [processInstanceIdIn] Restrict to tasks that belong to process instances with the given ids.
         * @param {string} [processInstanceBusinessKey] Restrict to tasks that belong to process instances with the given business key.
         * @param {string} [processInstanceBusinessKeyExpression] Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {string} [processInstanceBusinessKeyIn] Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
         * @param {string} [processInstanceBusinessKeyLike] Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
         * @param {string} [processInstanceBusinessKeyLikeExpression] Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [processDefinitionId] Restrict to tasks that belong to a process definition with the given id.
         * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
         * @param {string} [processDefinitionKeyIn] Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
         * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
         * @param {string} [processDefinitionNameLike] Restrict to tasks that have a process definition name that has the parameter value as  a substring.
         * @param {string} [executionId] Restrict to tasks that belong to an execution with the given id.
         * @param {string} [caseInstanceId] Restrict to tasks that belong to case instances with the given id.
         * @param {string} [caseInstanceBusinessKey] Restrict to tasks that belong to case instances with the given business key.
         * @param {string} [caseInstanceBusinessKeyLike] Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
         * @param {string} [caseDefinitionId] Restrict to tasks that belong to a case definition with the given id.
         * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
         * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
         * @param {string} [caseDefinitionNameLike] Restrict to tasks that have a case definition name that has the parameter value as a  substring.
         * @param {string} [caseExecutionId] Restrict to tasks that belong to a case execution with the given id.
         * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
         * @param {string} [tenantIdIn] Only include tasks which belong to one of the passed and comma-separated  tenant ids.
         * @param {boolean} [withoutTenantId] Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
         * @param {string} [assignee] Restrict to tasks that the given user is assigned to.
         * @param {string} [assigneeExpression] Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeLike] Restrict to tasks that have an assignee that has the parameter  value as a substring.
         * @param {string} [assigneeLikeExpression] Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeIn] Only include tasks which are assigned to one of the passed and  comma-separated user ids.
         * @param {string} [assigneeNotIn] Only include tasks which are not assigned to one of the passed and comma-separated user ids.
         * @param {string} [owner] Restrict to tasks that the given user owns.
         * @param {string} [ownerExpression] Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateGroup] Only include tasks that are offered to the given group.
         * @param {string} [candidateGroupExpression] Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateUser] Only include tasks that are offered to the given user or to one of his groups.
         * @param {string} [candidateUserExpression] Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {boolean} [includeAssignedTasks] Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
         * @param {string} [involvedUser] Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
         * @param {string} [involvedUserExpression] Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
         * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
         * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
         * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
         * @param {string} [taskDefinitionKeyLike] Restrict to tasks that have a key that has the parameter value as a substring.
         * @param {string} [name] Restrict to tasks that have the given name.
         * @param {string} [nameNotEqual] Restrict to tasks that do not have the given name.
         * @param {string} [nameLike] Restrict to tasks that have a name with the given parameter value as substring.
         * @param {string} [nameNotLike] Restrict to tasks that do not have a name with the given parameter value as substring.
         * @param {string} [description] Restrict to tasks that have the given description.
         * @param {string} [descriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
         * @param {number} [priority] Restrict to tasks that have the given priority.
         * @param {number} [maxPriority] Restrict to tasks that have a lower or equal priority.
         * @param {number} [minPriority] Restrict to tasks that have a higher or equal priority.
         * @param {string} [dueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [dueDateExpression] Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
         * @param {string} [dueAfterExpression] Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
         * @param {string} [dueBeforeExpression] Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {boolean} [withoutDueDate] Only include tasks which have no due date. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
         * @param {string} [followUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [followUpDateExpression] Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
         * @param {string} [followUpAfterExpression] Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
         * @param {string} [followUpBeforeExpression] Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBeforeOrNotExistent] Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
         * @param {string} [followUpBeforeOrNotExistentExpression] Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdOn] Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
         * @param {string} [createdOnExpression] Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdAfter] Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [createdAfterExpression] Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdBefore] Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
         * @param {string} [createdBeforeExpression] Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [updatedAfter] Restrict to tasks that were updated after the given date. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.18/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
         * @param {string} [updatedAfterExpression] Restrict to tasks that were updated after the date described by the given expression. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.18/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [delegationState] Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
         * @param {string} [candidateGroups] Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
         * @param {string} [candidateGroupsExpression] Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
         * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withCandidateUsers] Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateUsers] Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;; &#x60;notLike&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [caseInstanceVariables] Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
         * @param {string} [parentTaskId] Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksCount: async (taskId?: string, taskIdIn?: string, processInstanceId?: string, processInstanceIdIn?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyExpression?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, processInstanceBusinessKeyLikeExpression?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionName?: string, processDefinitionNameLike?: string, executionId?: string, caseInstanceId?: string, caseInstanceBusinessKey?: string, caseInstanceBusinessKeyLike?: string, caseDefinitionId?: string, caseDefinitionKey?: string, caseDefinitionName?: string, caseDefinitionNameLike?: string, caseExecutionId?: string, activityInstanceIdIn?: string, tenantIdIn?: string, withoutTenantId?: boolean, assignee?: string, assigneeExpression?: string, assigneeLike?: string, assigneeLikeExpression?: string, assigneeIn?: string, assigneeNotIn?: string, owner?: string, ownerExpression?: string, candidateGroup?: string, candidateGroupExpression?: string, candidateUser?: string, candidateUserExpression?: string, includeAssignedTasks?: boolean, involvedUser?: string, involvedUserExpression?: string, assigned?: boolean, unassigned?: boolean, taskDefinitionKey?: string, taskDefinitionKeyIn?: string, taskDefinitionKeyLike?: string, name?: string, nameNotEqual?: string, nameLike?: string, nameNotLike?: string, description?: string, descriptionLike?: string, priority?: number, maxPriority?: number, minPriority?: number, dueDate?: string, dueDateExpression?: string, dueAfter?: string, dueAfterExpression?: string, dueBefore?: string, dueBeforeExpression?: string, withoutDueDate?: boolean, followUpDate?: string, followUpDateExpression?: string, followUpAfter?: string, followUpAfterExpression?: string, followUpBefore?: string, followUpBeforeExpression?: string, followUpBeforeOrNotExistent?: string, followUpBeforeOrNotExistentExpression?: string, createdOn?: string, createdOnExpression?: string, createdAfter?: string, createdAfterExpression?: string, createdBefore?: string, createdBeforeExpression?: string, updatedAfter?: string, updatedAfterExpression?: string, delegationState?: string, candidateGroups?: string, candidateGroupsExpression?: string, withCandidateGroups?: boolean, withoutCandidateGroups?: boolean, withCandidateUsers?: boolean, withoutCandidateUsers?: boolean, active?: boolean, suspended?: boolean, taskVariables?: string, processVariables?: string, caseInstanceVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, parentTaskId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/task/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (taskId !== undefined) {
                localVarQueryParameter['taskId'] = taskId;
            }

            if (taskIdIn !== undefined) {
                localVarQueryParameter['taskIdIn'] = taskIdIn;
            }

            if (processInstanceId !== undefined) {
                localVarQueryParameter['processInstanceId'] = processInstanceId;
            }

            if (processInstanceIdIn !== undefined) {
                localVarQueryParameter['processInstanceIdIn'] = processInstanceIdIn;
            }

            if (processInstanceBusinessKey !== undefined) {
                localVarQueryParameter['processInstanceBusinessKey'] = processInstanceBusinessKey;
            }

            if (processInstanceBusinessKeyExpression !== undefined) {
                localVarQueryParameter['processInstanceBusinessKeyExpression'] = processInstanceBusinessKeyExpression;
            }

            if (processInstanceBusinessKeyIn !== undefined) {
                localVarQueryParameter['processInstanceBusinessKeyIn'] = processInstanceBusinessKeyIn;
            }

            if (processInstanceBusinessKeyLike !== undefined) {
                localVarQueryParameter['processInstanceBusinessKeyLike'] = processInstanceBusinessKeyLike;
            }

            if (processInstanceBusinessKeyLikeExpression !== undefined) {
                localVarQueryParameter['processInstanceBusinessKeyLikeExpression'] = processInstanceBusinessKeyLikeExpression;
            }

            if (processDefinitionId !== undefined) {
                localVarQueryParameter['processDefinitionId'] = processDefinitionId;
            }

            if (processDefinitionKey !== undefined) {
                localVarQueryParameter['processDefinitionKey'] = processDefinitionKey;
            }

            if (processDefinitionKeyIn !== undefined) {
                localVarQueryParameter['processDefinitionKeyIn'] = processDefinitionKeyIn;
            }

            if (processDefinitionName !== undefined) {
                localVarQueryParameter['processDefinitionName'] = processDefinitionName;
            }

            if (processDefinitionNameLike !== undefined) {
                localVarQueryParameter['processDefinitionNameLike'] = processDefinitionNameLike;
            }

            if (executionId !== undefined) {
                localVarQueryParameter['executionId'] = executionId;
            }

            if (caseInstanceId !== undefined) {
                localVarQueryParameter['caseInstanceId'] = caseInstanceId;
            }

            if (caseInstanceBusinessKey !== undefined) {
                localVarQueryParameter['caseInstanceBusinessKey'] = caseInstanceBusinessKey;
            }

            if (caseInstanceBusinessKeyLike !== undefined) {
                localVarQueryParameter['caseInstanceBusinessKeyLike'] = caseInstanceBusinessKeyLike;
            }

            if (caseDefinitionId !== undefined) {
                localVarQueryParameter['caseDefinitionId'] = caseDefinitionId;
            }

            if (caseDefinitionKey !== undefined) {
                localVarQueryParameter['caseDefinitionKey'] = caseDefinitionKey;
            }

            if (caseDefinitionName !== undefined) {
                localVarQueryParameter['caseDefinitionName'] = caseDefinitionName;
            }

            if (caseDefinitionNameLike !== undefined) {
                localVarQueryParameter['caseDefinitionNameLike'] = caseDefinitionNameLike;
            }

            if (caseExecutionId !== undefined) {
                localVarQueryParameter['caseExecutionId'] = caseExecutionId;
            }

            if (activityInstanceIdIn !== undefined) {
                localVarQueryParameter['activityInstanceIdIn'] = activityInstanceIdIn;
            }

            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }

            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }

            if (assignee !== undefined) {
                localVarQueryParameter['assignee'] = assignee;
            }

            if (assigneeExpression !== undefined) {
                localVarQueryParameter['assigneeExpression'] = assigneeExpression;
            }

            if (assigneeLike !== undefined) {
                localVarQueryParameter['assigneeLike'] = assigneeLike;
            }

            if (assigneeLikeExpression !== undefined) {
                localVarQueryParameter['assigneeLikeExpression'] = assigneeLikeExpression;
            }

            if (assigneeIn !== undefined) {
                localVarQueryParameter['assigneeIn'] = assigneeIn;
            }

            if (assigneeNotIn !== undefined) {
                localVarQueryParameter['assigneeNotIn'] = assigneeNotIn;
            }

            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }

            if (ownerExpression !== undefined) {
                localVarQueryParameter['ownerExpression'] = ownerExpression;
            }

            if (candidateGroup !== undefined) {
                localVarQueryParameter['candidateGroup'] = candidateGroup;
            }

            if (candidateGroupExpression !== undefined) {
                localVarQueryParameter['candidateGroupExpression'] = candidateGroupExpression;
            }

            if (candidateUser !== undefined) {
                localVarQueryParameter['candidateUser'] = candidateUser;
            }

            if (candidateUserExpression !== undefined) {
                localVarQueryParameter['candidateUserExpression'] = candidateUserExpression;
            }

            if (includeAssignedTasks !== undefined) {
                localVarQueryParameter['includeAssignedTasks'] = includeAssignedTasks;
            }

            if (involvedUser !== undefined) {
                localVarQueryParameter['involvedUser'] = involvedUser;
            }

            if (involvedUserExpression !== undefined) {
                localVarQueryParameter['involvedUserExpression'] = involvedUserExpression;
            }

            if (assigned !== undefined) {
                localVarQueryParameter['assigned'] = assigned;
            }

            if (unassigned !== undefined) {
                localVarQueryParameter['unassigned'] = unassigned;
            }

            if (taskDefinitionKey !== undefined) {
                localVarQueryParameter['taskDefinitionKey'] = taskDefinitionKey;
            }

            if (taskDefinitionKeyIn !== undefined) {
                localVarQueryParameter['taskDefinitionKeyIn'] = taskDefinitionKeyIn;
            }

            if (taskDefinitionKeyLike !== undefined) {
                localVarQueryParameter['taskDefinitionKeyLike'] = taskDefinitionKeyLike;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameNotEqual !== undefined) {
                localVarQueryParameter['nameNotEqual'] = nameNotEqual;
            }

            if (nameLike !== undefined) {
                localVarQueryParameter['nameLike'] = nameLike;
            }

            if (nameNotLike !== undefined) {
                localVarQueryParameter['nameNotLike'] = nameNotLike;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (descriptionLike !== undefined) {
                localVarQueryParameter['descriptionLike'] = descriptionLike;
            }

            if (priority !== undefined) {
                localVarQueryParameter['priority'] = priority;
            }

            if (maxPriority !== undefined) {
                localVarQueryParameter['maxPriority'] = maxPriority;
            }

            if (minPriority !== undefined) {
                localVarQueryParameter['minPriority'] = minPriority;
            }

            if (dueDate !== undefined) {
                localVarQueryParameter['dueDate'] = dueDate;
            }

            if (dueDateExpression !== undefined) {
                localVarQueryParameter['dueDateExpression'] = dueDateExpression;
            }

            if (dueAfter !== undefined) {
                localVarQueryParameter['dueAfter'] = dueAfter;
            }

            if (dueAfterExpression !== undefined) {
                localVarQueryParameter['dueAfterExpression'] = dueAfterExpression;
            }

            if (dueBefore !== undefined) {
                localVarQueryParameter['dueBefore'] = dueBefore;
            }

            if (dueBeforeExpression !== undefined) {
                localVarQueryParameter['dueBeforeExpression'] = dueBeforeExpression;
            }

            if (withoutDueDate !== undefined) {
                localVarQueryParameter['withoutDueDate'] = withoutDueDate;
            }

            if (followUpDate !== undefined) {
                localVarQueryParameter['followUpDate'] = followUpDate;
            }

            if (followUpDateExpression !== undefined) {
                localVarQueryParameter['followUpDateExpression'] = followUpDateExpression;
            }

            if (followUpAfter !== undefined) {
                localVarQueryParameter['followUpAfter'] = followUpAfter;
            }

            if (followUpAfterExpression !== undefined) {
                localVarQueryParameter['followUpAfterExpression'] = followUpAfterExpression;
            }

            if (followUpBefore !== undefined) {
                localVarQueryParameter['followUpBefore'] = followUpBefore;
            }

            if (followUpBeforeExpression !== undefined) {
                localVarQueryParameter['followUpBeforeExpression'] = followUpBeforeExpression;
            }

            if (followUpBeforeOrNotExistent !== undefined) {
                localVarQueryParameter['followUpBeforeOrNotExistent'] = followUpBeforeOrNotExistent;
            }

            if (followUpBeforeOrNotExistentExpression !== undefined) {
                localVarQueryParameter['followUpBeforeOrNotExistentExpression'] = followUpBeforeOrNotExistentExpression;
            }

            if (createdOn !== undefined) {
                localVarQueryParameter['createdOn'] = createdOn;
            }

            if (createdOnExpression !== undefined) {
                localVarQueryParameter['createdOnExpression'] = createdOnExpression;
            }

            if (createdAfter !== undefined) {
                localVarQueryParameter['createdAfter'] = createdAfter;
            }

            if (createdAfterExpression !== undefined) {
                localVarQueryParameter['createdAfterExpression'] = createdAfterExpression;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['createdBefore'] = createdBefore;
            }

            if (createdBeforeExpression !== undefined) {
                localVarQueryParameter['createdBeforeExpression'] = createdBeforeExpression;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updatedAfter'] = updatedAfter;
            }

            if (updatedAfterExpression !== undefined) {
                localVarQueryParameter['updatedAfterExpression'] = updatedAfterExpression;
            }

            if (delegationState !== undefined) {
                localVarQueryParameter['delegationState'] = delegationState;
            }

            if (candidateGroups !== undefined) {
                localVarQueryParameter['candidateGroups'] = candidateGroups;
            }

            if (candidateGroupsExpression !== undefined) {
                localVarQueryParameter['candidateGroupsExpression'] = candidateGroupsExpression;
            }

            if (withCandidateGroups !== undefined) {
                localVarQueryParameter['withCandidateGroups'] = withCandidateGroups;
            }

            if (withoutCandidateGroups !== undefined) {
                localVarQueryParameter['withoutCandidateGroups'] = withoutCandidateGroups;
            }

            if (withCandidateUsers !== undefined) {
                localVarQueryParameter['withCandidateUsers'] = withCandidateUsers;
            }

            if (withoutCandidateUsers !== undefined) {
                localVarQueryParameter['withoutCandidateUsers'] = withoutCandidateUsers;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (suspended !== undefined) {
                localVarQueryParameter['suspended'] = suspended;
            }

            if (taskVariables !== undefined) {
                localVarQueryParameter['taskVariables'] = taskVariables;
            }

            if (processVariables !== undefined) {
                localVarQueryParameter['processVariables'] = processVariables;
            }

            if (caseInstanceVariables !== undefined) {
                localVarQueryParameter['caseInstanceVariables'] = caseInstanceVariables;
            }

            if (variableNamesIgnoreCase !== undefined) {
                localVarQueryParameter['variableNamesIgnoreCase'] = variableNamesIgnoreCase;
            }

            if (variableValuesIgnoreCase !== undefined) {
                localVarQueryParameter['variableValuesIgnoreCase'] = variableValuesIgnoreCase;
            }

            if (parentTaskId !== undefined) {
                localVarQueryParameter['parentTaskId'] = parentTaskId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Reports a business error in the context of a running task by id. The error code must be specified to identify the BPMN error handler. See the documentation for [Reporting Bpmn Error](https://docs.camunda.org/manual/7.18/reference/bpmn20/tasks/user-task/#reporting-bpmn-error) in User Tasks.
         * @summary Handle BPMN Error
         * @param {string} id The id of the task a BPMN error is reported for.
         * @param {TaskBpmnErrorDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleBpmnError: async (id: string, body?: TaskBpmnErrorDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling handleBpmnError.');
            }
            const localVarPath = `/task/{id}/bpmnError`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Reports an escalation in the context of a running task by id. The escalation code must be specified to identify the escalation handler. See the documentation for [Reporting Bpmn Escalation](https://docs.camunda.org/manual/7.18/reference/bpmn20/tasks/user-task/#reporting-bpmn-escalation) in User Tasks.
         * @summary Handle BPMN Escalation
         * @param {string} id The id of the task in which context a BPMN escalation is reported.
         * @param {TaskEscalationDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleEscalation: async (id: string, body?: TaskEscalationDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling handleEscalation.');
            }
            const localVarPath = `/task/{id}/bpmnEscalation`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for tasks that fulfill a given filter. This method is slightly more powerful than the [Get Tasks](https://docs.camunda.org/manual/7.18/reference/rest/task/get-query/) method because it allows filtering by multiple process or task variables of types `String`, `Number` or `Boolean`. The size of the result set can be retrieved by using the [Get Task Count (POST)](https://docs.camunda.org/manual/7.18/reference/rest/task/post-query-count/) method.  **Security Consideration**: There are several parameters (such as `assigneeExpression`) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.18/user-guide/process-engine/securing-custom-code/) in the user guide for details.
         * @summary Get List (POST)
         * @param {TaskQueryDto} [body] 
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryTasks: async (body?: TaskQueryDto, firstResult?: number, maxResults?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/task`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the number of tasks that fulfill the given filter. Corresponds to the size of the result set of the [Get Tasks (POST)](https://docs.camunda.org/manual/7.18/reference/rest/task/post-query/) method and takes the same parameters.  **Security Consideration**: There are several parameters (such as `assigneeExpression`) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.18/user-guide/process-engine/securing-custom-code/) in the user guide for details.
         * @summary Get List Count (POST)
         * @param {TaskQueryDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryTasksCount: async (body?: TaskQueryDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/task/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Resolves a task and updates execution variables.  Resolving a task marks that the assignee is done with the task delegated to them, and that it can be sent back to the owner. Can only be executed when the task has been delegated. The assignee will be set to the owner, who performed the delegation.
         * @summary Resolve
         * @param {string} id The id of the task to resolve.
         * @param {CompleteTaskDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolve: async (id: string, body?: CompleteTaskDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling resolve.');
            }
            const localVarPath = `/task/{id}/resolve`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes the assignee of a task to a specific user.  **Note:** The difference with the [Claim Task](https://docs.camunda.org/manual/7.18/reference/rest/task/post-claim/) method is that this method does not check if the task already has a user assigned to it.
         * @summary Set Assignee
         * @param {string} id The id of the task to set the assignee for.
         * @param {UserIdDto} [body] Provide the id of the user that will be the assignee of the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAssignee: async (id: string, body?: UserIdDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling setAssignee.');
            }
            const localVarPath = `/task/{id}/assignee`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Completes a task and updates process variables using a form submit. There are two difference between this method and the `complete` method:  * If the task is in state `PENDING` - i.e., has been delegated before, it is not completed but resolved. Otherwise it will be completed. * If the task has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See the [Generated Task Forms](https://docs.camunda.org/manual/7.18/user-guide/task-forms/_index/#generated-task-forms) section of the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/) for more information.
         * @summary Submit Form
         * @param {string} id The id of the task to submit the form for.
         * @param {CompleteTaskDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submit: async (id: string, body?: CompleteTaskDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling submit.');
            }
            const localVarPath = `/task/{id}/submit-form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Resets a task's assignee. If successful, the task is not assigned to a user.
         * @summary Unclaim
         * @param {string} id The id of the task to unclaim.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unclaim: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling unclaim.');
            }
            const localVarPath = `/task/{id}/unclaim`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a task.
         * @summary Update
         * @param {string} id The id of the task to be updated.
         * @param {TaskDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask: async (id: string, body?: TaskDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateTask.');
            }
            const localVarPath = `/task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskApi - functional programming interface
 * @export
 */
export const TaskApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Claims a task for a specific user.  **Note:** The difference with the [Set Assignee](https://docs.camunda.org/manual/7.18/reference/rest/task/post-assignee/) method is that here a check is performed to see if the task already has a user assigned to it.
         * @summary Claim
         * @param {string} id The id of the task to claim.
         * @param {UserIdDto} [body] Provide the id of the user that claims the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async claim(id: string, body?: UserIdDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).claim(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Completes a task and updates process variables.
         * @summary Complete
         * @param {string} id The id of the task to complete.
         * @param {CompleteTaskDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async complete(id: string, body?: CompleteTaskDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<{ [key: string]: VariableValueDto; }>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).complete(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a new task.
         * @summary Create
         * @param {TaskDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTask(body?: TaskDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).createTask(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delegates a task to another user.
         * @summary Delegate
         * @param {string} id The id of the task to delegate.
         * @param {UserIdDto} [body] Provide the id of the user that the task should be delegated to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delegateTask(id: string, body?: UserIdDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).delegateTask(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes a task by id.
         * @summary Delete
         * @param {string} id The id of the task to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTask(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).deleteTask(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves the deployed form that is referenced from a given task. For further information please refer to the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Form
         * @param {string} id The id of the task to get the deployed form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeployedForm(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Blob>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).getDeployedForm(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves the form key for a task. The form key corresponds to the `FormData#formKey` property in the engine. This key can be used to do task-specific form rendering in client applications. Additionally, the context path of the containing process application is returned.
         * @summary Get Form Key
         * @param {string} id The id of the task to retrieve the form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForm(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<FormDto>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).getForm(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves the form variables for a task. The form variables take form data specified on the task into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Task Form Variables
         * @param {string} id The id of the task to retrieve the variables for.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFormVariables(id: string, variableNames?: string, deserializeValues?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<{ [key: string]: VariableValueDto; }>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).getFormVariables(id, variableNames, deserializeValues, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves the rendered form for a task. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Form
         * @param {string} id The id of the task to get the rendered form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRenderedForm(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Blob>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).getRenderedForm(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves a task by id.
         * @summary Get
         * @param {string} id The id of the task to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTask(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<TaskDto>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).getTask(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Queries for tasks that fulfill a given filter. The size of the result set can be retrieved by using the Get Task Count method.  **Security Consideration:** There are several query parameters (such as assigneeExpression) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations](https://docs.camunda.org/manual/7.18/user-guide/process-engine/securing-custom-code/) for custom code in the user guide for details.
         * @summary Get List
         * @param {string} [taskId] Restrict to task with the given id.
         * @param {string} [taskIdIn] Restrict to tasks with any of the given ids.
         * @param {string} [processInstanceId] Restrict to tasks that belong to process instances with the given id.
         * @param {string} [processInstanceIdIn] Restrict to tasks that belong to process instances with the given ids.
         * @param {string} [processInstanceBusinessKey] Restrict to tasks that belong to process instances with the given business key.
         * @param {string} [processInstanceBusinessKeyExpression] Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {string} [processInstanceBusinessKeyIn] Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
         * @param {string} [processInstanceBusinessKeyLike] Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
         * @param {string} [processInstanceBusinessKeyLikeExpression] Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [processDefinitionId] Restrict to tasks that belong to a process definition with the given id.
         * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
         * @param {string} [processDefinitionKeyIn] Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
         * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
         * @param {string} [processDefinitionNameLike] Restrict to tasks that have a process definition name that has the parameter value as  a substring.
         * @param {string} [executionId] Restrict to tasks that belong to an execution with the given id.
         * @param {string} [caseInstanceId] Restrict to tasks that belong to case instances with the given id.
         * @param {string} [caseInstanceBusinessKey] Restrict to tasks that belong to case instances with the given business key.
         * @param {string} [caseInstanceBusinessKeyLike] Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
         * @param {string} [caseDefinitionId] Restrict to tasks that belong to a case definition with the given id.
         * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
         * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
         * @param {string} [caseDefinitionNameLike] Restrict to tasks that have a case definition name that has the parameter value as a  substring.
         * @param {string} [caseExecutionId] Restrict to tasks that belong to a case execution with the given id.
         * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
         * @param {string} [tenantIdIn] Only include tasks which belong to one of the passed and comma-separated  tenant ids.
         * @param {boolean} [withoutTenantId] Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
         * @param {string} [assignee] Restrict to tasks that the given user is assigned to.
         * @param {string} [assigneeExpression] Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeLike] Restrict to tasks that have an assignee that has the parameter  value as a substring.
         * @param {string} [assigneeLikeExpression] Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeIn] Only include tasks which are assigned to one of the passed and  comma-separated user ids.
         * @param {string} [assigneeNotIn] Only include tasks which are not assigned to one of the passed and comma-separated user ids.
         * @param {string} [owner] Restrict to tasks that the given user owns.
         * @param {string} [ownerExpression] Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateGroup] Only include tasks that are offered to the given group.
         * @param {string} [candidateGroupExpression] Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateUser] Only include tasks that are offered to the given user or to one of his groups.
         * @param {string} [candidateUserExpression] Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {boolean} [includeAssignedTasks] Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
         * @param {string} [involvedUser] Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
         * @param {string} [involvedUserExpression] Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
         * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
         * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
         * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
         * @param {string} [taskDefinitionKeyLike] Restrict to tasks that have a key that has the parameter value as a substring.
         * @param {string} [name] Restrict to tasks that have the given name.
         * @param {string} [nameNotEqual] Restrict to tasks that do not have the given name.
         * @param {string} [nameLike] Restrict to tasks that have a name with the given parameter value as substring.
         * @param {string} [nameNotLike] Restrict to tasks that do not have a name with the given parameter value as substring.
         * @param {string} [description] Restrict to tasks that have the given description.
         * @param {string} [descriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
         * @param {number} [priority] Restrict to tasks that have the given priority.
         * @param {number} [maxPriority] Restrict to tasks that have a lower or equal priority.
         * @param {number} [minPriority] Restrict to tasks that have a higher or equal priority.
         * @param {string} [dueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [dueDateExpression] Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
         * @param {string} [dueAfterExpression] Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
         * @param {string} [dueBeforeExpression] Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {boolean} [withoutDueDate] Only include tasks which have no due date. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
         * @param {string} [followUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [followUpDateExpression] Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
         * @param {string} [followUpAfterExpression] Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
         * @param {string} [followUpBeforeExpression] Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBeforeOrNotExistent] Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
         * @param {string} [followUpBeforeOrNotExistentExpression] Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdOn] Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
         * @param {string} [createdOnExpression] Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdAfter] Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [createdAfterExpression] Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdBefore] Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
         * @param {string} [createdBeforeExpression] Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [updatedAfter] Restrict to tasks that were updated after the given date. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.18/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
         * @param {string} [updatedAfterExpression] Restrict to tasks that were updated after the date described by the given expression. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.18/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [delegationState] Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
         * @param {string} [candidateGroups] Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
         * @param {string} [candidateGroupsExpression] Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
         * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withCandidateUsers] Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateUsers] Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;; &#x60;notLike&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [caseInstanceVariables] Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
         * @param {string} [parentTaskId] Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTasks(taskId?: string, taskIdIn?: string, processInstanceId?: string, processInstanceIdIn?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyExpression?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, processInstanceBusinessKeyLikeExpression?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionName?: string, processDefinitionNameLike?: string, executionId?: string, caseInstanceId?: string, caseInstanceBusinessKey?: string, caseInstanceBusinessKeyLike?: string, caseDefinitionId?: string, caseDefinitionKey?: string, caseDefinitionName?: string, caseDefinitionNameLike?: string, caseExecutionId?: string, activityInstanceIdIn?: string, tenantIdIn?: string, withoutTenantId?: boolean, assignee?: string, assigneeExpression?: string, assigneeLike?: string, assigneeLikeExpression?: string, assigneeIn?: string, assigneeNotIn?: string, owner?: string, ownerExpression?: string, candidateGroup?: string, candidateGroupExpression?: string, candidateUser?: string, candidateUserExpression?: string, includeAssignedTasks?: boolean, involvedUser?: string, involvedUserExpression?: string, assigned?: boolean, unassigned?: boolean, taskDefinitionKey?: string, taskDefinitionKeyIn?: string, taskDefinitionKeyLike?: string, name?: string, nameNotEqual?: string, nameLike?: string, nameNotLike?: string, description?: string, descriptionLike?: string, priority?: number, maxPriority?: number, minPriority?: number, dueDate?: string, dueDateExpression?: string, dueAfter?: string, dueAfterExpression?: string, dueBefore?: string, dueBeforeExpression?: string, withoutDueDate?: boolean, followUpDate?: string, followUpDateExpression?: string, followUpAfter?: string, followUpAfterExpression?: string, followUpBefore?: string, followUpBeforeExpression?: string, followUpBeforeOrNotExistent?: string, followUpBeforeOrNotExistentExpression?: string, createdOn?: string, createdOnExpression?: string, createdAfter?: string, createdAfterExpression?: string, createdBefore?: string, createdBeforeExpression?: string, updatedAfter?: string, updatedAfterExpression?: string, delegationState?: string, candidateGroups?: string, candidateGroupsExpression?: string, withCandidateGroups?: boolean, withoutCandidateGroups?: boolean, withCandidateUsers?: boolean, withoutCandidateUsers?: boolean, active?: boolean, suspended?: boolean, taskVariables?: string, processVariables?: string, caseInstanceVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, parentTaskId?: string, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<TaskDto>>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).getTasks(taskId, taskIdIn, processInstanceId, processInstanceIdIn, processInstanceBusinessKey, processInstanceBusinessKeyExpression, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, processInstanceBusinessKeyLikeExpression, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionName, processDefinitionNameLike, executionId, caseInstanceId, caseInstanceBusinessKey, caseInstanceBusinessKeyLike, caseDefinitionId, caseDefinitionKey, caseDefinitionName, caseDefinitionNameLike, caseExecutionId, activityInstanceIdIn, tenantIdIn, withoutTenantId, assignee, assigneeExpression, assigneeLike, assigneeLikeExpression, assigneeIn, assigneeNotIn, owner, ownerExpression, candidateGroup, candidateGroupExpression, candidateUser, candidateUserExpression, includeAssignedTasks, involvedUser, involvedUserExpression, assigned, unassigned, taskDefinitionKey, taskDefinitionKeyIn, taskDefinitionKeyLike, name, nameNotEqual, nameLike, nameNotLike, description, descriptionLike, priority, maxPriority, minPriority, dueDate, dueDateExpression, dueAfter, dueAfterExpression, dueBefore, dueBeforeExpression, withoutDueDate, followUpDate, followUpDateExpression, followUpAfter, followUpAfterExpression, followUpBefore, followUpBeforeExpression, followUpBeforeOrNotExistent, followUpBeforeOrNotExistentExpression, createdOn, createdOnExpression, createdAfter, createdAfterExpression, createdBefore, createdBeforeExpression, updatedAfter, updatedAfterExpression, delegationState, candidateGroups, candidateGroupsExpression, withCandidateGroups, withoutCandidateGroups, withCandidateUsers, withoutCandidateUsers, active, suspended, taskVariables, processVariables, caseInstanceVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, parentTaskId, sortBy, sortOrder, firstResult, maxResults, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves the number of tasks that fulfill a provided filter. Corresponds to the size of the result set when using the [Get Tasks](https://docs.camunda.org/manual/7.18/reference/rest/task/) method.  **Security Consideration:** There are several query parameters (such as assigneeExpression) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations](https://docs.camunda.org/manual/7.18/user-guide/process-engine/securing-custom-code/) for custom code in the user guide for details.
         * @summary Get List Count
         * @param {string} [taskId] Restrict to task with the given id.
         * @param {string} [taskIdIn] Restrict to tasks with any of the given ids.
         * @param {string} [processInstanceId] Restrict to tasks that belong to process instances with the given id.
         * @param {string} [processInstanceIdIn] Restrict to tasks that belong to process instances with the given ids.
         * @param {string} [processInstanceBusinessKey] Restrict to tasks that belong to process instances with the given business key.
         * @param {string} [processInstanceBusinessKeyExpression] Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {string} [processInstanceBusinessKeyIn] Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
         * @param {string} [processInstanceBusinessKeyLike] Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
         * @param {string} [processInstanceBusinessKeyLikeExpression] Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [processDefinitionId] Restrict to tasks that belong to a process definition with the given id.
         * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
         * @param {string} [processDefinitionKeyIn] Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
         * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
         * @param {string} [processDefinitionNameLike] Restrict to tasks that have a process definition name that has the parameter value as  a substring.
         * @param {string} [executionId] Restrict to tasks that belong to an execution with the given id.
         * @param {string} [caseInstanceId] Restrict to tasks that belong to case instances with the given id.
         * @param {string} [caseInstanceBusinessKey] Restrict to tasks that belong to case instances with the given business key.
         * @param {string} [caseInstanceBusinessKeyLike] Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
         * @param {string} [caseDefinitionId] Restrict to tasks that belong to a case definition with the given id.
         * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
         * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
         * @param {string} [caseDefinitionNameLike] Restrict to tasks that have a case definition name that has the parameter value as a  substring.
         * @param {string} [caseExecutionId] Restrict to tasks that belong to a case execution with the given id.
         * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
         * @param {string} [tenantIdIn] Only include tasks which belong to one of the passed and comma-separated  tenant ids.
         * @param {boolean} [withoutTenantId] Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
         * @param {string} [assignee] Restrict to tasks that the given user is assigned to.
         * @param {string} [assigneeExpression] Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeLike] Restrict to tasks that have an assignee that has the parameter  value as a substring.
         * @param {string} [assigneeLikeExpression] Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeIn] Only include tasks which are assigned to one of the passed and  comma-separated user ids.
         * @param {string} [assigneeNotIn] Only include tasks which are not assigned to one of the passed and comma-separated user ids.
         * @param {string} [owner] Restrict to tasks that the given user owns.
         * @param {string} [ownerExpression] Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateGroup] Only include tasks that are offered to the given group.
         * @param {string} [candidateGroupExpression] Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateUser] Only include tasks that are offered to the given user or to one of his groups.
         * @param {string} [candidateUserExpression] Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {boolean} [includeAssignedTasks] Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
         * @param {string} [involvedUser] Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
         * @param {string} [involvedUserExpression] Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
         * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
         * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
         * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
         * @param {string} [taskDefinitionKeyLike] Restrict to tasks that have a key that has the parameter value as a substring.
         * @param {string} [name] Restrict to tasks that have the given name.
         * @param {string} [nameNotEqual] Restrict to tasks that do not have the given name.
         * @param {string} [nameLike] Restrict to tasks that have a name with the given parameter value as substring.
         * @param {string} [nameNotLike] Restrict to tasks that do not have a name with the given parameter value as substring.
         * @param {string} [description] Restrict to tasks that have the given description.
         * @param {string} [descriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
         * @param {number} [priority] Restrict to tasks that have the given priority.
         * @param {number} [maxPriority] Restrict to tasks that have a lower or equal priority.
         * @param {number} [minPriority] Restrict to tasks that have a higher or equal priority.
         * @param {string} [dueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [dueDateExpression] Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
         * @param {string} [dueAfterExpression] Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
         * @param {string} [dueBeforeExpression] Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {boolean} [withoutDueDate] Only include tasks which have no due date. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
         * @param {string} [followUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [followUpDateExpression] Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
         * @param {string} [followUpAfterExpression] Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
         * @param {string} [followUpBeforeExpression] Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBeforeOrNotExistent] Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
         * @param {string} [followUpBeforeOrNotExistentExpression] Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdOn] Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
         * @param {string} [createdOnExpression] Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdAfter] Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [createdAfterExpression] Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdBefore] Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
         * @param {string} [createdBeforeExpression] Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [updatedAfter] Restrict to tasks that were updated after the given date. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.18/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
         * @param {string} [updatedAfterExpression] Restrict to tasks that were updated after the date described by the given expression. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.18/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [delegationState] Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
         * @param {string} [candidateGroups] Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
         * @param {string} [candidateGroupsExpression] Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
         * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withCandidateUsers] Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateUsers] Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;; &#x60;notLike&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [caseInstanceVariables] Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
         * @param {string} [parentTaskId] Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTasksCount(taskId?: string, taskIdIn?: string, processInstanceId?: string, processInstanceIdIn?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyExpression?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, processInstanceBusinessKeyLikeExpression?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionName?: string, processDefinitionNameLike?: string, executionId?: string, caseInstanceId?: string, caseInstanceBusinessKey?: string, caseInstanceBusinessKeyLike?: string, caseDefinitionId?: string, caseDefinitionKey?: string, caseDefinitionName?: string, caseDefinitionNameLike?: string, caseExecutionId?: string, activityInstanceIdIn?: string, tenantIdIn?: string, withoutTenantId?: boolean, assignee?: string, assigneeExpression?: string, assigneeLike?: string, assigneeLikeExpression?: string, assigneeIn?: string, assigneeNotIn?: string, owner?: string, ownerExpression?: string, candidateGroup?: string, candidateGroupExpression?: string, candidateUser?: string, candidateUserExpression?: string, includeAssignedTasks?: boolean, involvedUser?: string, involvedUserExpression?: string, assigned?: boolean, unassigned?: boolean, taskDefinitionKey?: string, taskDefinitionKeyIn?: string, taskDefinitionKeyLike?: string, name?: string, nameNotEqual?: string, nameLike?: string, nameNotLike?: string, description?: string, descriptionLike?: string, priority?: number, maxPriority?: number, minPriority?: number, dueDate?: string, dueDateExpression?: string, dueAfter?: string, dueAfterExpression?: string, dueBefore?: string, dueBeforeExpression?: string, withoutDueDate?: boolean, followUpDate?: string, followUpDateExpression?: string, followUpAfter?: string, followUpAfterExpression?: string, followUpBefore?: string, followUpBeforeExpression?: string, followUpBeforeOrNotExistent?: string, followUpBeforeOrNotExistentExpression?: string, createdOn?: string, createdOnExpression?: string, createdAfter?: string, createdAfterExpression?: string, createdBefore?: string, createdBeforeExpression?: string, updatedAfter?: string, updatedAfterExpression?: string, delegationState?: string, candidateGroups?: string, candidateGroupsExpression?: string, withCandidateGroups?: boolean, withoutCandidateGroups?: boolean, withCandidateUsers?: boolean, withoutCandidateUsers?: boolean, active?: boolean, suspended?: boolean, taskVariables?: string, processVariables?: string, caseInstanceVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, parentTaskId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<CountResultDto>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).getTasksCount(taskId, taskIdIn, processInstanceId, processInstanceIdIn, processInstanceBusinessKey, processInstanceBusinessKeyExpression, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, processInstanceBusinessKeyLikeExpression, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionName, processDefinitionNameLike, executionId, caseInstanceId, caseInstanceBusinessKey, caseInstanceBusinessKeyLike, caseDefinitionId, caseDefinitionKey, caseDefinitionName, caseDefinitionNameLike, caseExecutionId, activityInstanceIdIn, tenantIdIn, withoutTenantId, assignee, assigneeExpression, assigneeLike, assigneeLikeExpression, assigneeIn, assigneeNotIn, owner, ownerExpression, candidateGroup, candidateGroupExpression, candidateUser, candidateUserExpression, includeAssignedTasks, involvedUser, involvedUserExpression, assigned, unassigned, taskDefinitionKey, taskDefinitionKeyIn, taskDefinitionKeyLike, name, nameNotEqual, nameLike, nameNotLike, description, descriptionLike, priority, maxPriority, minPriority, dueDate, dueDateExpression, dueAfter, dueAfterExpression, dueBefore, dueBeforeExpression, withoutDueDate, followUpDate, followUpDateExpression, followUpAfter, followUpAfterExpression, followUpBefore, followUpBeforeExpression, followUpBeforeOrNotExistent, followUpBeforeOrNotExistentExpression, createdOn, createdOnExpression, createdAfter, createdAfterExpression, createdBefore, createdBeforeExpression, updatedAfter, updatedAfterExpression, delegationState, candidateGroups, candidateGroupsExpression, withCandidateGroups, withoutCandidateGroups, withCandidateUsers, withoutCandidateUsers, active, suspended, taskVariables, processVariables, caseInstanceVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, parentTaskId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Reports a business error in the context of a running task by id. The error code must be specified to identify the BPMN error handler. See the documentation for [Reporting Bpmn Error](https://docs.camunda.org/manual/7.18/reference/bpmn20/tasks/user-task/#reporting-bpmn-error) in User Tasks.
         * @summary Handle BPMN Error
         * @param {string} id The id of the task a BPMN error is reported for.
         * @param {TaskBpmnErrorDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleBpmnError(id: string, body?: TaskBpmnErrorDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).handleBpmnError(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Reports an escalation in the context of a running task by id. The escalation code must be specified to identify the escalation handler. See the documentation for [Reporting Bpmn Escalation](https://docs.camunda.org/manual/7.18/reference/bpmn20/tasks/user-task/#reporting-bpmn-escalation) in User Tasks.
         * @summary Handle BPMN Escalation
         * @param {string} id The id of the task in which context a BPMN escalation is reported.
         * @param {TaskEscalationDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleEscalation(id: string, body?: TaskEscalationDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).handleEscalation(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Queries for tasks that fulfill a given filter. This method is slightly more powerful than the [Get Tasks](https://docs.camunda.org/manual/7.18/reference/rest/task/get-query/) method because it allows filtering by multiple process or task variables of types `String`, `Number` or `Boolean`. The size of the result set can be retrieved by using the [Get Task Count (POST)](https://docs.camunda.org/manual/7.18/reference/rest/task/post-query-count/) method.  **Security Consideration**: There are several parameters (such as `assigneeExpression`) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.18/user-guide/process-engine/securing-custom-code/) in the user guide for details.
         * @summary Get List (POST)
         * @param {TaskQueryDto} [body] 
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryTasks(body?: TaskQueryDto, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<TaskDto>>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).queryTasks(body, firstResult, maxResults, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves the number of tasks that fulfill the given filter. Corresponds to the size of the result set of the [Get Tasks (POST)](https://docs.camunda.org/manual/7.18/reference/rest/task/post-query/) method and takes the same parameters.  **Security Consideration**: There are several parameters (such as `assigneeExpression`) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.18/user-guide/process-engine/securing-custom-code/) in the user guide for details.
         * @summary Get List Count (POST)
         * @param {TaskQueryDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryTasksCount(body?: TaskQueryDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<CountResultDto>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).queryTasksCount(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Resolves a task and updates execution variables.  Resolving a task marks that the assignee is done with the task delegated to them, and that it can be sent back to the owner. Can only be executed when the task has been delegated. The assignee will be set to the owner, who performed the delegation.
         * @summary Resolve
         * @param {string} id The id of the task to resolve.
         * @param {CompleteTaskDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resolve(id: string, body?: CompleteTaskDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).resolve(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Changes the assignee of a task to a specific user.  **Note:** The difference with the [Claim Task](https://docs.camunda.org/manual/7.18/reference/rest/task/post-claim/) method is that this method does not check if the task already has a user assigned to it.
         * @summary Set Assignee
         * @param {string} id The id of the task to set the assignee for.
         * @param {UserIdDto} [body] Provide the id of the user that will be the assignee of the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setAssignee(id: string, body?: UserIdDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).setAssignee(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Completes a task and updates process variables using a form submit. There are two difference between this method and the `complete` method:  * If the task is in state `PENDING` - i.e., has been delegated before, it is not completed but resolved. Otherwise it will be completed. * If the task has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See the [Generated Task Forms](https://docs.camunda.org/manual/7.18/user-guide/task-forms/_index/#generated-task-forms) section of the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/) for more information.
         * @summary Submit Form
         * @param {string} id The id of the task to submit the form for.
         * @param {CompleteTaskDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submit(id: string, body?: CompleteTaskDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<{ [key: string]: VariableValueDto; }>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).submit(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Resets a task's assignee. If successful, the task is not assigned to a user.
         * @summary Unclaim
         * @param {string} id The id of the task to unclaim.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unclaim(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).unclaim(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates a task.
         * @summary Update
         * @param {string} id The id of the task to be updated.
         * @param {TaskDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTask(id: string, body?: TaskDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).updateTask(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TaskApi - factory interface
 * @export
 */
export const TaskApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Claims a task for a specific user.  **Note:** The difference with the [Set Assignee](https://docs.camunda.org/manual/7.18/reference/rest/task/post-assignee/) method is that here a check is performed to see if the task already has a user assigned to it.
         * @summary Claim
         * @param {string} id The id of the task to claim.
         * @param {UserIdDto} [body] Provide the id of the user that claims the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async claim(id: string, body?: UserIdDto, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return TaskApiFp(configuration).claim(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Completes a task and updates process variables.
         * @summary Complete
         * @param {string} id The id of the task to complete.
         * @param {CompleteTaskDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async complete(id: string, body?: CompleteTaskDto, options?: AxiosRequestConfig): Promise<AxiosResponse<{ [key: string]: VariableValueDto; }>> {
            return TaskApiFp(configuration).complete(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new task.
         * @summary Create
         * @param {TaskDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTask(body?: TaskDto, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return TaskApiFp(configuration).createTask(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Delegates a task to another user.
         * @summary Delegate
         * @param {string} id The id of the task to delegate.
         * @param {UserIdDto} [body] Provide the id of the user that the task should be delegated to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delegateTask(id: string, body?: UserIdDto, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return TaskApiFp(configuration).delegateTask(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a task by id.
         * @summary Delete
         * @param {string} id The id of the task to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTask(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return TaskApiFp(configuration).deleteTask(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the deployed form that is referenced from a given task. For further information please refer to the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Form
         * @param {string} id The id of the task to get the deployed form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeployedForm(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Blob>> {
            return TaskApiFp(configuration).getDeployedForm(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the form key for a task. The form key corresponds to the `FormData#formKey` property in the engine. This key can be used to do task-specific form rendering in client applications. Additionally, the context path of the containing process application is returned.
         * @summary Get Form Key
         * @param {string} id The id of the task to retrieve the form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForm(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<FormDto>> {
            return TaskApiFp(configuration).getForm(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the form variables for a task. The form variables take form data specified on the task into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Task Form Variables
         * @param {string} id The id of the task to retrieve the variables for.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFormVariables(id: string, variableNames?: string, deserializeValues?: boolean, options?: AxiosRequestConfig): Promise<AxiosResponse<{ [key: string]: VariableValueDto; }>> {
            return TaskApiFp(configuration).getFormVariables(id, variableNames, deserializeValues, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the rendered form for a task. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Form
         * @param {string} id The id of the task to get the rendered form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRenderedForm(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Blob>> {
            return TaskApiFp(configuration).getRenderedForm(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a task by id.
         * @summary Get
         * @param {string} id The id of the task to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTask(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<TaskDto>> {
            return TaskApiFp(configuration).getTask(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for tasks that fulfill a given filter. The size of the result set can be retrieved by using the Get Task Count method.  **Security Consideration:** There are several query parameters (such as assigneeExpression) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations](https://docs.camunda.org/manual/7.18/user-guide/process-engine/securing-custom-code/) for custom code in the user guide for details.
         * @summary Get List
         * @param {string} [taskId] Restrict to task with the given id.
         * @param {string} [taskIdIn] Restrict to tasks with any of the given ids.
         * @param {string} [processInstanceId] Restrict to tasks that belong to process instances with the given id.
         * @param {string} [processInstanceIdIn] Restrict to tasks that belong to process instances with the given ids.
         * @param {string} [processInstanceBusinessKey] Restrict to tasks that belong to process instances with the given business key.
         * @param {string} [processInstanceBusinessKeyExpression] Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {string} [processInstanceBusinessKeyIn] Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
         * @param {string} [processInstanceBusinessKeyLike] Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
         * @param {string} [processInstanceBusinessKeyLikeExpression] Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [processDefinitionId] Restrict to tasks that belong to a process definition with the given id.
         * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
         * @param {string} [processDefinitionKeyIn] Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
         * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
         * @param {string} [processDefinitionNameLike] Restrict to tasks that have a process definition name that has the parameter value as  a substring.
         * @param {string} [executionId] Restrict to tasks that belong to an execution with the given id.
         * @param {string} [caseInstanceId] Restrict to tasks that belong to case instances with the given id.
         * @param {string} [caseInstanceBusinessKey] Restrict to tasks that belong to case instances with the given business key.
         * @param {string} [caseInstanceBusinessKeyLike] Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
         * @param {string} [caseDefinitionId] Restrict to tasks that belong to a case definition with the given id.
         * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
         * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
         * @param {string} [caseDefinitionNameLike] Restrict to tasks that have a case definition name that has the parameter value as a  substring.
         * @param {string} [caseExecutionId] Restrict to tasks that belong to a case execution with the given id.
         * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
         * @param {string} [tenantIdIn] Only include tasks which belong to one of the passed and comma-separated  tenant ids.
         * @param {boolean} [withoutTenantId] Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
         * @param {string} [assignee] Restrict to tasks that the given user is assigned to.
         * @param {string} [assigneeExpression] Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeLike] Restrict to tasks that have an assignee that has the parameter  value as a substring.
         * @param {string} [assigneeLikeExpression] Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeIn] Only include tasks which are assigned to one of the passed and  comma-separated user ids.
         * @param {string} [assigneeNotIn] Only include tasks which are not assigned to one of the passed and comma-separated user ids.
         * @param {string} [owner] Restrict to tasks that the given user owns.
         * @param {string} [ownerExpression] Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateGroup] Only include tasks that are offered to the given group.
         * @param {string} [candidateGroupExpression] Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateUser] Only include tasks that are offered to the given user or to one of his groups.
         * @param {string} [candidateUserExpression] Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {boolean} [includeAssignedTasks] Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
         * @param {string} [involvedUser] Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
         * @param {string} [involvedUserExpression] Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
         * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
         * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
         * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
         * @param {string} [taskDefinitionKeyLike] Restrict to tasks that have a key that has the parameter value as a substring.
         * @param {string} [name] Restrict to tasks that have the given name.
         * @param {string} [nameNotEqual] Restrict to tasks that do not have the given name.
         * @param {string} [nameLike] Restrict to tasks that have a name with the given parameter value as substring.
         * @param {string} [nameNotLike] Restrict to tasks that do not have a name with the given parameter value as substring.
         * @param {string} [description] Restrict to tasks that have the given description.
         * @param {string} [descriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
         * @param {number} [priority] Restrict to tasks that have the given priority.
         * @param {number} [maxPriority] Restrict to tasks that have a lower or equal priority.
         * @param {number} [minPriority] Restrict to tasks that have a higher or equal priority.
         * @param {string} [dueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [dueDateExpression] Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
         * @param {string} [dueAfterExpression] Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
         * @param {string} [dueBeforeExpression] Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {boolean} [withoutDueDate] Only include tasks which have no due date. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
         * @param {string} [followUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [followUpDateExpression] Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
         * @param {string} [followUpAfterExpression] Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
         * @param {string} [followUpBeforeExpression] Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBeforeOrNotExistent] Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
         * @param {string} [followUpBeforeOrNotExistentExpression] Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdOn] Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
         * @param {string} [createdOnExpression] Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdAfter] Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [createdAfterExpression] Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdBefore] Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
         * @param {string} [createdBeforeExpression] Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [updatedAfter] Restrict to tasks that were updated after the given date. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.18/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
         * @param {string} [updatedAfterExpression] Restrict to tasks that were updated after the date described by the given expression. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.18/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [delegationState] Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
         * @param {string} [candidateGroups] Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
         * @param {string} [candidateGroupsExpression] Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
         * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withCandidateUsers] Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateUsers] Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;; &#x60;notLike&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [caseInstanceVariables] Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
         * @param {string} [parentTaskId] Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTasks(taskId?: string, taskIdIn?: string, processInstanceId?: string, processInstanceIdIn?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyExpression?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, processInstanceBusinessKeyLikeExpression?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionName?: string, processDefinitionNameLike?: string, executionId?: string, caseInstanceId?: string, caseInstanceBusinessKey?: string, caseInstanceBusinessKeyLike?: string, caseDefinitionId?: string, caseDefinitionKey?: string, caseDefinitionName?: string, caseDefinitionNameLike?: string, caseExecutionId?: string, activityInstanceIdIn?: string, tenantIdIn?: string, withoutTenantId?: boolean, assignee?: string, assigneeExpression?: string, assigneeLike?: string, assigneeLikeExpression?: string, assigneeIn?: string, assigneeNotIn?: string, owner?: string, ownerExpression?: string, candidateGroup?: string, candidateGroupExpression?: string, candidateUser?: string, candidateUserExpression?: string, includeAssignedTasks?: boolean, involvedUser?: string, involvedUserExpression?: string, assigned?: boolean, unassigned?: boolean, taskDefinitionKey?: string, taskDefinitionKeyIn?: string, taskDefinitionKeyLike?: string, name?: string, nameNotEqual?: string, nameLike?: string, nameNotLike?: string, description?: string, descriptionLike?: string, priority?: number, maxPriority?: number, minPriority?: number, dueDate?: string, dueDateExpression?: string, dueAfter?: string, dueAfterExpression?: string, dueBefore?: string, dueBeforeExpression?: string, withoutDueDate?: boolean, followUpDate?: string, followUpDateExpression?: string, followUpAfter?: string, followUpAfterExpression?: string, followUpBefore?: string, followUpBeforeExpression?: string, followUpBeforeOrNotExistent?: string, followUpBeforeOrNotExistentExpression?: string, createdOn?: string, createdOnExpression?: string, createdAfter?: string, createdAfterExpression?: string, createdBefore?: string, createdBeforeExpression?: string, updatedAfter?: string, updatedAfterExpression?: string, delegationState?: string, candidateGroups?: string, candidateGroupsExpression?: string, withCandidateGroups?: boolean, withoutCandidateGroups?: boolean, withCandidateUsers?: boolean, withoutCandidateUsers?: boolean, active?: boolean, suspended?: boolean, taskVariables?: string, processVariables?: string, caseInstanceVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, parentTaskId?: string, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<TaskDto>>> {
            return TaskApiFp(configuration).getTasks(taskId, taskIdIn, processInstanceId, processInstanceIdIn, processInstanceBusinessKey, processInstanceBusinessKeyExpression, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, processInstanceBusinessKeyLikeExpression, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionName, processDefinitionNameLike, executionId, caseInstanceId, caseInstanceBusinessKey, caseInstanceBusinessKeyLike, caseDefinitionId, caseDefinitionKey, caseDefinitionName, caseDefinitionNameLike, caseExecutionId, activityInstanceIdIn, tenantIdIn, withoutTenantId, assignee, assigneeExpression, assigneeLike, assigneeLikeExpression, assigneeIn, assigneeNotIn, owner, ownerExpression, candidateGroup, candidateGroupExpression, candidateUser, candidateUserExpression, includeAssignedTasks, involvedUser, involvedUserExpression, assigned, unassigned, taskDefinitionKey, taskDefinitionKeyIn, taskDefinitionKeyLike, name, nameNotEqual, nameLike, nameNotLike, description, descriptionLike, priority, maxPriority, minPriority, dueDate, dueDateExpression, dueAfter, dueAfterExpression, dueBefore, dueBeforeExpression, withoutDueDate, followUpDate, followUpDateExpression, followUpAfter, followUpAfterExpression, followUpBefore, followUpBeforeExpression, followUpBeforeOrNotExistent, followUpBeforeOrNotExistentExpression, createdOn, createdOnExpression, createdAfter, createdAfterExpression, createdBefore, createdBeforeExpression, updatedAfter, updatedAfterExpression, delegationState, candidateGroups, candidateGroupsExpression, withCandidateGroups, withoutCandidateGroups, withCandidateUsers, withoutCandidateUsers, active, suspended, taskVariables, processVariables, caseInstanceVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, parentTaskId, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the number of tasks that fulfill a provided filter. Corresponds to the size of the result set when using the [Get Tasks](https://docs.camunda.org/manual/7.18/reference/rest/task/) method.  **Security Consideration:** There are several query parameters (such as assigneeExpression) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations](https://docs.camunda.org/manual/7.18/user-guide/process-engine/securing-custom-code/) for custom code in the user guide for details.
         * @summary Get List Count
         * @param {string} [taskId] Restrict to task with the given id.
         * @param {string} [taskIdIn] Restrict to tasks with any of the given ids.
         * @param {string} [processInstanceId] Restrict to tasks that belong to process instances with the given id.
         * @param {string} [processInstanceIdIn] Restrict to tasks that belong to process instances with the given ids.
         * @param {string} [processInstanceBusinessKey] Restrict to tasks that belong to process instances with the given business key.
         * @param {string} [processInstanceBusinessKeyExpression] Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {string} [processInstanceBusinessKeyIn] Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
         * @param {string} [processInstanceBusinessKeyLike] Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
         * @param {string} [processInstanceBusinessKeyLikeExpression] Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [processDefinitionId] Restrict to tasks that belong to a process definition with the given id.
         * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
         * @param {string} [processDefinitionKeyIn] Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
         * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
         * @param {string} [processDefinitionNameLike] Restrict to tasks that have a process definition name that has the parameter value as  a substring.
         * @param {string} [executionId] Restrict to tasks that belong to an execution with the given id.
         * @param {string} [caseInstanceId] Restrict to tasks that belong to case instances with the given id.
         * @param {string} [caseInstanceBusinessKey] Restrict to tasks that belong to case instances with the given business key.
         * @param {string} [caseInstanceBusinessKeyLike] Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
         * @param {string} [caseDefinitionId] Restrict to tasks that belong to a case definition with the given id.
         * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
         * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
         * @param {string} [caseDefinitionNameLike] Restrict to tasks that have a case definition name that has the parameter value as a  substring.
         * @param {string} [caseExecutionId] Restrict to tasks that belong to a case execution with the given id.
         * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
         * @param {string} [tenantIdIn] Only include tasks which belong to one of the passed and comma-separated  tenant ids.
         * @param {boolean} [withoutTenantId] Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
         * @param {string} [assignee] Restrict to tasks that the given user is assigned to.
         * @param {string} [assigneeExpression] Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeLike] Restrict to tasks that have an assignee that has the parameter  value as a substring.
         * @param {string} [assigneeLikeExpression] Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeIn] Only include tasks which are assigned to one of the passed and  comma-separated user ids.
         * @param {string} [assigneeNotIn] Only include tasks which are not assigned to one of the passed and comma-separated user ids.
         * @param {string} [owner] Restrict to tasks that the given user owns.
         * @param {string} [ownerExpression] Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateGroup] Only include tasks that are offered to the given group.
         * @param {string} [candidateGroupExpression] Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateUser] Only include tasks that are offered to the given user or to one of his groups.
         * @param {string} [candidateUserExpression] Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {boolean} [includeAssignedTasks] Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
         * @param {string} [involvedUser] Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
         * @param {string} [involvedUserExpression] Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
         * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
         * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
         * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
         * @param {string} [taskDefinitionKeyLike] Restrict to tasks that have a key that has the parameter value as a substring.
         * @param {string} [name] Restrict to tasks that have the given name.
         * @param {string} [nameNotEqual] Restrict to tasks that do not have the given name.
         * @param {string} [nameLike] Restrict to tasks that have a name with the given parameter value as substring.
         * @param {string} [nameNotLike] Restrict to tasks that do not have a name with the given parameter value as substring.
         * @param {string} [description] Restrict to tasks that have the given description.
         * @param {string} [descriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
         * @param {number} [priority] Restrict to tasks that have the given priority.
         * @param {number} [maxPriority] Restrict to tasks that have a lower or equal priority.
         * @param {number} [minPriority] Restrict to tasks that have a higher or equal priority.
         * @param {string} [dueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [dueDateExpression] Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
         * @param {string} [dueAfterExpression] Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
         * @param {string} [dueBeforeExpression] Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {boolean} [withoutDueDate] Only include tasks which have no due date. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
         * @param {string} [followUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [followUpDateExpression] Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
         * @param {string} [followUpAfterExpression] Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
         * @param {string} [followUpBeforeExpression] Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBeforeOrNotExistent] Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
         * @param {string} [followUpBeforeOrNotExistentExpression] Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdOn] Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
         * @param {string} [createdOnExpression] Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdAfter] Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [createdAfterExpression] Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdBefore] Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
         * @param {string} [createdBeforeExpression] Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [updatedAfter] Restrict to tasks that were updated after the given date. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.18/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
         * @param {string} [updatedAfterExpression] Restrict to tasks that were updated after the date described by the given expression. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.18/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [delegationState] Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
         * @param {string} [candidateGroups] Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
         * @param {string} [candidateGroupsExpression] Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
         * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withCandidateUsers] Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateUsers] Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;; &#x60;notLike&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [caseInstanceVariables] Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
         * @param {string} [parentTaskId] Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTasksCount(taskId?: string, taskIdIn?: string, processInstanceId?: string, processInstanceIdIn?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyExpression?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, processInstanceBusinessKeyLikeExpression?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionName?: string, processDefinitionNameLike?: string, executionId?: string, caseInstanceId?: string, caseInstanceBusinessKey?: string, caseInstanceBusinessKeyLike?: string, caseDefinitionId?: string, caseDefinitionKey?: string, caseDefinitionName?: string, caseDefinitionNameLike?: string, caseExecutionId?: string, activityInstanceIdIn?: string, tenantIdIn?: string, withoutTenantId?: boolean, assignee?: string, assigneeExpression?: string, assigneeLike?: string, assigneeLikeExpression?: string, assigneeIn?: string, assigneeNotIn?: string, owner?: string, ownerExpression?: string, candidateGroup?: string, candidateGroupExpression?: string, candidateUser?: string, candidateUserExpression?: string, includeAssignedTasks?: boolean, involvedUser?: string, involvedUserExpression?: string, assigned?: boolean, unassigned?: boolean, taskDefinitionKey?: string, taskDefinitionKeyIn?: string, taskDefinitionKeyLike?: string, name?: string, nameNotEqual?: string, nameLike?: string, nameNotLike?: string, description?: string, descriptionLike?: string, priority?: number, maxPriority?: number, minPriority?: number, dueDate?: string, dueDateExpression?: string, dueAfter?: string, dueAfterExpression?: string, dueBefore?: string, dueBeforeExpression?: string, withoutDueDate?: boolean, followUpDate?: string, followUpDateExpression?: string, followUpAfter?: string, followUpAfterExpression?: string, followUpBefore?: string, followUpBeforeExpression?: string, followUpBeforeOrNotExistent?: string, followUpBeforeOrNotExistentExpression?: string, createdOn?: string, createdOnExpression?: string, createdAfter?: string, createdAfterExpression?: string, createdBefore?: string, createdBeforeExpression?: string, updatedAfter?: string, updatedAfterExpression?: string, delegationState?: string, candidateGroups?: string, candidateGroupsExpression?: string, withCandidateGroups?: boolean, withoutCandidateGroups?: boolean, withCandidateUsers?: boolean, withoutCandidateUsers?: boolean, active?: boolean, suspended?: boolean, taskVariables?: string, processVariables?: string, caseInstanceVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, parentTaskId?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<CountResultDto>> {
            return TaskApiFp(configuration).getTasksCount(taskId, taskIdIn, processInstanceId, processInstanceIdIn, processInstanceBusinessKey, processInstanceBusinessKeyExpression, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, processInstanceBusinessKeyLikeExpression, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionName, processDefinitionNameLike, executionId, caseInstanceId, caseInstanceBusinessKey, caseInstanceBusinessKeyLike, caseDefinitionId, caseDefinitionKey, caseDefinitionName, caseDefinitionNameLike, caseExecutionId, activityInstanceIdIn, tenantIdIn, withoutTenantId, assignee, assigneeExpression, assigneeLike, assigneeLikeExpression, assigneeIn, assigneeNotIn, owner, ownerExpression, candidateGroup, candidateGroupExpression, candidateUser, candidateUserExpression, includeAssignedTasks, involvedUser, involvedUserExpression, assigned, unassigned, taskDefinitionKey, taskDefinitionKeyIn, taskDefinitionKeyLike, name, nameNotEqual, nameLike, nameNotLike, description, descriptionLike, priority, maxPriority, minPriority, dueDate, dueDateExpression, dueAfter, dueAfterExpression, dueBefore, dueBeforeExpression, withoutDueDate, followUpDate, followUpDateExpression, followUpAfter, followUpAfterExpression, followUpBefore, followUpBeforeExpression, followUpBeforeOrNotExistent, followUpBeforeOrNotExistentExpression, createdOn, createdOnExpression, createdAfter, createdAfterExpression, createdBefore, createdBeforeExpression, updatedAfter, updatedAfterExpression, delegationState, candidateGroups, candidateGroupsExpression, withCandidateGroups, withoutCandidateGroups, withCandidateUsers, withoutCandidateUsers, active, suspended, taskVariables, processVariables, caseInstanceVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, parentTaskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Reports a business error in the context of a running task by id. The error code must be specified to identify the BPMN error handler. See the documentation for [Reporting Bpmn Error](https://docs.camunda.org/manual/7.18/reference/bpmn20/tasks/user-task/#reporting-bpmn-error) in User Tasks.
         * @summary Handle BPMN Error
         * @param {string} id The id of the task a BPMN error is reported for.
         * @param {TaskBpmnErrorDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleBpmnError(id: string, body?: TaskBpmnErrorDto, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return TaskApiFp(configuration).handleBpmnError(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Reports an escalation in the context of a running task by id. The escalation code must be specified to identify the escalation handler. See the documentation for [Reporting Bpmn Escalation](https://docs.camunda.org/manual/7.18/reference/bpmn20/tasks/user-task/#reporting-bpmn-escalation) in User Tasks.
         * @summary Handle BPMN Escalation
         * @param {string} id The id of the task in which context a BPMN escalation is reported.
         * @param {TaskEscalationDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleEscalation(id: string, body?: TaskEscalationDto, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return TaskApiFp(configuration).handleEscalation(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for tasks that fulfill a given filter. This method is slightly more powerful than the [Get Tasks](https://docs.camunda.org/manual/7.18/reference/rest/task/get-query/) method because it allows filtering by multiple process or task variables of types `String`, `Number` or `Boolean`. The size of the result set can be retrieved by using the [Get Task Count (POST)](https://docs.camunda.org/manual/7.18/reference/rest/task/post-query-count/) method.  **Security Consideration**: There are several parameters (such as `assigneeExpression`) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.18/user-guide/process-engine/securing-custom-code/) in the user guide for details.
         * @summary Get List (POST)
         * @param {TaskQueryDto} [body] 
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryTasks(body?: TaskQueryDto, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<TaskDto>>> {
            return TaskApiFp(configuration).queryTasks(body, firstResult, maxResults, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the number of tasks that fulfill the given filter. Corresponds to the size of the result set of the [Get Tasks (POST)](https://docs.camunda.org/manual/7.18/reference/rest/task/post-query/) method and takes the same parameters.  **Security Consideration**: There are several parameters (such as `assigneeExpression`) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.18/user-guide/process-engine/securing-custom-code/) in the user guide for details.
         * @summary Get List Count (POST)
         * @param {TaskQueryDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryTasksCount(body?: TaskQueryDto, options?: AxiosRequestConfig): Promise<AxiosResponse<CountResultDto>> {
            return TaskApiFp(configuration).queryTasksCount(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Resolves a task and updates execution variables.  Resolving a task marks that the assignee is done with the task delegated to them, and that it can be sent back to the owner. Can only be executed when the task has been delegated. The assignee will be set to the owner, who performed the delegation.
         * @summary Resolve
         * @param {string} id The id of the task to resolve.
         * @param {CompleteTaskDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resolve(id: string, body?: CompleteTaskDto, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return TaskApiFp(configuration).resolve(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes the assignee of a task to a specific user.  **Note:** The difference with the [Claim Task](https://docs.camunda.org/manual/7.18/reference/rest/task/post-claim/) method is that this method does not check if the task already has a user assigned to it.
         * @summary Set Assignee
         * @param {string} id The id of the task to set the assignee for.
         * @param {UserIdDto} [body] Provide the id of the user that will be the assignee of the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setAssignee(id: string, body?: UserIdDto, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return TaskApiFp(configuration).setAssignee(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Completes a task and updates process variables using a form submit. There are two difference between this method and the `complete` method:  * If the task is in state `PENDING` - i.e., has been delegated before, it is not completed but resolved. Otherwise it will be completed. * If the task has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See the [Generated Task Forms](https://docs.camunda.org/manual/7.18/user-guide/task-forms/_index/#generated-task-forms) section of the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/) for more information.
         * @summary Submit Form
         * @param {string} id The id of the task to submit the form for.
         * @param {CompleteTaskDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submit(id: string, body?: CompleteTaskDto, options?: AxiosRequestConfig): Promise<AxiosResponse<{ [key: string]: VariableValueDto; }>> {
            return TaskApiFp(configuration).submit(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Resets a task's assignee. If successful, the task is not assigned to a user.
         * @summary Unclaim
         * @param {string} id The id of the task to unclaim.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unclaim(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return TaskApiFp(configuration).unclaim(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a task.
         * @summary Update
         * @param {string} id The id of the task to be updated.
         * @param {TaskDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTask(id: string, body?: TaskDto, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return TaskApiFp(configuration).updateTask(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TaskApi - object-oriented interface
 * @export
 * @class TaskApi
 * @extends {BaseAPI}
 */
export class TaskApi extends BaseAPI {
    /**
     * Claims a task for a specific user.  **Note:** The difference with the [Set Assignee](https://docs.camunda.org/manual/7.18/reference/rest/task/post-assignee/) method is that here a check is performed to see if the task already has a user assigned to it.
     * @summary Claim
     * @param {string} id The id of the task to claim.
     * @param {UserIdDto} [body] Provide the id of the user that claims the task.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public async claim(id: string, body?: UserIdDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return TaskApiFp(this.configuration).claim(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Completes a task and updates process variables.
     * @summary Complete
     * @param {string} id The id of the task to complete.
     * @param {CompleteTaskDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public async complete(id: string, body?: CompleteTaskDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<{ [key: string]: VariableValueDto; }>> {
        return TaskApiFp(this.configuration).complete(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new task.
     * @summary Create
     * @param {TaskDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public async createTask(body?: TaskDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return TaskApiFp(this.configuration).createTask(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delegates a task to another user.
     * @summary Delegate
     * @param {string} id The id of the task to delegate.
     * @param {UserIdDto} [body] Provide the id of the user that the task should be delegated to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public async delegateTask(id: string, body?: UserIdDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return TaskApiFp(this.configuration).delegateTask(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Removes a task by id.
     * @summary Delete
     * @param {string} id The id of the task to be removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public async deleteTask(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return TaskApiFp(this.configuration).deleteTask(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the deployed form that is referenced from a given task. For further information please refer to the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#embedded-task-forms).
     * @summary Get Deployed Form
     * @param {string} id The id of the task to get the deployed form for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public async getDeployedForm(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Blob>> {
        return TaskApiFp(this.configuration).getDeployedForm(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the form key for a task. The form key corresponds to the `FormData#formKey` property in the engine. This key can be used to do task-specific form rendering in client applications. Additionally, the context path of the containing process application is returned.
     * @summary Get Form Key
     * @param {string} id The id of the task to retrieve the form for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public async getForm(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<FormDto>> {
        return TaskApiFp(this.configuration).getForm(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the form variables for a task. The form variables take form data specified on the task into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
     * @summary Get Task Form Variables
     * @param {string} id The id of the task to retrieve the variables for.
     * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
     * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public async getFormVariables(id: string, variableNames?: string, deserializeValues?: boolean, options?: AxiosRequestConfig) : Promise<AxiosResponse<{ [key: string]: VariableValueDto; }>> {
        return TaskApiFp(this.configuration).getFormVariables(id, variableNames, deserializeValues, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the rendered form for a task. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms).
     * @summary Get Rendered Form
     * @param {string} id The id of the task to get the rendered form for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public async getRenderedForm(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Blob>> {
        return TaskApiFp(this.configuration).getRenderedForm(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a task by id.
     * @summary Get
     * @param {string} id The id of the task to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public async getTask(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<TaskDto>> {
        return TaskApiFp(this.configuration).getTask(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Queries for tasks that fulfill a given filter. The size of the result set can be retrieved by using the Get Task Count method.  **Security Consideration:** There are several query parameters (such as assigneeExpression) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations](https://docs.camunda.org/manual/7.18/user-guide/process-engine/securing-custom-code/) for custom code in the user guide for details.
     * @summary Get List
     * @param {string} [taskId] Restrict to task with the given id.
     * @param {string} [taskIdIn] Restrict to tasks with any of the given ids.
     * @param {string} [processInstanceId] Restrict to tasks that belong to process instances with the given id.
     * @param {string} [processInstanceIdIn] Restrict to tasks that belong to process instances with the given ids.
     * @param {string} [processInstanceBusinessKey] Restrict to tasks that belong to process instances with the given business key.
     * @param {string} [processInstanceBusinessKeyExpression] Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
     * @param {string} [processInstanceBusinessKeyIn] Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
     * @param {string} [processInstanceBusinessKeyLike] Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
     * @param {string} [processInstanceBusinessKeyLikeExpression] Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [processDefinitionId] Restrict to tasks that belong to a process definition with the given id.
     * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
     * @param {string} [processDefinitionKeyIn] Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
     * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
     * @param {string} [processDefinitionNameLike] Restrict to tasks that have a process definition name that has the parameter value as  a substring.
     * @param {string} [executionId] Restrict to tasks that belong to an execution with the given id.
     * @param {string} [caseInstanceId] Restrict to tasks that belong to case instances with the given id.
     * @param {string} [caseInstanceBusinessKey] Restrict to tasks that belong to case instances with the given business key.
     * @param {string} [caseInstanceBusinessKeyLike] Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
     * @param {string} [caseDefinitionId] Restrict to tasks that belong to a case definition with the given id.
     * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
     * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
     * @param {string} [caseDefinitionNameLike] Restrict to tasks that have a case definition name that has the parameter value as a  substring.
     * @param {string} [caseExecutionId] Restrict to tasks that belong to a case execution with the given id.
     * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
     * @param {string} [tenantIdIn] Only include tasks which belong to one of the passed and comma-separated  tenant ids.
     * @param {boolean} [withoutTenantId] Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
     * @param {string} [assignee] Restrict to tasks that the given user is assigned to.
     * @param {string} [assigneeExpression] Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [assigneeLike] Restrict to tasks that have an assignee that has the parameter  value as a substring.
     * @param {string} [assigneeLikeExpression] Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [assigneeIn] Only include tasks which are assigned to one of the passed and  comma-separated user ids.
     * @param {string} [assigneeNotIn] Only include tasks which are not assigned to one of the passed and comma-separated user ids.
     * @param {string} [owner] Restrict to tasks that the given user owns.
     * @param {string} [ownerExpression] Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [candidateGroup] Only include tasks that are offered to the given group.
     * @param {string} [candidateGroupExpression] Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [candidateUser] Only include tasks that are offered to the given user or to one of his groups.
     * @param {string} [candidateUserExpression] Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {boolean} [includeAssignedTasks] Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
     * @param {string} [involvedUser] Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
     * @param {string} [involvedUserExpression] Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
     * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
     * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
     * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
     * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
     * @param {string} [taskDefinitionKeyLike] Restrict to tasks that have a key that has the parameter value as a substring.
     * @param {string} [name] Restrict to tasks that have the given name.
     * @param {string} [nameNotEqual] Restrict to tasks that do not have the given name.
     * @param {string} [nameLike] Restrict to tasks that have a name with the given parameter value as substring.
     * @param {string} [nameNotLike] Restrict to tasks that do not have a name with the given parameter value as substring.
     * @param {string} [description] Restrict to tasks that have the given description.
     * @param {string} [descriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
     * @param {number} [priority] Restrict to tasks that have the given priority.
     * @param {number} [maxPriority] Restrict to tasks that have a lower or equal priority.
     * @param {number} [minPriority] Restrict to tasks that have a higher or equal priority.
     * @param {string} [dueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
     * @param {string} [dueDateExpression] Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [dueAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
     * @param {string} [dueAfterExpression] Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [dueBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
     * @param {string} [dueBeforeExpression] Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {boolean} [withoutDueDate] Only include tasks which have no due date. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
     * @param {string} [followUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
     * @param {string} [followUpDateExpression] Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [followUpAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
     * @param {string} [followUpAfterExpression] Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [followUpBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
     * @param {string} [followUpBeforeExpression] Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [followUpBeforeOrNotExistent] Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
     * @param {string} [followUpBeforeOrNotExistentExpression] Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [createdOn] Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
     * @param {string} [createdOnExpression] Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [createdAfter] Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
     * @param {string} [createdAfterExpression] Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [createdBefore] Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
     * @param {string} [createdBeforeExpression] Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [updatedAfter] Restrict to tasks that were updated after the given date. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.18/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
     * @param {string} [updatedAfterExpression] Restrict to tasks that were updated after the date described by the given expression. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.18/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [delegationState] Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
     * @param {string} [candidateGroups] Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
     * @param {string} [candidateGroupsExpression] Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
     * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [withCandidateUsers] Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [withoutCandidateUsers] Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;; &#x60;notLike&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {string} [caseInstanceVariables] Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
     * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
     * @param {string} [parentTaskId] Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
     * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public async getTasks(taskId?: string, taskIdIn?: string, processInstanceId?: string, processInstanceIdIn?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyExpression?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, processInstanceBusinessKeyLikeExpression?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionName?: string, processDefinitionNameLike?: string, executionId?: string, caseInstanceId?: string, caseInstanceBusinessKey?: string, caseInstanceBusinessKeyLike?: string, caseDefinitionId?: string, caseDefinitionKey?: string, caseDefinitionName?: string, caseDefinitionNameLike?: string, caseExecutionId?: string, activityInstanceIdIn?: string, tenantIdIn?: string, withoutTenantId?: boolean, assignee?: string, assigneeExpression?: string, assigneeLike?: string, assigneeLikeExpression?: string, assigneeIn?: string, assigneeNotIn?: string, owner?: string, ownerExpression?: string, candidateGroup?: string, candidateGroupExpression?: string, candidateUser?: string, candidateUserExpression?: string, includeAssignedTasks?: boolean, involvedUser?: string, involvedUserExpression?: string, assigned?: boolean, unassigned?: boolean, taskDefinitionKey?: string, taskDefinitionKeyIn?: string, taskDefinitionKeyLike?: string, name?: string, nameNotEqual?: string, nameLike?: string, nameNotLike?: string, description?: string, descriptionLike?: string, priority?: number, maxPriority?: number, minPriority?: number, dueDate?: string, dueDateExpression?: string, dueAfter?: string, dueAfterExpression?: string, dueBefore?: string, dueBeforeExpression?: string, withoutDueDate?: boolean, followUpDate?: string, followUpDateExpression?: string, followUpAfter?: string, followUpAfterExpression?: string, followUpBefore?: string, followUpBeforeExpression?: string, followUpBeforeOrNotExistent?: string, followUpBeforeOrNotExistentExpression?: string, createdOn?: string, createdOnExpression?: string, createdAfter?: string, createdAfterExpression?: string, createdBefore?: string, createdBeforeExpression?: string, updatedAfter?: string, updatedAfterExpression?: string, delegationState?: string, candidateGroups?: string, candidateGroupsExpression?: string, withCandidateGroups?: boolean, withoutCandidateGroups?: boolean, withCandidateUsers?: boolean, withoutCandidateUsers?: boolean, active?: boolean, suspended?: boolean, taskVariables?: string, processVariables?: string, caseInstanceVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, parentTaskId?: string, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<TaskDto>>> {
        return TaskApiFp(this.configuration).getTasks(taskId, taskIdIn, processInstanceId, processInstanceIdIn, processInstanceBusinessKey, processInstanceBusinessKeyExpression, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, processInstanceBusinessKeyLikeExpression, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionName, processDefinitionNameLike, executionId, caseInstanceId, caseInstanceBusinessKey, caseInstanceBusinessKeyLike, caseDefinitionId, caseDefinitionKey, caseDefinitionName, caseDefinitionNameLike, caseExecutionId, activityInstanceIdIn, tenantIdIn, withoutTenantId, assignee, assigneeExpression, assigneeLike, assigneeLikeExpression, assigneeIn, assigneeNotIn, owner, ownerExpression, candidateGroup, candidateGroupExpression, candidateUser, candidateUserExpression, includeAssignedTasks, involvedUser, involvedUserExpression, assigned, unassigned, taskDefinitionKey, taskDefinitionKeyIn, taskDefinitionKeyLike, name, nameNotEqual, nameLike, nameNotLike, description, descriptionLike, priority, maxPriority, minPriority, dueDate, dueDateExpression, dueAfter, dueAfterExpression, dueBefore, dueBeforeExpression, withoutDueDate, followUpDate, followUpDateExpression, followUpAfter, followUpAfterExpression, followUpBefore, followUpBeforeExpression, followUpBeforeOrNotExistent, followUpBeforeOrNotExistentExpression, createdOn, createdOnExpression, createdAfter, createdAfterExpression, createdBefore, createdBeforeExpression, updatedAfter, updatedAfterExpression, delegationState, candidateGroups, candidateGroupsExpression, withCandidateGroups, withoutCandidateGroups, withCandidateUsers, withoutCandidateUsers, active, suspended, taskVariables, processVariables, caseInstanceVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, parentTaskId, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the number of tasks that fulfill a provided filter. Corresponds to the size of the result set when using the [Get Tasks](https://docs.camunda.org/manual/7.18/reference/rest/task/) method.  **Security Consideration:** There are several query parameters (such as assigneeExpression) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations](https://docs.camunda.org/manual/7.18/user-guide/process-engine/securing-custom-code/) for custom code in the user guide for details.
     * @summary Get List Count
     * @param {string} [taskId] Restrict to task with the given id.
     * @param {string} [taskIdIn] Restrict to tasks with any of the given ids.
     * @param {string} [processInstanceId] Restrict to tasks that belong to process instances with the given id.
     * @param {string} [processInstanceIdIn] Restrict to tasks that belong to process instances with the given ids.
     * @param {string} [processInstanceBusinessKey] Restrict to tasks that belong to process instances with the given business key.
     * @param {string} [processInstanceBusinessKeyExpression] Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
     * @param {string} [processInstanceBusinessKeyIn] Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
     * @param {string} [processInstanceBusinessKeyLike] Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
     * @param {string} [processInstanceBusinessKeyLikeExpression] Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [processDefinitionId] Restrict to tasks that belong to a process definition with the given id.
     * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
     * @param {string} [processDefinitionKeyIn] Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
     * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
     * @param {string} [processDefinitionNameLike] Restrict to tasks that have a process definition name that has the parameter value as  a substring.
     * @param {string} [executionId] Restrict to tasks that belong to an execution with the given id.
     * @param {string} [caseInstanceId] Restrict to tasks that belong to case instances with the given id.
     * @param {string} [caseInstanceBusinessKey] Restrict to tasks that belong to case instances with the given business key.
     * @param {string} [caseInstanceBusinessKeyLike] Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
     * @param {string} [caseDefinitionId] Restrict to tasks that belong to a case definition with the given id.
     * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
     * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
     * @param {string} [caseDefinitionNameLike] Restrict to tasks that have a case definition name that has the parameter value as a  substring.
     * @param {string} [caseExecutionId] Restrict to tasks that belong to a case execution with the given id.
     * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
     * @param {string} [tenantIdIn] Only include tasks which belong to one of the passed and comma-separated  tenant ids.
     * @param {boolean} [withoutTenantId] Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
     * @param {string} [assignee] Restrict to tasks that the given user is assigned to.
     * @param {string} [assigneeExpression] Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [assigneeLike] Restrict to tasks that have an assignee that has the parameter  value as a substring.
     * @param {string} [assigneeLikeExpression] Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [assigneeIn] Only include tasks which are assigned to one of the passed and  comma-separated user ids.
     * @param {string} [assigneeNotIn] Only include tasks which are not assigned to one of the passed and comma-separated user ids.
     * @param {string} [owner] Restrict to tasks that the given user owns.
     * @param {string} [ownerExpression] Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [candidateGroup] Only include tasks that are offered to the given group.
     * @param {string} [candidateGroupExpression] Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [candidateUser] Only include tasks that are offered to the given user or to one of his groups.
     * @param {string} [candidateUserExpression] Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {boolean} [includeAssignedTasks] Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
     * @param {string} [involvedUser] Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
     * @param {string} [involvedUserExpression] Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
     * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
     * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
     * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
     * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
     * @param {string} [taskDefinitionKeyLike] Restrict to tasks that have a key that has the parameter value as a substring.
     * @param {string} [name] Restrict to tasks that have the given name.
     * @param {string} [nameNotEqual] Restrict to tasks that do not have the given name.
     * @param {string} [nameLike] Restrict to tasks that have a name with the given parameter value as substring.
     * @param {string} [nameNotLike] Restrict to tasks that do not have a name with the given parameter value as substring.
     * @param {string} [description] Restrict to tasks that have the given description.
     * @param {string} [descriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
     * @param {number} [priority] Restrict to tasks that have the given priority.
     * @param {number} [maxPriority] Restrict to tasks that have a lower or equal priority.
     * @param {number} [minPriority] Restrict to tasks that have a higher or equal priority.
     * @param {string} [dueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
     * @param {string} [dueDateExpression] Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [dueAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
     * @param {string} [dueAfterExpression] Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [dueBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
     * @param {string} [dueBeforeExpression] Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {boolean} [withoutDueDate] Only include tasks which have no due date. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
     * @param {string} [followUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
     * @param {string} [followUpDateExpression] Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [followUpAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
     * @param {string} [followUpAfterExpression] Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [followUpBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
     * @param {string} [followUpBeforeExpression] Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [followUpBeforeOrNotExistent] Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
     * @param {string} [followUpBeforeOrNotExistentExpression] Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [createdOn] Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
     * @param {string} [createdOnExpression] Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [createdAfter] Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
     * @param {string} [createdAfterExpression] Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [createdBefore] Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
     * @param {string} [createdBeforeExpression] Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [updatedAfter] Restrict to tasks that were updated after the given date. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.18/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
     * @param {string} [updatedAfterExpression] Restrict to tasks that were updated after the date described by the given expression. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.18/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [delegationState] Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
     * @param {string} [candidateGroups] Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
     * @param {string} [candidateGroupsExpression] Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
     * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [withCandidateUsers] Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [withoutCandidateUsers] Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;; &#x60;notLike&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {string} [caseInstanceVariables] Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
     * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
     * @param {string} [parentTaskId] Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public async getTasksCount(taskId?: string, taskIdIn?: string, processInstanceId?: string, processInstanceIdIn?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyExpression?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, processInstanceBusinessKeyLikeExpression?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionName?: string, processDefinitionNameLike?: string, executionId?: string, caseInstanceId?: string, caseInstanceBusinessKey?: string, caseInstanceBusinessKeyLike?: string, caseDefinitionId?: string, caseDefinitionKey?: string, caseDefinitionName?: string, caseDefinitionNameLike?: string, caseExecutionId?: string, activityInstanceIdIn?: string, tenantIdIn?: string, withoutTenantId?: boolean, assignee?: string, assigneeExpression?: string, assigneeLike?: string, assigneeLikeExpression?: string, assigneeIn?: string, assigneeNotIn?: string, owner?: string, ownerExpression?: string, candidateGroup?: string, candidateGroupExpression?: string, candidateUser?: string, candidateUserExpression?: string, includeAssignedTasks?: boolean, involvedUser?: string, involvedUserExpression?: string, assigned?: boolean, unassigned?: boolean, taskDefinitionKey?: string, taskDefinitionKeyIn?: string, taskDefinitionKeyLike?: string, name?: string, nameNotEqual?: string, nameLike?: string, nameNotLike?: string, description?: string, descriptionLike?: string, priority?: number, maxPriority?: number, minPriority?: number, dueDate?: string, dueDateExpression?: string, dueAfter?: string, dueAfterExpression?: string, dueBefore?: string, dueBeforeExpression?: string, withoutDueDate?: boolean, followUpDate?: string, followUpDateExpression?: string, followUpAfter?: string, followUpAfterExpression?: string, followUpBefore?: string, followUpBeforeExpression?: string, followUpBeforeOrNotExistent?: string, followUpBeforeOrNotExistentExpression?: string, createdOn?: string, createdOnExpression?: string, createdAfter?: string, createdAfterExpression?: string, createdBefore?: string, createdBeforeExpression?: string, updatedAfter?: string, updatedAfterExpression?: string, delegationState?: string, candidateGroups?: string, candidateGroupsExpression?: string, withCandidateGroups?: boolean, withoutCandidateGroups?: boolean, withCandidateUsers?: boolean, withoutCandidateUsers?: boolean, active?: boolean, suspended?: boolean, taskVariables?: string, processVariables?: string, caseInstanceVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, parentTaskId?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<CountResultDto>> {
        return TaskApiFp(this.configuration).getTasksCount(taskId, taskIdIn, processInstanceId, processInstanceIdIn, processInstanceBusinessKey, processInstanceBusinessKeyExpression, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, processInstanceBusinessKeyLikeExpression, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionName, processDefinitionNameLike, executionId, caseInstanceId, caseInstanceBusinessKey, caseInstanceBusinessKeyLike, caseDefinitionId, caseDefinitionKey, caseDefinitionName, caseDefinitionNameLike, caseExecutionId, activityInstanceIdIn, tenantIdIn, withoutTenantId, assignee, assigneeExpression, assigneeLike, assigneeLikeExpression, assigneeIn, assigneeNotIn, owner, ownerExpression, candidateGroup, candidateGroupExpression, candidateUser, candidateUserExpression, includeAssignedTasks, involvedUser, involvedUserExpression, assigned, unassigned, taskDefinitionKey, taskDefinitionKeyIn, taskDefinitionKeyLike, name, nameNotEqual, nameLike, nameNotLike, description, descriptionLike, priority, maxPriority, minPriority, dueDate, dueDateExpression, dueAfter, dueAfterExpression, dueBefore, dueBeforeExpression, withoutDueDate, followUpDate, followUpDateExpression, followUpAfter, followUpAfterExpression, followUpBefore, followUpBeforeExpression, followUpBeforeOrNotExistent, followUpBeforeOrNotExistentExpression, createdOn, createdOnExpression, createdAfter, createdAfterExpression, createdBefore, createdBeforeExpression, updatedAfter, updatedAfterExpression, delegationState, candidateGroups, candidateGroupsExpression, withCandidateGroups, withoutCandidateGroups, withCandidateUsers, withoutCandidateUsers, active, suspended, taskVariables, processVariables, caseInstanceVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, parentTaskId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Reports a business error in the context of a running task by id. The error code must be specified to identify the BPMN error handler. See the documentation for [Reporting Bpmn Error](https://docs.camunda.org/manual/7.18/reference/bpmn20/tasks/user-task/#reporting-bpmn-error) in User Tasks.
     * @summary Handle BPMN Error
     * @param {string} id The id of the task a BPMN error is reported for.
     * @param {TaskBpmnErrorDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public async handleBpmnError(id: string, body?: TaskBpmnErrorDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return TaskApiFp(this.configuration).handleBpmnError(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Reports an escalation in the context of a running task by id. The escalation code must be specified to identify the escalation handler. See the documentation for [Reporting Bpmn Escalation](https://docs.camunda.org/manual/7.18/reference/bpmn20/tasks/user-task/#reporting-bpmn-escalation) in User Tasks.
     * @summary Handle BPMN Escalation
     * @param {string} id The id of the task in which context a BPMN escalation is reported.
     * @param {TaskEscalationDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public async handleEscalation(id: string, body?: TaskEscalationDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return TaskApiFp(this.configuration).handleEscalation(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Queries for tasks that fulfill a given filter. This method is slightly more powerful than the [Get Tasks](https://docs.camunda.org/manual/7.18/reference/rest/task/get-query/) method because it allows filtering by multiple process or task variables of types `String`, `Number` or `Boolean`. The size of the result set can be retrieved by using the [Get Task Count (POST)](https://docs.camunda.org/manual/7.18/reference/rest/task/post-query-count/) method.  **Security Consideration**: There are several parameters (such as `assigneeExpression`) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.18/user-guide/process-engine/securing-custom-code/) in the user guide for details.
     * @summary Get List (POST)
     * @param {TaskQueryDto} [body] 
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public async queryTasks(body?: TaskQueryDto, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<TaskDto>>> {
        return TaskApiFp(this.configuration).queryTasks(body, firstResult, maxResults, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the number of tasks that fulfill the given filter. Corresponds to the size of the result set of the [Get Tasks (POST)](https://docs.camunda.org/manual/7.18/reference/rest/task/post-query/) method and takes the same parameters.  **Security Consideration**: There are several parameters (such as `assigneeExpression`) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.18/user-guide/process-engine/securing-custom-code/) in the user guide for details.
     * @summary Get List Count (POST)
     * @param {TaskQueryDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public async queryTasksCount(body?: TaskQueryDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<CountResultDto>> {
        return TaskApiFp(this.configuration).queryTasksCount(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Resolves a task and updates execution variables.  Resolving a task marks that the assignee is done with the task delegated to them, and that it can be sent back to the owner. Can only be executed when the task has been delegated. The assignee will be set to the owner, who performed the delegation.
     * @summary Resolve
     * @param {string} id The id of the task to resolve.
     * @param {CompleteTaskDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public async resolve(id: string, body?: CompleteTaskDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return TaskApiFp(this.configuration).resolve(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Changes the assignee of a task to a specific user.  **Note:** The difference with the [Claim Task](https://docs.camunda.org/manual/7.18/reference/rest/task/post-claim/) method is that this method does not check if the task already has a user assigned to it.
     * @summary Set Assignee
     * @param {string} id The id of the task to set the assignee for.
     * @param {UserIdDto} [body] Provide the id of the user that will be the assignee of the task.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public async setAssignee(id: string, body?: UserIdDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return TaskApiFp(this.configuration).setAssignee(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Completes a task and updates process variables using a form submit. There are two difference between this method and the `complete` method:  * If the task is in state `PENDING` - i.e., has been delegated before, it is not completed but resolved. Otherwise it will be completed. * If the task has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See the [Generated Task Forms](https://docs.camunda.org/manual/7.18/user-guide/task-forms/_index/#generated-task-forms) section of the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/) for more information.
     * @summary Submit Form
     * @param {string} id The id of the task to submit the form for.
     * @param {CompleteTaskDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public async submit(id: string, body?: CompleteTaskDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<{ [key: string]: VariableValueDto; }>> {
        return TaskApiFp(this.configuration).submit(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Resets a task's assignee. If successful, the task is not assigned to a user.
     * @summary Unclaim
     * @param {string} id The id of the task to unclaim.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public async unclaim(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return TaskApiFp(this.configuration).unclaim(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates a task.
     * @summary Update
     * @param {string} id The id of the task to be updated.
     * @param {TaskDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public async updateTask(id: string, body?: TaskDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return TaskApiFp(this.configuration).updateTask(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Camunda Platform REST API
 * OpenApi Spec for Camunda Platform REST API.
 *
 * OpenAPI spec version: 7.18.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { AuthorizationCheckResultDto } from '../models';
import { AuthorizationCreateDto } from '../models';
import { AuthorizationDto } from '../models';
import { AuthorizationUpdateDto } from '../models';
import { CountResultDto } from '../models';
import { ExceptionDto } from '../models';
import { ResourceOptionsDto } from '../models';
/**
 * AuthorizationApi - axios parameter creator
 * @export
 */
export const AuthorizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The OPTIONS request allows you to check for the set of available operations that the currently authenticated user can perform on the `/authorization` resource. Whether the user can perform an operation or not may depend on various factors, including the users authorizations to interact with this resource and the internal configuration of the process engine.
         * @summary Authorization Resource Options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableOperationsAuthorization: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authorization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * The OPTIONS request allows you to check for the set of available operations that the currently authenticated user can perform on a given instance of the `/authorization` resource. Whether the user can perform an operation or not may depend on various factors, including the users authorizations to interact with this resource and the internal configuration of the process engine.
         * @summary Authorization Resource Options
         * @param {string} id The id of the authorization to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableOperationsAuthorizationInstance: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling availableOperationsAuthorizationInstance.');
            }
            const localVarPath = `/authorization/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new authorization.
         * @summary Create a New Authorization
         * @param {AuthorizationCreateDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthorization: async (body?: AuthorizationCreateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authorization/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an authorization by id.
         * @summary Delete Authorization
         * @param {string} id The id of the authorization to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuthorization: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteAuthorization.');
            }
            const localVarPath = `/authorization/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves an authorization by id.
         * @summary Get Authorization
         * @param {string} id The id of the authorization to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorization: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getAuthorization.');
            }
            const localVarPath = `/authorization/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for authorizations using a list of parameters and retrieves the count.
         * @summary Get Authorization Count
         * @param {string} [id] Filter by the id of the authorization.
         * @param {number} [type] Filter by authorization type. (0&#x3D;global, 1&#x3D;grant, 2&#x3D;revoke). See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/authorization-service/#authorization-type) for more information about authorization types.
         * @param {string} [userIdIn] Filter by a comma-separated list of userIds.
         * @param {string} [groupIdIn] Filter by a comma-separated list of groupIds.
         * @param {number} [resourceType] Filter by an integer representation of the resource type. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/authorization-service/#resources) for a list of integer representations of resource types.
         * @param {string} [resourceId] Filter by resource id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorizationCount: async (id?: string, type?: number, userIdIn?: string, groupIdIn?: string, resourceType?: number, resourceId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authorization/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (userIdIn !== undefined) {
                localVarQueryParameter['userIdIn'] = userIdIn;
            }

            if (groupIdIn !== undefined) {
                localVarQueryParameter['groupIdIn'] = groupIdIn;
            }

            if (resourceType !== undefined) {
                localVarQueryParameter['resourceType'] = resourceType;
            }

            if (resourceId !== undefined) {
                localVarQueryParameter['resourceId'] = resourceId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs an authorization check for the currently authenticated user.
         * @summary Perform an Authorization Check
         * @param {string} permissionName String value representing the permission name to check for.
         * @param {string} resourceName String value for the name of the resource to check permissions for.
         * @param {number} resourceType An integer representing the resource type to check permissions for. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/authorization-service/#resources) for a list of integer representations of resource types.
         * @param {string} [resourceId] The id of the resource to check permissions for. If left blank, a check for global permissions on the resource is performed.
         * @param {string} [userId] The id of the user to check permissions for. The currently authenticated user must have a READ permission for the Authorization resource. If &#x60;userId&#x60; is blank, a check for the currently authenticated user is performed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isUserAuthorized: async (permissionName: string, resourceName: string, resourceType: number, resourceId?: string, userId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'permissionName' is not null or undefined
            if (permissionName === null || permissionName === undefined) {
                throw new RequiredError('permissionName','Required parameter permissionName was null or undefined when calling isUserAuthorized.');
            }
            // verify required parameter 'resourceName' is not null or undefined
            if (resourceName === null || resourceName === undefined) {
                throw new RequiredError('resourceName','Required parameter resourceName was null or undefined when calling isUserAuthorized.');
            }
            // verify required parameter 'resourceType' is not null or undefined
            if (resourceType === null || resourceType === undefined) {
                throw new RequiredError('resourceType','Required parameter resourceType was null or undefined when calling isUserAuthorized.');
            }
            const localVarPath = `/authorization/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (permissionName !== undefined) {
                localVarQueryParameter['permissionName'] = permissionName;
            }

            if (resourceName !== undefined) {
                localVarQueryParameter['resourceName'] = resourceName;
            }

            if (resourceType !== undefined) {
                localVarQueryParameter['resourceType'] = resourceType;
            }

            if (resourceId !== undefined) {
                localVarQueryParameter['resourceId'] = resourceId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for a list of authorizations using a list of parameters. The size of the result set can be retrieved by using the [Get Authorization Count](https://docs.camunda.org/manual/7.18/reference/rest/authorization/get-query-count/) method.
         * @summary Get Authorizations
         * @param {string} [id] Filter by the id of the authorization.
         * @param {number} [type] Filter by authorization type. (0&#x3D;global, 1&#x3D;grant, 2&#x3D;revoke). See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/authorization-service/#authorization-type) for more information about authorization types.
         * @param {string} [userIdIn] Filter by a comma-separated list of userIds.
         * @param {string} [groupIdIn] Filter by a comma-separated list of groupIds.
         * @param {number} [resourceType] Filter by an integer representation of the resource type. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/authorization-service/#resources) for a list of integer representations of resource types.
         * @param {string} [resourceId] Filter by resource id.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryAuthorizations: async (id?: string, type?: number, userIdIn?: string, groupIdIn?: string, resourceType?: number, resourceId?: string, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authorization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (userIdIn !== undefined) {
                localVarQueryParameter['userIdIn'] = userIdIn;
            }

            if (groupIdIn !== undefined) {
                localVarQueryParameter['groupIdIn'] = groupIdIn;
            }

            if (resourceType !== undefined) {
                localVarQueryParameter['resourceType'] = resourceType;
            }

            if (resourceId !== undefined) {
                localVarQueryParameter['resourceId'] = resourceId;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an authorization by id.
         * @summary Update an Authorization
         * @param {string} id The id of the authorization to be updated.
         * @param {AuthorizationUpdateDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAuthorization: async (id: string, body?: AuthorizationUpdateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateAuthorization.');
            }
            const localVarPath = `/authorization/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthorizationApi - functional programming interface
 * @export
 */
export const AuthorizationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * The OPTIONS request allows you to check for the set of available operations that the currently authenticated user can perform on the `/authorization` resource. Whether the user can perform an operation or not may depend on various factors, including the users authorizations to interact with this resource and the internal configuration of the process engine.
         * @summary Authorization Resource Options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableOperationsAuthorization(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResourceOptionsDto>>> {
            const localVarAxiosArgs = await AuthorizationApiAxiosParamCreator(configuration).availableOperationsAuthorization(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * The OPTIONS request allows you to check for the set of available operations that the currently authenticated user can perform on a given instance of the `/authorization` resource. Whether the user can perform an operation or not may depend on various factors, including the users authorizations to interact with this resource and the internal configuration of the process engine.
         * @summary Authorization Resource Options
         * @param {string} id The id of the authorization to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableOperationsAuthorizationInstance(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResourceOptionsDto>>> {
            const localVarAxiosArgs = await AuthorizationApiAxiosParamCreator(configuration).availableOperationsAuthorizationInstance(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a new authorization.
         * @summary Create a New Authorization
         * @param {AuthorizationCreateDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAuthorization(body?: AuthorizationCreateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<AuthorizationDto>>> {
            const localVarAxiosArgs = await AuthorizationApiAxiosParamCreator(configuration).createAuthorization(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes an authorization by id.
         * @summary Delete Authorization
         * @param {string} id The id of the authorization to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAuthorization(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await AuthorizationApiAxiosParamCreator(configuration).deleteAuthorization(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves an authorization by id.
         * @summary Get Authorization
         * @param {string} id The id of the authorization to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthorization(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<AuthorizationDto>>> {
            const localVarAxiosArgs = await AuthorizationApiAxiosParamCreator(configuration).getAuthorization(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Queries for authorizations using a list of parameters and retrieves the count.
         * @summary Get Authorization Count
         * @param {string} [id] Filter by the id of the authorization.
         * @param {number} [type] Filter by authorization type. (0&#x3D;global, 1&#x3D;grant, 2&#x3D;revoke). See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/authorization-service/#authorization-type) for more information about authorization types.
         * @param {string} [userIdIn] Filter by a comma-separated list of userIds.
         * @param {string} [groupIdIn] Filter by a comma-separated list of groupIds.
         * @param {number} [resourceType] Filter by an integer representation of the resource type. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/authorization-service/#resources) for a list of integer representations of resource types.
         * @param {string} [resourceId] Filter by resource id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthorizationCount(id?: string, type?: number, userIdIn?: string, groupIdIn?: string, resourceType?: number, resourceId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<CountResultDto>>> {
            const localVarAxiosArgs = await AuthorizationApiAxiosParamCreator(configuration).getAuthorizationCount(id, type, userIdIn, groupIdIn, resourceType, resourceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Performs an authorization check for the currently authenticated user.
         * @summary Perform an Authorization Check
         * @param {string} permissionName String value representing the permission name to check for.
         * @param {string} resourceName String value for the name of the resource to check permissions for.
         * @param {number} resourceType An integer representing the resource type to check permissions for. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/authorization-service/#resources) for a list of integer representations of resource types.
         * @param {string} [resourceId] The id of the resource to check permissions for. If left blank, a check for global permissions on the resource is performed.
         * @param {string} [userId] The id of the user to check permissions for. The currently authenticated user must have a READ permission for the Authorization resource. If &#x60;userId&#x60; is blank, a check for the currently authenticated user is performed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isUserAuthorized(permissionName: string, resourceName: string, resourceType: number, resourceId?: string, userId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<AuthorizationCheckResultDto>>> {
            const localVarAxiosArgs = await AuthorizationApiAxiosParamCreator(configuration).isUserAuthorized(permissionName, resourceName, resourceType, resourceId, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Queries for a list of authorizations using a list of parameters. The size of the result set can be retrieved by using the [Get Authorization Count](https://docs.camunda.org/manual/7.18/reference/rest/authorization/get-query-count/) method.
         * @summary Get Authorizations
         * @param {string} [id] Filter by the id of the authorization.
         * @param {number} [type] Filter by authorization type. (0&#x3D;global, 1&#x3D;grant, 2&#x3D;revoke). See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/authorization-service/#authorization-type) for more information about authorization types.
         * @param {string} [userIdIn] Filter by a comma-separated list of userIds.
         * @param {string} [groupIdIn] Filter by a comma-separated list of groupIds.
         * @param {number} [resourceType] Filter by an integer representation of the resource type. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/authorization-service/#resources) for a list of integer representations of resource types.
         * @param {string} [resourceId] Filter by resource id.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryAuthorizations(id?: string, type?: number, userIdIn?: string, groupIdIn?: string, resourceType?: number, resourceId?: string, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<AuthorizationDto>>>> {
            const localVarAxiosArgs = await AuthorizationApiAxiosParamCreator(configuration).queryAuthorizations(id, type, userIdIn, groupIdIn, resourceType, resourceId, sortBy, sortOrder, firstResult, maxResults, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates an authorization by id.
         * @summary Update an Authorization
         * @param {string} id The id of the authorization to be updated.
         * @param {AuthorizationUpdateDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAuthorization(id: string, body?: AuthorizationUpdateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await AuthorizationApiAxiosParamCreator(configuration).updateAuthorization(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AuthorizationApi - factory interface
 * @export
 */
export const AuthorizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * The OPTIONS request allows you to check for the set of available operations that the currently authenticated user can perform on the `/authorization` resource. Whether the user can perform an operation or not may depend on various factors, including the users authorizations to interact with this resource and the internal configuration of the process engine.
         * @summary Authorization Resource Options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableOperationsAuthorization(options?: AxiosRequestConfig): Promise<AxiosResponse<ResourceOptionsDto>> {
            return AuthorizationApiFp(configuration).availableOperationsAuthorization(options).then((request) => request(axios, basePath));
        },
        /**
         * The OPTIONS request allows you to check for the set of available operations that the currently authenticated user can perform on a given instance of the `/authorization` resource. Whether the user can perform an operation or not may depend on various factors, including the users authorizations to interact with this resource and the internal configuration of the process engine.
         * @summary Authorization Resource Options
         * @param {string} id The id of the authorization to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableOperationsAuthorizationInstance(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<ResourceOptionsDto>> {
            return AuthorizationApiFp(configuration).availableOperationsAuthorizationInstance(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new authorization.
         * @summary Create a New Authorization
         * @param {AuthorizationCreateDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAuthorization(body?: AuthorizationCreateDto, options?: AxiosRequestConfig): Promise<AxiosResponse<AuthorizationDto>> {
            return AuthorizationApiFp(configuration).createAuthorization(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an authorization by id.
         * @summary Delete Authorization
         * @param {string} id The id of the authorization to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAuthorization(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return AuthorizationApiFp(configuration).deleteAuthorization(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves an authorization by id.
         * @summary Get Authorization
         * @param {string} id The id of the authorization to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthorization(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<AuthorizationDto>> {
            return AuthorizationApiFp(configuration).getAuthorization(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for authorizations using a list of parameters and retrieves the count.
         * @summary Get Authorization Count
         * @param {string} [id] Filter by the id of the authorization.
         * @param {number} [type] Filter by authorization type. (0&#x3D;global, 1&#x3D;grant, 2&#x3D;revoke). See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/authorization-service/#authorization-type) for more information about authorization types.
         * @param {string} [userIdIn] Filter by a comma-separated list of userIds.
         * @param {string} [groupIdIn] Filter by a comma-separated list of groupIds.
         * @param {number} [resourceType] Filter by an integer representation of the resource type. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/authorization-service/#resources) for a list of integer representations of resource types.
         * @param {string} [resourceId] Filter by resource id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthorizationCount(id?: string, type?: number, userIdIn?: string, groupIdIn?: string, resourceType?: number, resourceId?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<CountResultDto>> {
            return AuthorizationApiFp(configuration).getAuthorizationCount(id, type, userIdIn, groupIdIn, resourceType, resourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Performs an authorization check for the currently authenticated user.
         * @summary Perform an Authorization Check
         * @param {string} permissionName String value representing the permission name to check for.
         * @param {string} resourceName String value for the name of the resource to check permissions for.
         * @param {number} resourceType An integer representing the resource type to check permissions for. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/authorization-service/#resources) for a list of integer representations of resource types.
         * @param {string} [resourceId] The id of the resource to check permissions for. If left blank, a check for global permissions on the resource is performed.
         * @param {string} [userId] The id of the user to check permissions for. The currently authenticated user must have a READ permission for the Authorization resource. If &#x60;userId&#x60; is blank, a check for the currently authenticated user is performed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isUserAuthorized(permissionName: string, resourceName: string, resourceType: number, resourceId?: string, userId?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<AuthorizationCheckResultDto>> {
            return AuthorizationApiFp(configuration).isUserAuthorized(permissionName, resourceName, resourceType, resourceId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for a list of authorizations using a list of parameters. The size of the result set can be retrieved by using the [Get Authorization Count](https://docs.camunda.org/manual/7.18/reference/rest/authorization/get-query-count/) method.
         * @summary Get Authorizations
         * @param {string} [id] Filter by the id of the authorization.
         * @param {number} [type] Filter by authorization type. (0&#x3D;global, 1&#x3D;grant, 2&#x3D;revoke). See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/authorization-service/#authorization-type) for more information about authorization types.
         * @param {string} [userIdIn] Filter by a comma-separated list of userIds.
         * @param {string} [groupIdIn] Filter by a comma-separated list of groupIds.
         * @param {number} [resourceType] Filter by an integer representation of the resource type. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/authorization-service/#resources) for a list of integer representations of resource types.
         * @param {string} [resourceId] Filter by resource id.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryAuthorizations(id?: string, type?: number, userIdIn?: string, groupIdIn?: string, resourceType?: number, resourceId?: string, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<AuthorizationDto>>> {
            return AuthorizationApiFp(configuration).queryAuthorizations(id, type, userIdIn, groupIdIn, resourceType, resourceId, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an authorization by id.
         * @summary Update an Authorization
         * @param {string} id The id of the authorization to be updated.
         * @param {AuthorizationUpdateDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAuthorization(id: string, body?: AuthorizationUpdateDto, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return AuthorizationApiFp(configuration).updateAuthorization(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthorizationApi - object-oriented interface
 * @export
 * @class AuthorizationApi
 * @extends {BaseAPI}
 */
export class AuthorizationApi extends BaseAPI {
    /**
     * The OPTIONS request allows you to check for the set of available operations that the currently authenticated user can perform on the `/authorization` resource. Whether the user can perform an operation or not may depend on various factors, including the users authorizations to interact with this resource and the internal configuration of the process engine.
     * @summary Authorization Resource Options
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    public async availableOperationsAuthorization(options?: AxiosRequestConfig) : Promise<AxiosResponse<ResourceOptionsDto>> {
        return AuthorizationApiFp(this.configuration).availableOperationsAuthorization(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * The OPTIONS request allows you to check for the set of available operations that the currently authenticated user can perform on a given instance of the `/authorization` resource. Whether the user can perform an operation or not may depend on various factors, including the users authorizations to interact with this resource and the internal configuration of the process engine.
     * @summary Authorization Resource Options
     * @param {string} id The id of the authorization to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    public async availableOperationsAuthorizationInstance(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResourceOptionsDto>> {
        return AuthorizationApiFp(this.configuration).availableOperationsAuthorizationInstance(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new authorization.
     * @summary Create a New Authorization
     * @param {AuthorizationCreateDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    public async createAuthorization(body?: AuthorizationCreateDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<AuthorizationDto>> {
        return AuthorizationApiFp(this.configuration).createAuthorization(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes an authorization by id.
     * @summary Delete Authorization
     * @param {string} id The id of the authorization to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    public async deleteAuthorization(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return AuthorizationApiFp(this.configuration).deleteAuthorization(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves an authorization by id.
     * @summary Get Authorization
     * @param {string} id The id of the authorization to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    public async getAuthorization(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<AuthorizationDto>> {
        return AuthorizationApiFp(this.configuration).getAuthorization(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Queries for authorizations using a list of parameters and retrieves the count.
     * @summary Get Authorization Count
     * @param {string} [id] Filter by the id of the authorization.
     * @param {number} [type] Filter by authorization type. (0&#x3D;global, 1&#x3D;grant, 2&#x3D;revoke). See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/authorization-service/#authorization-type) for more information about authorization types.
     * @param {string} [userIdIn] Filter by a comma-separated list of userIds.
     * @param {string} [groupIdIn] Filter by a comma-separated list of groupIds.
     * @param {number} [resourceType] Filter by an integer representation of the resource type. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/authorization-service/#resources) for a list of integer representations of resource types.
     * @param {string} [resourceId] Filter by resource id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    public async getAuthorizationCount(id?: string, type?: number, userIdIn?: string, groupIdIn?: string, resourceType?: number, resourceId?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<CountResultDto>> {
        return AuthorizationApiFp(this.configuration).getAuthorizationCount(id, type, userIdIn, groupIdIn, resourceType, resourceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Performs an authorization check for the currently authenticated user.
     * @summary Perform an Authorization Check
     * @param {string} permissionName String value representing the permission name to check for.
     * @param {string} resourceName String value for the name of the resource to check permissions for.
     * @param {number} resourceType An integer representing the resource type to check permissions for. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/authorization-service/#resources) for a list of integer representations of resource types.
     * @param {string} [resourceId] The id of the resource to check permissions for. If left blank, a check for global permissions on the resource is performed.
     * @param {string} [userId] The id of the user to check permissions for. The currently authenticated user must have a READ permission for the Authorization resource. If &#x60;userId&#x60; is blank, a check for the currently authenticated user is performed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    public async isUserAuthorized(permissionName: string, resourceName: string, resourceType: number, resourceId?: string, userId?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<AuthorizationCheckResultDto>> {
        return AuthorizationApiFp(this.configuration).isUserAuthorized(permissionName, resourceName, resourceType, resourceId, userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Queries for a list of authorizations using a list of parameters. The size of the result set can be retrieved by using the [Get Authorization Count](https://docs.camunda.org/manual/7.18/reference/rest/authorization/get-query-count/) method.
     * @summary Get Authorizations
     * @param {string} [id] Filter by the id of the authorization.
     * @param {number} [type] Filter by authorization type. (0&#x3D;global, 1&#x3D;grant, 2&#x3D;revoke). See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/authorization-service/#authorization-type) for more information about authorization types.
     * @param {string} [userIdIn] Filter by a comma-separated list of userIds.
     * @param {string} [groupIdIn] Filter by a comma-separated list of groupIds.
     * @param {number} [resourceType] Filter by an integer representation of the resource type. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/authorization-service/#resources) for a list of integer representations of resource types.
     * @param {string} [resourceId] Filter by resource id.
     * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    public async queryAuthorizations(id?: string, type?: number, userIdIn?: string, groupIdIn?: string, resourceType?: number, resourceId?: string, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<AuthorizationDto>>> {
        return AuthorizationApiFp(this.configuration).queryAuthorizations(id, type, userIdIn, groupIdIn, resourceType, resourceId, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates an authorization by id.
     * @summary Update an Authorization
     * @param {string} id The id of the authorization to be updated.
     * @param {AuthorizationUpdateDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    public async updateAuthorization(id: string, body?: AuthorizationUpdateDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return AuthorizationApiFp(this.configuration).updateAuthorization(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}

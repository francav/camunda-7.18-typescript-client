/* tslint:disable */
/* eslint-disable */
/**
 * Camunda Platform REST API
 * OpenApi Spec for Camunda Platform REST API.
 *
 * OpenAPI spec version: 7.18.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { BatchDto } from '../models';
import { CountResultDto } from '../models';
import { ExceptionDto } from '../models';
import { JobDto } from '../models';
import { JobDuedateDto } from '../models';
import { JobQueryDto } from '../models';
import { JobSuspensionStateDto } from '../models';
import { PriorityDto } from '../models';
import { RetriesDto } from '../models';
import { SetJobRetriesDto } from '../models';
import { SuspensionStateDto } from '../models';
/**
 * JobApi - axios parameter creator
 * @export
 */
export const JobApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Executes a job by id. **Note:** The execution of the job happens synchronously in the same thread.
         * @summary Execute Job
         * @param {string} id The id of the job to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeJob: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling executeJob.');
            }
            const localVarPath = `/job/{id}/execute`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a job by id, according to the `Job` interface in the engine.
         * @summary Get Job
         * @param {string} id The id of the job to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getJob.');
            }
            const localVarPath = `/job/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for jobs that fulfill given parameters. The size of the result set can be retrieved by using the [Get Job Count](https://docs.camunda.org/manual/7.18/reference/rest/job/get-query-count/) method.
         * @summary Get Jobs
         * @param {string} [jobId] Filter by job id.
         * @param {string} [jobIds] Filter by a comma-separated list of job ids.
         * @param {string} [jobDefinitionId] Only select jobs which exist for the given job definition.
         * @param {string} [processInstanceId] Only select jobs which exist for the given process instance.
         * @param {string} [processInstanceIds] Only select jobs which exist for the given comma-separated list of process instance ids.
         * @param {string} [executionId] Only select jobs which exist for the given execution.
         * @param {string} [processDefinitionId] Filter by the id of the process definition the jobs run on.
         * @param {string} [processDefinitionKey] Filter by the key of the process definition the jobs run on.
         * @param {string} [activityId] Only select jobs which exist for an activity with the given id.
         * @param {boolean} [withRetriesLeft] Only select jobs which have retries left. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [executable] Only select jobs which are executable, i.e., retries &gt; 0 and due date is &#x60;null&#x60; or due date is in the past. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [timers] Only select jobs that are timers. Cannot be used together with &#x60;messages&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [messages] Only select jobs that are messages. Cannot be used together with &#x60;timers&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [dueDates] Only select jobs where the due date is lower or higher than the given date. Due date expressions are comma-separated and are structured as follows:  A valid condition value has the form &#x60;operator_value&#x60;. &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the date value as string.  Valid operator values are: &#x60;gt&#x60; - greater than; &#x60;lt&#x60; - lower than. &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [createTimes] Only select jobs created before or after the given date.  Create time expressions are comma-separated and are structured as follows:  A valid condition value has the form &#x60;operator_value&#x60;. &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the date value as string.  Valid operator values are: &#x60;gt&#x60; - greater than; &#x60;lt&#x60; - lower than. &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [withException] Only select jobs that failed due to an exception. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [exceptionMessage] Only select jobs that failed due to an exception with the given message.
         * @param {string} [failedActivityId] Only select jobs that failed due to an exception at an activity with the given id.
         * @param {boolean} [noRetriesLeft] Only select jobs which have no retries left. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [active] Only include active jobs. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended jobs. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {number} [priorityLowerThanOrEquals] Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {number} [priorityHigherThanOrEquals] Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {string} [tenantIdIn] Only include jobs which belong to one of the passed comma-separated tenant ids.
         * @param {boolean} [withoutTenantId] Only include jobs which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeJobsWithoutTenantId] Include jobs which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobs: async (jobId?: string, jobIds?: string, jobDefinitionId?: string, processInstanceId?: string, processInstanceIds?: string, executionId?: string, processDefinitionId?: string, processDefinitionKey?: string, activityId?: string, withRetriesLeft?: boolean, executable?: boolean, timers?: boolean, messages?: boolean, dueDates?: string, createTimes?: string, withException?: boolean, exceptionMessage?: string, failedActivityId?: string, noRetriesLeft?: boolean, active?: boolean, suspended?: boolean, priorityLowerThanOrEquals?: number, priorityHigherThanOrEquals?: number, tenantIdIn?: string, withoutTenantId?: boolean, includeJobsWithoutTenantId?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/job`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (jobId !== undefined) {
                localVarQueryParameter['jobId'] = jobId;
            }

            if (jobIds !== undefined) {
                localVarQueryParameter['jobIds'] = jobIds;
            }

            if (jobDefinitionId !== undefined) {
                localVarQueryParameter['jobDefinitionId'] = jobDefinitionId;
            }

            if (processInstanceId !== undefined) {
                localVarQueryParameter['processInstanceId'] = processInstanceId;
            }

            if (processInstanceIds !== undefined) {
                localVarQueryParameter['processInstanceIds'] = processInstanceIds;
            }

            if (executionId !== undefined) {
                localVarQueryParameter['executionId'] = executionId;
            }

            if (processDefinitionId !== undefined) {
                localVarQueryParameter['processDefinitionId'] = processDefinitionId;
            }

            if (processDefinitionKey !== undefined) {
                localVarQueryParameter['processDefinitionKey'] = processDefinitionKey;
            }

            if (activityId !== undefined) {
                localVarQueryParameter['activityId'] = activityId;
            }

            if (withRetriesLeft !== undefined) {
                localVarQueryParameter['withRetriesLeft'] = withRetriesLeft;
            }

            if (executable !== undefined) {
                localVarQueryParameter['executable'] = executable;
            }

            if (timers !== undefined) {
                localVarQueryParameter['timers'] = timers;
            }

            if (messages !== undefined) {
                localVarQueryParameter['messages'] = messages;
            }

            if (dueDates !== undefined) {
                localVarQueryParameter['dueDates'] = dueDates;
            }

            if (createTimes !== undefined) {
                localVarQueryParameter['createTimes'] = createTimes;
            }

            if (withException !== undefined) {
                localVarQueryParameter['withException'] = withException;
            }

            if (exceptionMessage !== undefined) {
                localVarQueryParameter['exceptionMessage'] = exceptionMessage;
            }

            if (failedActivityId !== undefined) {
                localVarQueryParameter['failedActivityId'] = failedActivityId;
            }

            if (noRetriesLeft !== undefined) {
                localVarQueryParameter['noRetriesLeft'] = noRetriesLeft;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (suspended !== undefined) {
                localVarQueryParameter['suspended'] = suspended;
            }

            if (priorityLowerThanOrEquals !== undefined) {
                localVarQueryParameter['priorityLowerThanOrEquals'] = priorityLowerThanOrEquals;
            }

            if (priorityHigherThanOrEquals !== undefined) {
                localVarQueryParameter['priorityHigherThanOrEquals'] = priorityHigherThanOrEquals;
            }

            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }

            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }

            if (includeJobsWithoutTenantId !== undefined) {
                localVarQueryParameter['includeJobsWithoutTenantId'] = includeJobsWithoutTenantId;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for the number of jobs that fulfill given parameters. Takes the same parameters as the [Get Jobs](https://docs.camunda.org/manual/7.18/reference/rest/job/get-query/) method.
         * @summary Get Job Count
         * @param {string} [jobId] Filter by job id.
         * @param {string} [jobIds] Filter by a comma-separated list of job ids.
         * @param {string} [jobDefinitionId] Only select jobs which exist for the given job definition.
         * @param {string} [processInstanceId] Only select jobs which exist for the given process instance.
         * @param {string} [processInstanceIds] Only select jobs which exist for the given comma-separated list of process instance ids.
         * @param {string} [executionId] Only select jobs which exist for the given execution.
         * @param {string} [processDefinitionId] Filter by the id of the process definition the jobs run on.
         * @param {string} [processDefinitionKey] Filter by the key of the process definition the jobs run on.
         * @param {string} [activityId] Only select jobs which exist for an activity with the given id.
         * @param {boolean} [withRetriesLeft] Only select jobs which have retries left. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [executable] Only select jobs which are executable, i.e., retries &gt; 0 and due date is &#x60;null&#x60; or due date is in the past. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [timers] Only select jobs that are timers. Cannot be used together with &#x60;messages&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [messages] Only select jobs that are messages. Cannot be used together with &#x60;timers&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [dueDates] Only select jobs where the due date is lower or higher than the given date. Due date expressions are comma-separated and are structured as follows:  A valid condition value has the form &#x60;operator_value&#x60;. &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the date value as string.  Valid operator values are: &#x60;gt&#x60; - greater than; &#x60;lt&#x60; - lower than. &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [createTimes] Only select jobs created before or after the given date.  Create time expressions are comma-separated and are structured as follows:  A valid condition value has the form &#x60;operator_value&#x60;. &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the date value as string.  Valid operator values are: &#x60;gt&#x60; - greater than; &#x60;lt&#x60; - lower than. &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [withException] Only select jobs that failed due to an exception. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [exceptionMessage] Only select jobs that failed due to an exception with the given message.
         * @param {string} [failedActivityId] Only select jobs that failed due to an exception at an activity with the given id.
         * @param {boolean} [noRetriesLeft] Only select jobs which have no retries left. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [active] Only include active jobs. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended jobs. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {number} [priorityLowerThanOrEquals] Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {number} [priorityHigherThanOrEquals] Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {string} [tenantIdIn] Only include jobs which belong to one of the passed comma-separated tenant ids.
         * @param {boolean} [withoutTenantId] Only include jobs which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeJobsWithoutTenantId] Include jobs which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobsCount: async (jobId?: string, jobIds?: string, jobDefinitionId?: string, processInstanceId?: string, processInstanceIds?: string, executionId?: string, processDefinitionId?: string, processDefinitionKey?: string, activityId?: string, withRetriesLeft?: boolean, executable?: boolean, timers?: boolean, messages?: boolean, dueDates?: string, createTimes?: string, withException?: boolean, exceptionMessage?: string, failedActivityId?: string, noRetriesLeft?: boolean, active?: boolean, suspended?: boolean, priorityLowerThanOrEquals?: number, priorityHigherThanOrEquals?: number, tenantIdIn?: string, withoutTenantId?: boolean, includeJobsWithoutTenantId?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/job/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (jobId !== undefined) {
                localVarQueryParameter['jobId'] = jobId;
            }

            if (jobIds !== undefined) {
                localVarQueryParameter['jobIds'] = jobIds;
            }

            if (jobDefinitionId !== undefined) {
                localVarQueryParameter['jobDefinitionId'] = jobDefinitionId;
            }

            if (processInstanceId !== undefined) {
                localVarQueryParameter['processInstanceId'] = processInstanceId;
            }

            if (processInstanceIds !== undefined) {
                localVarQueryParameter['processInstanceIds'] = processInstanceIds;
            }

            if (executionId !== undefined) {
                localVarQueryParameter['executionId'] = executionId;
            }

            if (processDefinitionId !== undefined) {
                localVarQueryParameter['processDefinitionId'] = processDefinitionId;
            }

            if (processDefinitionKey !== undefined) {
                localVarQueryParameter['processDefinitionKey'] = processDefinitionKey;
            }

            if (activityId !== undefined) {
                localVarQueryParameter['activityId'] = activityId;
            }

            if (withRetriesLeft !== undefined) {
                localVarQueryParameter['withRetriesLeft'] = withRetriesLeft;
            }

            if (executable !== undefined) {
                localVarQueryParameter['executable'] = executable;
            }

            if (timers !== undefined) {
                localVarQueryParameter['timers'] = timers;
            }

            if (messages !== undefined) {
                localVarQueryParameter['messages'] = messages;
            }

            if (dueDates !== undefined) {
                localVarQueryParameter['dueDates'] = dueDates;
            }

            if (createTimes !== undefined) {
                localVarQueryParameter['createTimes'] = createTimes;
            }

            if (withException !== undefined) {
                localVarQueryParameter['withException'] = withException;
            }

            if (exceptionMessage !== undefined) {
                localVarQueryParameter['exceptionMessage'] = exceptionMessage;
            }

            if (failedActivityId !== undefined) {
                localVarQueryParameter['failedActivityId'] = failedActivityId;
            }

            if (noRetriesLeft !== undefined) {
                localVarQueryParameter['noRetriesLeft'] = noRetriesLeft;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (suspended !== undefined) {
                localVarQueryParameter['suspended'] = suspended;
            }

            if (priorityLowerThanOrEquals !== undefined) {
                localVarQueryParameter['priorityLowerThanOrEquals'] = priorityLowerThanOrEquals;
            }

            if (priorityHigherThanOrEquals !== undefined) {
                localVarQueryParameter['priorityHigherThanOrEquals'] = priorityHigherThanOrEquals;
            }

            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }

            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }

            if (includeJobsWithoutTenantId !== undefined) {
                localVarQueryParameter['includeJobsWithoutTenantId'] = includeJobsWithoutTenantId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the exception stacktrace corresponding to the passed job id.
         * @summary Get Exception Stacktrace
         * @param {string} id The id of the job to get the exception stacktrace for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStacktrace: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getStacktrace.');
            }
            const localVarPath = `/job/{id}/stacktrace`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for jobs that fulfill given parameters. This method is slightly more powerful than the [Get Jobs](https://docs.camunda.org/manual/7.18/reference/rest/job/get-query/) method because it allows filtering by multiple jobs of types `String`, `Number` or `Boolean`.
         * @summary Get Jobs (POST)
         * @param {JobQueryDto} [body] 
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryJobs: async (body?: JobQueryDto, firstResult?: number, maxResults?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/job`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for jobs that fulfill given parameters. This method takes the same message body as the [Get Jobs POST](https://docs.camunda.org/manual/7.18/reference/rest/job/post- query/) method and therefore it is slightly more powerful than the [Get Job Count](https://docs.camunda.org/manual/7.18/reference/rest/job/get-query-count/) method.
         * @summary Get Job Count (POST)
         * @param {JobQueryDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryJobsCount: async (body?: JobQueryDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/job/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Recalculates the due date of a job by id.
         * @summary Recalculate Job Due Date
         * @param {string} id The id of the job to be updated.
         * @param {boolean} [creationDateBased] Recalculate the due date based on the creation date of the job or the current date. Value may only be &#x60;false&#x60;, as &#x60;true&#x60; is the default behavior. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recalculateDuedate: async (id: string, creationDateBased?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling recalculateDuedate.');
            }
            const localVarPath = `/job/{id}/duedate/recalculate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (creationDateBased !== undefined) {
                localVarQueryParameter['creationDateBased'] = creationDateBased;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the due date of a job by id.
         * @summary Set Job Due Date
         * @param {string} id The id of the job to be updated.
         * @param {JobDuedateDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setJobDuedate: async (id: string, body?: JobDuedateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling setJobDuedate.');
            }
            const localVarPath = `/job/{id}/duedate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the execution priority of a job by id.
         * @summary Set Job Priority
         * @param {string} id The id of the job to be updated.
         * @param {PriorityDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setJobPriority: async (id: string, body?: PriorityDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling setJobPriority.');
            }
            const localVarPath = `/job/{id}/priority`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the retries of the job to the given number of retries by id.
         * @summary Set Job Retries
         * @param {string} id The id of the job to be updated.
         * @param {RetriesDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setJobRetries: async (id: string, body?: RetriesDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling setJobRetries.');
            }
            const localVarPath = `/job/{id}/retries`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a batch to set retries of jobs asynchronously.
         * @summary Set Job Retries Async (POST)
         * @param {SetJobRetriesDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setJobRetriesAsyncOperation: async (body?: SetJobRetriesDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/job/retries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Activates or suspends a given job by id.
         * @summary Activate/Suspend Job By Id
         * @param {string} id The id of the job to activate or suspend.
         * @param {SuspensionStateDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJobSuspensionState: async (id: string, body?: SuspensionStateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateJobSuspensionState.');
            }
            const localVarPath = `/job/{id}/suspended`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Activates or suspends jobs matching the given criterion. This can only be on of: * `jobDefinitionId` * `processDefinitionId` * `processInstanceId` * `processDefinitionKey`
         * @summary Activate/Suspend Jobs
         * @param {JobSuspensionStateDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSuspensionStateBy: async (body?: JobSuspensionStateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/job/suspended`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobApi - functional programming interface
 * @export
 */
export const JobApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Executes a job by id. **Note:** The execution of the job happens synchronously in the same thread.
         * @summary Execute Job
         * @param {string} id The id of the job to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeJob(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await JobApiAxiosParamCreator(configuration).executeJob(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves a job by id, according to the `Job` interface in the engine.
         * @summary Get Job
         * @param {string} id The id of the job to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJob(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<JobDto>>> {
            const localVarAxiosArgs = await JobApiAxiosParamCreator(configuration).getJob(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Queries for jobs that fulfill given parameters. The size of the result set can be retrieved by using the [Get Job Count](https://docs.camunda.org/manual/7.18/reference/rest/job/get-query-count/) method.
         * @summary Get Jobs
         * @param {string} [jobId] Filter by job id.
         * @param {string} [jobIds] Filter by a comma-separated list of job ids.
         * @param {string} [jobDefinitionId] Only select jobs which exist for the given job definition.
         * @param {string} [processInstanceId] Only select jobs which exist for the given process instance.
         * @param {string} [processInstanceIds] Only select jobs which exist for the given comma-separated list of process instance ids.
         * @param {string} [executionId] Only select jobs which exist for the given execution.
         * @param {string} [processDefinitionId] Filter by the id of the process definition the jobs run on.
         * @param {string} [processDefinitionKey] Filter by the key of the process definition the jobs run on.
         * @param {string} [activityId] Only select jobs which exist for an activity with the given id.
         * @param {boolean} [withRetriesLeft] Only select jobs which have retries left. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [executable] Only select jobs which are executable, i.e., retries &gt; 0 and due date is &#x60;null&#x60; or due date is in the past. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [timers] Only select jobs that are timers. Cannot be used together with &#x60;messages&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [messages] Only select jobs that are messages. Cannot be used together with &#x60;timers&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [dueDates] Only select jobs where the due date is lower or higher than the given date. Due date expressions are comma-separated and are structured as follows:  A valid condition value has the form &#x60;operator_value&#x60;. &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the date value as string.  Valid operator values are: &#x60;gt&#x60; - greater than; &#x60;lt&#x60; - lower than. &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [createTimes] Only select jobs created before or after the given date.  Create time expressions are comma-separated and are structured as follows:  A valid condition value has the form &#x60;operator_value&#x60;. &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the date value as string.  Valid operator values are: &#x60;gt&#x60; - greater than; &#x60;lt&#x60; - lower than. &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [withException] Only select jobs that failed due to an exception. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [exceptionMessage] Only select jobs that failed due to an exception with the given message.
         * @param {string} [failedActivityId] Only select jobs that failed due to an exception at an activity with the given id.
         * @param {boolean} [noRetriesLeft] Only select jobs which have no retries left. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [active] Only include active jobs. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended jobs. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {number} [priorityLowerThanOrEquals] Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {number} [priorityHigherThanOrEquals] Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {string} [tenantIdIn] Only include jobs which belong to one of the passed comma-separated tenant ids.
         * @param {boolean} [withoutTenantId] Only include jobs which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeJobsWithoutTenantId] Include jobs which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobs(jobId?: string, jobIds?: string, jobDefinitionId?: string, processInstanceId?: string, processInstanceIds?: string, executionId?: string, processDefinitionId?: string, processDefinitionKey?: string, activityId?: string, withRetriesLeft?: boolean, executable?: boolean, timers?: boolean, messages?: boolean, dueDates?: string, createTimes?: string, withException?: boolean, exceptionMessage?: string, failedActivityId?: string, noRetriesLeft?: boolean, active?: boolean, suspended?: boolean, priorityLowerThanOrEquals?: number, priorityHigherThanOrEquals?: number, tenantIdIn?: string, withoutTenantId?: boolean, includeJobsWithoutTenantId?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<JobDto>>>> {
            const localVarAxiosArgs = await JobApiAxiosParamCreator(configuration).getJobs(jobId, jobIds, jobDefinitionId, processInstanceId, processInstanceIds, executionId, processDefinitionId, processDefinitionKey, activityId, withRetriesLeft, executable, timers, messages, dueDates, createTimes, withException, exceptionMessage, failedActivityId, noRetriesLeft, active, suspended, priorityLowerThanOrEquals, priorityHigherThanOrEquals, tenantIdIn, withoutTenantId, includeJobsWithoutTenantId, sortBy, sortOrder, firstResult, maxResults, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Queries for the number of jobs that fulfill given parameters. Takes the same parameters as the [Get Jobs](https://docs.camunda.org/manual/7.18/reference/rest/job/get-query/) method.
         * @summary Get Job Count
         * @param {string} [jobId] Filter by job id.
         * @param {string} [jobIds] Filter by a comma-separated list of job ids.
         * @param {string} [jobDefinitionId] Only select jobs which exist for the given job definition.
         * @param {string} [processInstanceId] Only select jobs which exist for the given process instance.
         * @param {string} [processInstanceIds] Only select jobs which exist for the given comma-separated list of process instance ids.
         * @param {string} [executionId] Only select jobs which exist for the given execution.
         * @param {string} [processDefinitionId] Filter by the id of the process definition the jobs run on.
         * @param {string} [processDefinitionKey] Filter by the key of the process definition the jobs run on.
         * @param {string} [activityId] Only select jobs which exist for an activity with the given id.
         * @param {boolean} [withRetriesLeft] Only select jobs which have retries left. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [executable] Only select jobs which are executable, i.e., retries &gt; 0 and due date is &#x60;null&#x60; or due date is in the past. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [timers] Only select jobs that are timers. Cannot be used together with &#x60;messages&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [messages] Only select jobs that are messages. Cannot be used together with &#x60;timers&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [dueDates] Only select jobs where the due date is lower or higher than the given date. Due date expressions are comma-separated and are structured as follows:  A valid condition value has the form &#x60;operator_value&#x60;. &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the date value as string.  Valid operator values are: &#x60;gt&#x60; - greater than; &#x60;lt&#x60; - lower than. &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [createTimes] Only select jobs created before or after the given date.  Create time expressions are comma-separated and are structured as follows:  A valid condition value has the form &#x60;operator_value&#x60;. &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the date value as string.  Valid operator values are: &#x60;gt&#x60; - greater than; &#x60;lt&#x60; - lower than. &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [withException] Only select jobs that failed due to an exception. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [exceptionMessage] Only select jobs that failed due to an exception with the given message.
         * @param {string} [failedActivityId] Only select jobs that failed due to an exception at an activity with the given id.
         * @param {boolean} [noRetriesLeft] Only select jobs which have no retries left. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [active] Only include active jobs. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended jobs. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {number} [priorityLowerThanOrEquals] Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {number} [priorityHigherThanOrEquals] Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {string} [tenantIdIn] Only include jobs which belong to one of the passed comma-separated tenant ids.
         * @param {boolean} [withoutTenantId] Only include jobs which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeJobsWithoutTenantId] Include jobs which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobsCount(jobId?: string, jobIds?: string, jobDefinitionId?: string, processInstanceId?: string, processInstanceIds?: string, executionId?: string, processDefinitionId?: string, processDefinitionKey?: string, activityId?: string, withRetriesLeft?: boolean, executable?: boolean, timers?: boolean, messages?: boolean, dueDates?: string, createTimes?: string, withException?: boolean, exceptionMessage?: string, failedActivityId?: string, noRetriesLeft?: boolean, active?: boolean, suspended?: boolean, priorityLowerThanOrEquals?: number, priorityHigherThanOrEquals?: number, tenantIdIn?: string, withoutTenantId?: boolean, includeJobsWithoutTenantId?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<CountResultDto>>> {
            const localVarAxiosArgs = await JobApiAxiosParamCreator(configuration).getJobsCount(jobId, jobIds, jobDefinitionId, processInstanceId, processInstanceIds, executionId, processDefinitionId, processDefinitionKey, activityId, withRetriesLeft, executable, timers, messages, dueDates, createTimes, withException, exceptionMessage, failedActivityId, noRetriesLeft, active, suspended, priorityLowerThanOrEquals, priorityHigherThanOrEquals, tenantIdIn, withoutTenantId, includeJobsWithoutTenantId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves the exception stacktrace corresponding to the passed job id.
         * @summary Get Exception Stacktrace
         * @param {string} id The id of the job to get the exception stacktrace for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStacktrace(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await JobApiAxiosParamCreator(configuration).getStacktrace(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Queries for jobs that fulfill given parameters. This method is slightly more powerful than the [Get Jobs](https://docs.camunda.org/manual/7.18/reference/rest/job/get-query/) method because it allows filtering by multiple jobs of types `String`, `Number` or `Boolean`.
         * @summary Get Jobs (POST)
         * @param {JobQueryDto} [body] 
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryJobs(body?: JobQueryDto, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<JobDto>>>> {
            const localVarAxiosArgs = await JobApiAxiosParamCreator(configuration).queryJobs(body, firstResult, maxResults, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Queries for jobs that fulfill given parameters. This method takes the same message body as the [Get Jobs POST](https://docs.camunda.org/manual/7.18/reference/rest/job/post- query/) method and therefore it is slightly more powerful than the [Get Job Count](https://docs.camunda.org/manual/7.18/reference/rest/job/get-query-count/) method.
         * @summary Get Job Count (POST)
         * @param {JobQueryDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryJobsCount(body?: JobQueryDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<CountResultDto>>> {
            const localVarAxiosArgs = await JobApiAxiosParamCreator(configuration).queryJobsCount(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Recalculates the due date of a job by id.
         * @summary Recalculate Job Due Date
         * @param {string} id The id of the job to be updated.
         * @param {boolean} [creationDateBased] Recalculate the due date based on the creation date of the job or the current date. Value may only be &#x60;false&#x60;, as &#x60;true&#x60; is the default behavior. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recalculateDuedate(id: string, creationDateBased?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await JobApiAxiosParamCreator(configuration).recalculateDuedate(id, creationDateBased, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates the due date of a job by id.
         * @summary Set Job Due Date
         * @param {string} id The id of the job to be updated.
         * @param {JobDuedateDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setJobDuedate(id: string, body?: JobDuedateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await JobApiAxiosParamCreator(configuration).setJobDuedate(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Sets the execution priority of a job by id.
         * @summary Set Job Priority
         * @param {string} id The id of the job to be updated.
         * @param {PriorityDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setJobPriority(id: string, body?: PriorityDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await JobApiAxiosParamCreator(configuration).setJobPriority(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Sets the retries of the job to the given number of retries by id.
         * @summary Set Job Retries
         * @param {string} id The id of the job to be updated.
         * @param {RetriesDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setJobRetries(id: string, body?: RetriesDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await JobApiAxiosParamCreator(configuration).setJobRetries(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a batch to set retries of jobs asynchronously.
         * @summary Set Job Retries Async (POST)
         * @param {SetJobRetriesDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setJobRetriesAsyncOperation(body?: SetJobRetriesDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<BatchDto>>> {
            const localVarAxiosArgs = await JobApiAxiosParamCreator(configuration).setJobRetriesAsyncOperation(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Activates or suspends a given job by id.
         * @summary Activate/Suspend Job By Id
         * @param {string} id The id of the job to activate or suspend.
         * @param {SuspensionStateDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateJobSuspensionState(id: string, body?: SuspensionStateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await JobApiAxiosParamCreator(configuration).updateJobSuspensionState(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Activates or suspends jobs matching the given criterion. This can only be on of: * `jobDefinitionId` * `processDefinitionId` * `processInstanceId` * `processDefinitionKey`
         * @summary Activate/Suspend Jobs
         * @param {JobSuspensionStateDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSuspensionStateBy(body?: JobSuspensionStateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await JobApiAxiosParamCreator(configuration).updateSuspensionStateBy(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * JobApi - factory interface
 * @export
 */
export const JobApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Executes a job by id. **Note:** The execution of the job happens synchronously in the same thread.
         * @summary Execute Job
         * @param {string} id The id of the job to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeJob(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return JobApiFp(configuration).executeJob(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a job by id, according to the `Job` interface in the engine.
         * @summary Get Job
         * @param {string} id The id of the job to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJob(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<JobDto>> {
            return JobApiFp(configuration).getJob(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for jobs that fulfill given parameters. The size of the result set can be retrieved by using the [Get Job Count](https://docs.camunda.org/manual/7.18/reference/rest/job/get-query-count/) method.
         * @summary Get Jobs
         * @param {string} [jobId] Filter by job id.
         * @param {string} [jobIds] Filter by a comma-separated list of job ids.
         * @param {string} [jobDefinitionId] Only select jobs which exist for the given job definition.
         * @param {string} [processInstanceId] Only select jobs which exist for the given process instance.
         * @param {string} [processInstanceIds] Only select jobs which exist for the given comma-separated list of process instance ids.
         * @param {string} [executionId] Only select jobs which exist for the given execution.
         * @param {string} [processDefinitionId] Filter by the id of the process definition the jobs run on.
         * @param {string} [processDefinitionKey] Filter by the key of the process definition the jobs run on.
         * @param {string} [activityId] Only select jobs which exist for an activity with the given id.
         * @param {boolean} [withRetriesLeft] Only select jobs which have retries left. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [executable] Only select jobs which are executable, i.e., retries &gt; 0 and due date is &#x60;null&#x60; or due date is in the past. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [timers] Only select jobs that are timers. Cannot be used together with &#x60;messages&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [messages] Only select jobs that are messages. Cannot be used together with &#x60;timers&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [dueDates] Only select jobs where the due date is lower or higher than the given date. Due date expressions are comma-separated and are structured as follows:  A valid condition value has the form &#x60;operator_value&#x60;. &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the date value as string.  Valid operator values are: &#x60;gt&#x60; - greater than; &#x60;lt&#x60; - lower than. &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [createTimes] Only select jobs created before or after the given date.  Create time expressions are comma-separated and are structured as follows:  A valid condition value has the form &#x60;operator_value&#x60;. &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the date value as string.  Valid operator values are: &#x60;gt&#x60; - greater than; &#x60;lt&#x60; - lower than. &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [withException] Only select jobs that failed due to an exception. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [exceptionMessage] Only select jobs that failed due to an exception with the given message.
         * @param {string} [failedActivityId] Only select jobs that failed due to an exception at an activity with the given id.
         * @param {boolean} [noRetriesLeft] Only select jobs which have no retries left. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [active] Only include active jobs. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended jobs. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {number} [priorityLowerThanOrEquals] Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {number} [priorityHigherThanOrEquals] Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {string} [tenantIdIn] Only include jobs which belong to one of the passed comma-separated tenant ids.
         * @param {boolean} [withoutTenantId] Only include jobs which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeJobsWithoutTenantId] Include jobs which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobs(jobId?: string, jobIds?: string, jobDefinitionId?: string, processInstanceId?: string, processInstanceIds?: string, executionId?: string, processDefinitionId?: string, processDefinitionKey?: string, activityId?: string, withRetriesLeft?: boolean, executable?: boolean, timers?: boolean, messages?: boolean, dueDates?: string, createTimes?: string, withException?: boolean, exceptionMessage?: string, failedActivityId?: string, noRetriesLeft?: boolean, active?: boolean, suspended?: boolean, priorityLowerThanOrEquals?: number, priorityHigherThanOrEquals?: number, tenantIdIn?: string, withoutTenantId?: boolean, includeJobsWithoutTenantId?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<JobDto>>> {
            return JobApiFp(configuration).getJobs(jobId, jobIds, jobDefinitionId, processInstanceId, processInstanceIds, executionId, processDefinitionId, processDefinitionKey, activityId, withRetriesLeft, executable, timers, messages, dueDates, createTimes, withException, exceptionMessage, failedActivityId, noRetriesLeft, active, suspended, priorityLowerThanOrEquals, priorityHigherThanOrEquals, tenantIdIn, withoutTenantId, includeJobsWithoutTenantId, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for the number of jobs that fulfill given parameters. Takes the same parameters as the [Get Jobs](https://docs.camunda.org/manual/7.18/reference/rest/job/get-query/) method.
         * @summary Get Job Count
         * @param {string} [jobId] Filter by job id.
         * @param {string} [jobIds] Filter by a comma-separated list of job ids.
         * @param {string} [jobDefinitionId] Only select jobs which exist for the given job definition.
         * @param {string} [processInstanceId] Only select jobs which exist for the given process instance.
         * @param {string} [processInstanceIds] Only select jobs which exist for the given comma-separated list of process instance ids.
         * @param {string} [executionId] Only select jobs which exist for the given execution.
         * @param {string} [processDefinitionId] Filter by the id of the process definition the jobs run on.
         * @param {string} [processDefinitionKey] Filter by the key of the process definition the jobs run on.
         * @param {string} [activityId] Only select jobs which exist for an activity with the given id.
         * @param {boolean} [withRetriesLeft] Only select jobs which have retries left. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [executable] Only select jobs which are executable, i.e., retries &gt; 0 and due date is &#x60;null&#x60; or due date is in the past. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [timers] Only select jobs that are timers. Cannot be used together with &#x60;messages&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [messages] Only select jobs that are messages. Cannot be used together with &#x60;timers&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [dueDates] Only select jobs where the due date is lower or higher than the given date. Due date expressions are comma-separated and are structured as follows:  A valid condition value has the form &#x60;operator_value&#x60;. &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the date value as string.  Valid operator values are: &#x60;gt&#x60; - greater than; &#x60;lt&#x60; - lower than. &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [createTimes] Only select jobs created before or after the given date.  Create time expressions are comma-separated and are structured as follows:  A valid condition value has the form &#x60;operator_value&#x60;. &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the date value as string.  Valid operator values are: &#x60;gt&#x60; - greater than; &#x60;lt&#x60; - lower than. &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [withException] Only select jobs that failed due to an exception. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [exceptionMessage] Only select jobs that failed due to an exception with the given message.
         * @param {string} [failedActivityId] Only select jobs that failed due to an exception at an activity with the given id.
         * @param {boolean} [noRetriesLeft] Only select jobs which have no retries left. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [active] Only include active jobs. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended jobs. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {number} [priorityLowerThanOrEquals] Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {number} [priorityHigherThanOrEquals] Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {string} [tenantIdIn] Only include jobs which belong to one of the passed comma-separated tenant ids.
         * @param {boolean} [withoutTenantId] Only include jobs which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeJobsWithoutTenantId] Include jobs which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobsCount(jobId?: string, jobIds?: string, jobDefinitionId?: string, processInstanceId?: string, processInstanceIds?: string, executionId?: string, processDefinitionId?: string, processDefinitionKey?: string, activityId?: string, withRetriesLeft?: boolean, executable?: boolean, timers?: boolean, messages?: boolean, dueDates?: string, createTimes?: string, withException?: boolean, exceptionMessage?: string, failedActivityId?: string, noRetriesLeft?: boolean, active?: boolean, suspended?: boolean, priorityLowerThanOrEquals?: number, priorityHigherThanOrEquals?: number, tenantIdIn?: string, withoutTenantId?: boolean, includeJobsWithoutTenantId?: boolean, options?: AxiosRequestConfig): Promise<AxiosResponse<CountResultDto>> {
            return JobApiFp(configuration).getJobsCount(jobId, jobIds, jobDefinitionId, processInstanceId, processInstanceIds, executionId, processDefinitionId, processDefinitionKey, activityId, withRetriesLeft, executable, timers, messages, dueDates, createTimes, withException, exceptionMessage, failedActivityId, noRetriesLeft, active, suspended, priorityLowerThanOrEquals, priorityHigherThanOrEquals, tenantIdIn, withoutTenantId, includeJobsWithoutTenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the exception stacktrace corresponding to the passed job id.
         * @summary Get Exception Stacktrace
         * @param {string} id The id of the job to get the exception stacktrace for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStacktrace(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return JobApiFp(configuration).getStacktrace(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for jobs that fulfill given parameters. This method is slightly more powerful than the [Get Jobs](https://docs.camunda.org/manual/7.18/reference/rest/job/get-query/) method because it allows filtering by multiple jobs of types `String`, `Number` or `Boolean`.
         * @summary Get Jobs (POST)
         * @param {JobQueryDto} [body] 
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryJobs(body?: JobQueryDto, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<JobDto>>> {
            return JobApiFp(configuration).queryJobs(body, firstResult, maxResults, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for jobs that fulfill given parameters. This method takes the same message body as the [Get Jobs POST](https://docs.camunda.org/manual/7.18/reference/rest/job/post- query/) method and therefore it is slightly more powerful than the [Get Job Count](https://docs.camunda.org/manual/7.18/reference/rest/job/get-query-count/) method.
         * @summary Get Job Count (POST)
         * @param {JobQueryDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryJobsCount(body?: JobQueryDto, options?: AxiosRequestConfig): Promise<AxiosResponse<CountResultDto>> {
            return JobApiFp(configuration).queryJobsCount(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Recalculates the due date of a job by id.
         * @summary Recalculate Job Due Date
         * @param {string} id The id of the job to be updated.
         * @param {boolean} [creationDateBased] Recalculate the due date based on the creation date of the job or the current date. Value may only be &#x60;false&#x60;, as &#x60;true&#x60; is the default behavior. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recalculateDuedate(id: string, creationDateBased?: boolean, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return JobApiFp(configuration).recalculateDuedate(id, creationDateBased, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the due date of a job by id.
         * @summary Set Job Due Date
         * @param {string} id The id of the job to be updated.
         * @param {JobDuedateDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setJobDuedate(id: string, body?: JobDuedateDto, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return JobApiFp(configuration).setJobDuedate(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the execution priority of a job by id.
         * @summary Set Job Priority
         * @param {string} id The id of the job to be updated.
         * @param {PriorityDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setJobPriority(id: string, body?: PriorityDto, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return JobApiFp(configuration).setJobPriority(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the retries of the job to the given number of retries by id.
         * @summary Set Job Retries
         * @param {string} id The id of the job to be updated.
         * @param {RetriesDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setJobRetries(id: string, body?: RetriesDto, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return JobApiFp(configuration).setJobRetries(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a batch to set retries of jobs asynchronously.
         * @summary Set Job Retries Async (POST)
         * @param {SetJobRetriesDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setJobRetriesAsyncOperation(body?: SetJobRetriesDto, options?: AxiosRequestConfig): Promise<AxiosResponse<BatchDto>> {
            return JobApiFp(configuration).setJobRetriesAsyncOperation(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Activates or suspends a given job by id.
         * @summary Activate/Suspend Job By Id
         * @param {string} id The id of the job to activate or suspend.
         * @param {SuspensionStateDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateJobSuspensionState(id: string, body?: SuspensionStateDto, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return JobApiFp(configuration).updateJobSuspensionState(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Activates or suspends jobs matching the given criterion. This can only be on of: * `jobDefinitionId` * `processDefinitionId` * `processInstanceId` * `processDefinitionKey`
         * @summary Activate/Suspend Jobs
         * @param {JobSuspensionStateDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSuspensionStateBy(body?: JobSuspensionStateDto, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return JobApiFp(configuration).updateSuspensionStateBy(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobApi - object-oriented interface
 * @export
 * @class JobApi
 * @extends {BaseAPI}
 */
export class JobApi extends BaseAPI {
    /**
     * Executes a job by id. **Note:** The execution of the job happens synchronously in the same thread.
     * @summary Execute Job
     * @param {string} id The id of the job to be executed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public async executeJob(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return JobApiFp(this.configuration).executeJob(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a job by id, according to the `Job` interface in the engine.
     * @summary Get Job
     * @param {string} id The id of the job to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public async getJob(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<JobDto>> {
        return JobApiFp(this.configuration).getJob(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Queries for jobs that fulfill given parameters. The size of the result set can be retrieved by using the [Get Job Count](https://docs.camunda.org/manual/7.18/reference/rest/job/get-query-count/) method.
     * @summary Get Jobs
     * @param {string} [jobId] Filter by job id.
     * @param {string} [jobIds] Filter by a comma-separated list of job ids.
     * @param {string} [jobDefinitionId] Only select jobs which exist for the given job definition.
     * @param {string} [processInstanceId] Only select jobs which exist for the given process instance.
     * @param {string} [processInstanceIds] Only select jobs which exist for the given comma-separated list of process instance ids.
     * @param {string} [executionId] Only select jobs which exist for the given execution.
     * @param {string} [processDefinitionId] Filter by the id of the process definition the jobs run on.
     * @param {string} [processDefinitionKey] Filter by the key of the process definition the jobs run on.
     * @param {string} [activityId] Only select jobs which exist for an activity with the given id.
     * @param {boolean} [withRetriesLeft] Only select jobs which have retries left. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [executable] Only select jobs which are executable, i.e., retries &gt; 0 and due date is &#x60;null&#x60; or due date is in the past. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [timers] Only select jobs that are timers. Cannot be used together with &#x60;messages&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [messages] Only select jobs that are messages. Cannot be used together with &#x60;timers&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [dueDates] Only select jobs where the due date is lower or higher than the given date. Due date expressions are comma-separated and are structured as follows:  A valid condition value has the form &#x60;operator_value&#x60;. &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the date value as string.  Valid operator values are: &#x60;gt&#x60; - greater than; &#x60;lt&#x60; - lower than. &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {string} [createTimes] Only select jobs created before or after the given date.  Create time expressions are comma-separated and are structured as follows:  A valid condition value has the form &#x60;operator_value&#x60;. &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the date value as string.  Valid operator values are: &#x60;gt&#x60; - greater than; &#x60;lt&#x60; - lower than. &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {boolean} [withException] Only select jobs that failed due to an exception. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [exceptionMessage] Only select jobs that failed due to an exception with the given message.
     * @param {string} [failedActivityId] Only select jobs that failed due to an exception at an activity with the given id.
     * @param {boolean} [noRetriesLeft] Only select jobs which have no retries left. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [active] Only include active jobs. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [suspended] Only include suspended jobs. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {number} [priorityLowerThanOrEquals] Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
     * @param {number} [priorityHigherThanOrEquals] Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
     * @param {string} [tenantIdIn] Only include jobs which belong to one of the passed comma-separated tenant ids.
     * @param {boolean} [withoutTenantId] Only include jobs which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [includeJobsWithoutTenantId] Include jobs which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public async getJobs(jobId?: string, jobIds?: string, jobDefinitionId?: string, processInstanceId?: string, processInstanceIds?: string, executionId?: string, processDefinitionId?: string, processDefinitionKey?: string, activityId?: string, withRetriesLeft?: boolean, executable?: boolean, timers?: boolean, messages?: boolean, dueDates?: string, createTimes?: string, withException?: boolean, exceptionMessage?: string, failedActivityId?: string, noRetriesLeft?: boolean, active?: boolean, suspended?: boolean, priorityLowerThanOrEquals?: number, priorityHigherThanOrEquals?: number, tenantIdIn?: string, withoutTenantId?: boolean, includeJobsWithoutTenantId?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<JobDto>>> {
        return JobApiFp(this.configuration).getJobs(jobId, jobIds, jobDefinitionId, processInstanceId, processInstanceIds, executionId, processDefinitionId, processDefinitionKey, activityId, withRetriesLeft, executable, timers, messages, dueDates, createTimes, withException, exceptionMessage, failedActivityId, noRetriesLeft, active, suspended, priorityLowerThanOrEquals, priorityHigherThanOrEquals, tenantIdIn, withoutTenantId, includeJobsWithoutTenantId, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Queries for the number of jobs that fulfill given parameters. Takes the same parameters as the [Get Jobs](https://docs.camunda.org/manual/7.18/reference/rest/job/get-query/) method.
     * @summary Get Job Count
     * @param {string} [jobId] Filter by job id.
     * @param {string} [jobIds] Filter by a comma-separated list of job ids.
     * @param {string} [jobDefinitionId] Only select jobs which exist for the given job definition.
     * @param {string} [processInstanceId] Only select jobs which exist for the given process instance.
     * @param {string} [processInstanceIds] Only select jobs which exist for the given comma-separated list of process instance ids.
     * @param {string} [executionId] Only select jobs which exist for the given execution.
     * @param {string} [processDefinitionId] Filter by the id of the process definition the jobs run on.
     * @param {string} [processDefinitionKey] Filter by the key of the process definition the jobs run on.
     * @param {string} [activityId] Only select jobs which exist for an activity with the given id.
     * @param {boolean} [withRetriesLeft] Only select jobs which have retries left. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [executable] Only select jobs which are executable, i.e., retries &gt; 0 and due date is &#x60;null&#x60; or due date is in the past. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [timers] Only select jobs that are timers. Cannot be used together with &#x60;messages&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [messages] Only select jobs that are messages. Cannot be used together with &#x60;timers&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [dueDates] Only select jobs where the due date is lower or higher than the given date. Due date expressions are comma-separated and are structured as follows:  A valid condition value has the form &#x60;operator_value&#x60;. &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the date value as string.  Valid operator values are: &#x60;gt&#x60; - greater than; &#x60;lt&#x60; - lower than. &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {string} [createTimes] Only select jobs created before or after the given date.  Create time expressions are comma-separated and are structured as follows:  A valid condition value has the form &#x60;operator_value&#x60;. &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the date value as string.  Valid operator values are: &#x60;gt&#x60; - greater than; &#x60;lt&#x60; - lower than. &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {boolean} [withException] Only select jobs that failed due to an exception. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [exceptionMessage] Only select jobs that failed due to an exception with the given message.
     * @param {string} [failedActivityId] Only select jobs that failed due to an exception at an activity with the given id.
     * @param {boolean} [noRetriesLeft] Only select jobs which have no retries left. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [active] Only include active jobs. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [suspended] Only include suspended jobs. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {number} [priorityLowerThanOrEquals] Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
     * @param {number} [priorityHigherThanOrEquals] Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
     * @param {string} [tenantIdIn] Only include jobs which belong to one of the passed comma-separated tenant ids.
     * @param {boolean} [withoutTenantId] Only include jobs which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [includeJobsWithoutTenantId] Include jobs which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public async getJobsCount(jobId?: string, jobIds?: string, jobDefinitionId?: string, processInstanceId?: string, processInstanceIds?: string, executionId?: string, processDefinitionId?: string, processDefinitionKey?: string, activityId?: string, withRetriesLeft?: boolean, executable?: boolean, timers?: boolean, messages?: boolean, dueDates?: string, createTimes?: string, withException?: boolean, exceptionMessage?: string, failedActivityId?: string, noRetriesLeft?: boolean, active?: boolean, suspended?: boolean, priorityLowerThanOrEquals?: number, priorityHigherThanOrEquals?: number, tenantIdIn?: string, withoutTenantId?: boolean, includeJobsWithoutTenantId?: boolean, options?: AxiosRequestConfig) : Promise<AxiosResponse<CountResultDto>> {
        return JobApiFp(this.configuration).getJobsCount(jobId, jobIds, jobDefinitionId, processInstanceId, processInstanceIds, executionId, processDefinitionId, processDefinitionKey, activityId, withRetriesLeft, executable, timers, messages, dueDates, createTimes, withException, exceptionMessage, failedActivityId, noRetriesLeft, active, suspended, priorityLowerThanOrEquals, priorityHigherThanOrEquals, tenantIdIn, withoutTenantId, includeJobsWithoutTenantId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the exception stacktrace corresponding to the passed job id.
     * @summary Get Exception Stacktrace
     * @param {string} id The id of the job to get the exception stacktrace for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public async getStacktrace(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return JobApiFp(this.configuration).getStacktrace(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Queries for jobs that fulfill given parameters. This method is slightly more powerful than the [Get Jobs](https://docs.camunda.org/manual/7.18/reference/rest/job/get-query/) method because it allows filtering by multiple jobs of types `String`, `Number` or `Boolean`.
     * @summary Get Jobs (POST)
     * @param {JobQueryDto} [body] 
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public async queryJobs(body?: JobQueryDto, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<JobDto>>> {
        return JobApiFp(this.configuration).queryJobs(body, firstResult, maxResults, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Queries for jobs that fulfill given parameters. This method takes the same message body as the [Get Jobs POST](https://docs.camunda.org/manual/7.18/reference/rest/job/post- query/) method and therefore it is slightly more powerful than the [Get Job Count](https://docs.camunda.org/manual/7.18/reference/rest/job/get-query-count/) method.
     * @summary Get Job Count (POST)
     * @param {JobQueryDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public async queryJobsCount(body?: JobQueryDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<CountResultDto>> {
        return JobApiFp(this.configuration).queryJobsCount(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Recalculates the due date of a job by id.
     * @summary Recalculate Job Due Date
     * @param {string} id The id of the job to be updated.
     * @param {boolean} [creationDateBased] Recalculate the due date based on the creation date of the job or the current date. Value may only be &#x60;false&#x60;, as &#x60;true&#x60; is the default behavior. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public async recalculateDuedate(id: string, creationDateBased?: boolean, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return JobApiFp(this.configuration).recalculateDuedate(id, creationDateBased, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the due date of a job by id.
     * @summary Set Job Due Date
     * @param {string} id The id of the job to be updated.
     * @param {JobDuedateDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public async setJobDuedate(id: string, body?: JobDuedateDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return JobApiFp(this.configuration).setJobDuedate(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sets the execution priority of a job by id.
     * @summary Set Job Priority
     * @param {string} id The id of the job to be updated.
     * @param {PriorityDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public async setJobPriority(id: string, body?: PriorityDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return JobApiFp(this.configuration).setJobPriority(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sets the retries of the job to the given number of retries by id.
     * @summary Set Job Retries
     * @param {string} id The id of the job to be updated.
     * @param {RetriesDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public async setJobRetries(id: string, body?: RetriesDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return JobApiFp(this.configuration).setJobRetries(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a batch to set retries of jobs asynchronously.
     * @summary Set Job Retries Async (POST)
     * @param {SetJobRetriesDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public async setJobRetriesAsyncOperation(body?: SetJobRetriesDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<BatchDto>> {
        return JobApiFp(this.configuration).setJobRetriesAsyncOperation(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Activates or suspends a given job by id.
     * @summary Activate/Suspend Job By Id
     * @param {string} id The id of the job to activate or suspend.
     * @param {SuspensionStateDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public async updateJobSuspensionState(id: string, body?: SuspensionStateDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return JobApiFp(this.configuration).updateJobSuspensionState(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Activates or suspends jobs matching the given criterion. This can only be on of: * `jobDefinitionId` * `processDefinitionId` * `processInstanceId` * `processDefinitionKey`
     * @summary Activate/Suspend Jobs
     * @param {JobSuspensionStateDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public async updateSuspensionStateBy(body?: JobSuspensionStateDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return JobApiFp(this.configuration).updateSuspensionStateBy(body, options).then((request) => request(this.axios, this.basePath));
    }
}

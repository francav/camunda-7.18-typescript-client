/* tslint:disable */
/* eslint-disable */
/**
 * Camunda Platform REST API
 * OpenApi Spec for Camunda Platform REST API.
 *
 * OpenAPI spec version: 7.18.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { CountResultDto } from '../models';
import { CreateFilterDto } from '../models';
import { ExceptionDto } from '../models';
import { FilterDto } from '../models';
import { ResourceOptionsDto } from '../models';
/**
 * FilterApi - axios parameter creator
 * @export
 */
export const FilterApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new filter.
         * @summary Create Filter
         * @param {CreateFilterDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFilter: async (body?: CreateFilterDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/filter/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a filter by id.
         * @summary Delete Filter
         * @param {string} id The id of the filter to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFilter: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteFilter.');
            }
            const localVarPath = `/filter/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Executes the saved query of the filter by id and returns the count.
         * @summary Execute Filter Count
         * @param {string} id The id of the filter to execute.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeFilterCount: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling executeFilterCount.');
            }
            const localVarPath = `/filter/{id}/count`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Executes the saved query of the filter by id and returns the result list.
         * @summary Execute Filter List
         * @param {string} id The id of the filter to execute.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeFilterList: async (id: string, firstResult?: number, maxResults?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling executeFilterList.');
            }
            const localVarPath = `/filter/{id}/list`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Executes the saved query of the filter by id and returns the single result.
         * @summary Execute Filter Single Result
         * @param {string} id The id of the filter to execute.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeFilterSingleResult: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling executeFilterSingleResult.');
            }
            const localVarPath = `/filter/{id}/singleResult`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * The OPTIONS request allows you to check for the set of available operations  that the currently authenticated user can perform on the `/filter` resource. Whether the user can perform an operation or not may depend on various factors, including the users authorizations to interact with this resource and the internal configuration of the process engine.
         * @summary Filter Resource Options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filterResourceOptions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * The OPTIONS request allows you to check for the set of available operations  that the currently authenticated user can perform on the `/filter` resource. Whether the user can perform an operation or not may depend on various factors, including the users authorizations to interact with this resource and the internal configuration of the process engine.
         * @summary Filter Resource Options
         * @param {string} id The id of the filter to be checked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filterResourceOptionsSingle: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling filterResourceOptionsSingle.');
            }
            const localVarPath = `/filter/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the number of filters that fulfill a provided query. Corresponds to the size of the result set when using the  [Get Filters](https://docs.camunda.org/manual/7.18/reference/rest/filter/get-query/) method.
         * @summary Get Filter Count
         * @param {string} [filterId] Filter by the id of the filter.
         * @param {string} [resourceType] Filter by the resource type of the filter, e.g., &#x60;Task&#x60;.
         * @param {string} [name] Filter by the name of the filter.
         * @param {string} [nameLike] Filter by the name that the parameter is a substring of.
         * @param {string} [owner] Filter by the user id of the owner of the filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilterCount: async (filterId?: string, resourceType?: string, name?: string, nameLike?: string, owner?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/filter/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterId !== undefined) {
                localVarQueryParameter['filterId'] = filterId;
            }

            if (resourceType !== undefined) {
                localVarQueryParameter['resourceType'] = resourceType;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameLike !== undefined) {
                localVarQueryParameter['nameLike'] = nameLike;
            }

            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for a list of filters using a list of parameters. The size of the result set can be retrieved by using the [Get Filter Count](https://docs.camunda.org/manual/7.18/reference/rest/filter/get-query-count/) method.
         * @summary Get Filters
         * @param {string} [filterId] Filter by the id of the filter.
         * @param {string} [resourceType] Filter by the resource type of the filter, e.g., &#x60;Task&#x60;.
         * @param {string} [name] Filter by the name of the filter.
         * @param {string} [nameLike] Filter by the name that the parameter is a substring of.
         * @param {string} [owner] Filter by the user id of the owner of the filter.
         * @param {boolean} [itemCount] If set to &#x60;true&#x60;, each filter result will contain an &#x60;itemCount&#x60; property with the number of items matched by the filter itself.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilterList: async (filterId?: string, resourceType?: string, name?: string, nameLike?: string, owner?: string, itemCount?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterId !== undefined) {
                localVarQueryParameter['filterId'] = filterId;
            }

            if (resourceType !== undefined) {
                localVarQueryParameter['resourceType'] = resourceType;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameLike !== undefined) {
                localVarQueryParameter['nameLike'] = nameLike;
            }

            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }

            if (itemCount !== undefined) {
                localVarQueryParameter['itemCount'] = itemCount;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single filter by id, according to the `Filter` interface in the engine.
         * @summary Get Single Filter
         * @param {string} id The id of the filter to be retrieved.
         * @param {boolean} [itemCount] If set to &#x60;true&#x60;, each filter result will contain an &#x60;itemCount&#x60; property with the number of items matched by the filter itself.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleFilter: async (id: string, itemCount?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSingleFilter.');
            }
            const localVarPath = `/filter/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (itemCount !== undefined) {
                localVarQueryParameter['itemCount'] = itemCount;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Executes the saved query of the filter by id and returns the count. This method is slightly more powerful then the [Get Execute Filter Count](https://docs.camunda.org/manual/7.18/reference/rest/filter/get-execute-count/)  method because it allows to extend the saved query of the filter.
         * @summary Execute Filter Count (POST)
         * @param {string} id The id of the filter to execute.
         * @param {any} [body] A JSON object which corresponds to the type of the saved query of the filter, i.e., if the resource type of the filter is Task the body should form a valid task query corresponding to the Task resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postExecuteFilterCount: async (id: string, body?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling postExecuteFilterCount.');
            }
            const localVarPath = `/filter/{id}/count`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Executes the saved query of the filter by id and returns the result list. This method is slightly more powerful then the  [Get Execute FilterList](https://docs.camunda.org/manual/7.18/reference/rest/filter/get-execute-list/) method because it allows to extend the saved query of the filter.
         * @summary Execute Filter List (POST)
         * @param {string} id The id of the filter to execute.
         * @param {any} [body] A JSON object which corresponds to the type of the saved query of the filter, i.e., if the resource type of the filter is Task the body should form a valid task query corresponding to the Task resource.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postExecuteFilterList: async (id: string, body?: any, firstResult?: number, maxResults?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling postExecuteFilterList.');
            }
            const localVarPath = `/filter/{id}/list`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Executes the saved query of the filter by id and returns the single result. This method is slightly more powerful then the [Get Execute Filter Single Result](https://docs.camunda.org/manual/7.18/reference/rest/filter/get-execute-single-result/) method because it allows to extend the saved query of the filter.
         * @summary Execute Filter Single Result (POST)
         * @param {string} id The id of the filter to execute.
         * @param {any} [body] A JSON object which corresponds to the type of the saved query of the filter, i.e., if the resource type of the filter is Task the body should form a valid task query corresponding to the Task resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postExecuteFilterSingleResult: async (id: string, body?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling postExecuteFilterSingleResult.');
            }
            const localVarPath = `/filter/{id}/singleResult`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing filter.
         * @summary Update Filter
         * @param {string} id The id of the filter to be updated.
         * @param {CreateFilterDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFilter: async (id: string, body?: CreateFilterDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateFilter.');
            }
            const localVarPath = `/filter/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilterApi - functional programming interface
 * @export
 */
export const FilterApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a new filter.
         * @summary Create Filter
         * @param {CreateFilterDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFilter(body?: CreateFilterDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<FilterDto>>> {
            const localVarAxiosArgs = await FilterApiAxiosParamCreator(configuration).createFilter(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes a filter by id.
         * @summary Delete Filter
         * @param {string} id The id of the filter to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFilter(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await FilterApiAxiosParamCreator(configuration).deleteFilter(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Executes the saved query of the filter by id and returns the count.
         * @summary Execute Filter Count
         * @param {string} id The id of the filter to execute.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeFilterCount(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<CountResultDto>>> {
            const localVarAxiosArgs = await FilterApiAxiosParamCreator(configuration).executeFilterCount(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Executes the saved query of the filter by id and returns the result list.
         * @summary Execute Filter List
         * @param {string} id The id of the filter to execute.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeFilterList(id: string, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<any>>>> {
            const localVarAxiosArgs = await FilterApiAxiosParamCreator(configuration).executeFilterList(id, firstResult, maxResults, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Executes the saved query of the filter by id and returns the single result.
         * @summary Execute Filter Single Result
         * @param {string} id The id of the filter to execute.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeFilterSingleResult(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await FilterApiAxiosParamCreator(configuration).executeFilterSingleResult(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * The OPTIONS request allows you to check for the set of available operations  that the currently authenticated user can perform on the `/filter` resource. Whether the user can perform an operation or not may depend on various factors, including the users authorizations to interact with this resource and the internal configuration of the process engine.
         * @summary Filter Resource Options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filterResourceOptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResourceOptionsDto>>> {
            const localVarAxiosArgs = await FilterApiAxiosParamCreator(configuration).filterResourceOptions(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * The OPTIONS request allows you to check for the set of available operations  that the currently authenticated user can perform on the `/filter` resource. Whether the user can perform an operation or not may depend on various factors, including the users authorizations to interact with this resource and the internal configuration of the process engine.
         * @summary Filter Resource Options
         * @param {string} id The id of the filter to be checked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filterResourceOptionsSingle(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResourceOptionsDto>>> {
            const localVarAxiosArgs = await FilterApiAxiosParamCreator(configuration).filterResourceOptionsSingle(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves the number of filters that fulfill a provided query. Corresponds to the size of the result set when using the  [Get Filters](https://docs.camunda.org/manual/7.18/reference/rest/filter/get-query/) method.
         * @summary Get Filter Count
         * @param {string} [filterId] Filter by the id of the filter.
         * @param {string} [resourceType] Filter by the resource type of the filter, e.g., &#x60;Task&#x60;.
         * @param {string} [name] Filter by the name of the filter.
         * @param {string} [nameLike] Filter by the name that the parameter is a substring of.
         * @param {string} [owner] Filter by the user id of the owner of the filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFilterCount(filterId?: string, resourceType?: string, name?: string, nameLike?: string, owner?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<CountResultDto>>> {
            const localVarAxiosArgs = await FilterApiAxiosParamCreator(configuration).getFilterCount(filterId, resourceType, name, nameLike, owner, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Queries for a list of filters using a list of parameters. The size of the result set can be retrieved by using the [Get Filter Count](https://docs.camunda.org/manual/7.18/reference/rest/filter/get-query-count/) method.
         * @summary Get Filters
         * @param {string} [filterId] Filter by the id of the filter.
         * @param {string} [resourceType] Filter by the resource type of the filter, e.g., &#x60;Task&#x60;.
         * @param {string} [name] Filter by the name of the filter.
         * @param {string} [nameLike] Filter by the name that the parameter is a substring of.
         * @param {string} [owner] Filter by the user id of the owner of the filter.
         * @param {boolean} [itemCount] If set to &#x60;true&#x60;, each filter result will contain an &#x60;itemCount&#x60; property with the number of items matched by the filter itself.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFilterList(filterId?: string, resourceType?: string, name?: string, nameLike?: string, owner?: string, itemCount?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<FilterDto>>>> {
            const localVarAxiosArgs = await FilterApiAxiosParamCreator(configuration).getFilterList(filterId, resourceType, name, nameLike, owner, itemCount, sortBy, sortOrder, firstResult, maxResults, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves a single filter by id, according to the `Filter` interface in the engine.
         * @summary Get Single Filter
         * @param {string} id The id of the filter to be retrieved.
         * @param {boolean} [itemCount] If set to &#x60;true&#x60;, each filter result will contain an &#x60;itemCount&#x60; property with the number of items matched by the filter itself.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleFilter(id: string, itemCount?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<FilterDto>>> {
            const localVarAxiosArgs = await FilterApiAxiosParamCreator(configuration).getSingleFilter(id, itemCount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Executes the saved query of the filter by id and returns the count. This method is slightly more powerful then the [Get Execute Filter Count](https://docs.camunda.org/manual/7.18/reference/rest/filter/get-execute-count/)  method because it allows to extend the saved query of the filter.
         * @summary Execute Filter Count (POST)
         * @param {string} id The id of the filter to execute.
         * @param {any} [body] A JSON object which corresponds to the type of the saved query of the filter, i.e., if the resource type of the filter is Task the body should form a valid task query corresponding to the Task resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postExecuteFilterCount(id: string, body?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<CountResultDto>>> {
            const localVarAxiosArgs = await FilterApiAxiosParamCreator(configuration).postExecuteFilterCount(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Executes the saved query of the filter by id and returns the result list. This method is slightly more powerful then the  [Get Execute FilterList](https://docs.camunda.org/manual/7.18/reference/rest/filter/get-execute-list/) method because it allows to extend the saved query of the filter.
         * @summary Execute Filter List (POST)
         * @param {string} id The id of the filter to execute.
         * @param {any} [body] A JSON object which corresponds to the type of the saved query of the filter, i.e., if the resource type of the filter is Task the body should form a valid task query corresponding to the Task resource.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postExecuteFilterList(id: string, body?: any, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<any>>>> {
            const localVarAxiosArgs = await FilterApiAxiosParamCreator(configuration).postExecuteFilterList(id, body, firstResult, maxResults, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Executes the saved query of the filter by id and returns the single result. This method is slightly more powerful then the [Get Execute Filter Single Result](https://docs.camunda.org/manual/7.18/reference/rest/filter/get-execute-single-result/) method because it allows to extend the saved query of the filter.
         * @summary Execute Filter Single Result (POST)
         * @param {string} id The id of the filter to execute.
         * @param {any} [body] A JSON object which corresponds to the type of the saved query of the filter, i.e., if the resource type of the filter is Task the body should form a valid task query corresponding to the Task resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postExecuteFilterSingleResult(id: string, body?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await FilterApiAxiosParamCreator(configuration).postExecuteFilterSingleResult(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates an existing filter.
         * @summary Update Filter
         * @param {string} id The id of the filter to be updated.
         * @param {CreateFilterDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFilter(id: string, body?: CreateFilterDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await FilterApiAxiosParamCreator(configuration).updateFilter(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * FilterApi - factory interface
 * @export
 */
export const FilterApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Creates a new filter.
         * @summary Create Filter
         * @param {CreateFilterDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFilter(body?: CreateFilterDto, options?: AxiosRequestConfig): Promise<AxiosResponse<FilterDto>> {
            return FilterApiFp(configuration).createFilter(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a filter by id.
         * @summary Delete Filter
         * @param {string} id The id of the filter to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFilter(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return FilterApiFp(configuration).deleteFilter(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Executes the saved query of the filter by id and returns the count.
         * @summary Execute Filter Count
         * @param {string} id The id of the filter to execute.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeFilterCount(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<CountResultDto>> {
            return FilterApiFp(configuration).executeFilterCount(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Executes the saved query of the filter by id and returns the result list.
         * @summary Execute Filter List
         * @param {string} id The id of the filter to execute.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeFilterList(id: string, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<any>>> {
            return FilterApiFp(configuration).executeFilterList(id, firstResult, maxResults, options).then((request) => request(axios, basePath));
        },
        /**
         * Executes the saved query of the filter by id and returns the single result.
         * @summary Execute Filter Single Result
         * @param {string} id The id of the filter to execute.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeFilterSingleResult(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return FilterApiFp(configuration).executeFilterSingleResult(id, options).then((request) => request(axios, basePath));
        },
        /**
         * The OPTIONS request allows you to check for the set of available operations  that the currently authenticated user can perform on the `/filter` resource. Whether the user can perform an operation or not may depend on various factors, including the users authorizations to interact with this resource and the internal configuration of the process engine.
         * @summary Filter Resource Options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filterResourceOptions(options?: AxiosRequestConfig): Promise<AxiosResponse<ResourceOptionsDto>> {
            return FilterApiFp(configuration).filterResourceOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * The OPTIONS request allows you to check for the set of available operations  that the currently authenticated user can perform on the `/filter` resource. Whether the user can perform an operation or not may depend on various factors, including the users authorizations to interact with this resource and the internal configuration of the process engine.
         * @summary Filter Resource Options
         * @param {string} id The id of the filter to be checked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filterResourceOptionsSingle(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<ResourceOptionsDto>> {
            return FilterApiFp(configuration).filterResourceOptionsSingle(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the number of filters that fulfill a provided query. Corresponds to the size of the result set when using the  [Get Filters](https://docs.camunda.org/manual/7.18/reference/rest/filter/get-query/) method.
         * @summary Get Filter Count
         * @param {string} [filterId] Filter by the id of the filter.
         * @param {string} [resourceType] Filter by the resource type of the filter, e.g., &#x60;Task&#x60;.
         * @param {string} [name] Filter by the name of the filter.
         * @param {string} [nameLike] Filter by the name that the parameter is a substring of.
         * @param {string} [owner] Filter by the user id of the owner of the filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFilterCount(filterId?: string, resourceType?: string, name?: string, nameLike?: string, owner?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<CountResultDto>> {
            return FilterApiFp(configuration).getFilterCount(filterId, resourceType, name, nameLike, owner, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for a list of filters using a list of parameters. The size of the result set can be retrieved by using the [Get Filter Count](https://docs.camunda.org/manual/7.18/reference/rest/filter/get-query-count/) method.
         * @summary Get Filters
         * @param {string} [filterId] Filter by the id of the filter.
         * @param {string} [resourceType] Filter by the resource type of the filter, e.g., &#x60;Task&#x60;.
         * @param {string} [name] Filter by the name of the filter.
         * @param {string} [nameLike] Filter by the name that the parameter is a substring of.
         * @param {string} [owner] Filter by the user id of the owner of the filter.
         * @param {boolean} [itemCount] If set to &#x60;true&#x60;, each filter result will contain an &#x60;itemCount&#x60; property with the number of items matched by the filter itself.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFilterList(filterId?: string, resourceType?: string, name?: string, nameLike?: string, owner?: string, itemCount?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<FilterDto>>> {
            return FilterApiFp(configuration).getFilterList(filterId, resourceType, name, nameLike, owner, itemCount, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single filter by id, according to the `Filter` interface in the engine.
         * @summary Get Single Filter
         * @param {string} id The id of the filter to be retrieved.
         * @param {boolean} [itemCount] If set to &#x60;true&#x60;, each filter result will contain an &#x60;itemCount&#x60; property with the number of items matched by the filter itself.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleFilter(id: string, itemCount?: boolean, options?: AxiosRequestConfig): Promise<AxiosResponse<FilterDto>> {
            return FilterApiFp(configuration).getSingleFilter(id, itemCount, options).then((request) => request(axios, basePath));
        },
        /**
         * Executes the saved query of the filter by id and returns the count. This method is slightly more powerful then the [Get Execute Filter Count](https://docs.camunda.org/manual/7.18/reference/rest/filter/get-execute-count/)  method because it allows to extend the saved query of the filter.
         * @summary Execute Filter Count (POST)
         * @param {string} id The id of the filter to execute.
         * @param {any} [body] A JSON object which corresponds to the type of the saved query of the filter, i.e., if the resource type of the filter is Task the body should form a valid task query corresponding to the Task resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postExecuteFilterCount(id: string, body?: any, options?: AxiosRequestConfig): Promise<AxiosResponse<CountResultDto>> {
            return FilterApiFp(configuration).postExecuteFilterCount(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Executes the saved query of the filter by id and returns the result list. This method is slightly more powerful then the  [Get Execute FilterList](https://docs.camunda.org/manual/7.18/reference/rest/filter/get-execute-list/) method because it allows to extend the saved query of the filter.
         * @summary Execute Filter List (POST)
         * @param {string} id The id of the filter to execute.
         * @param {any} [body] A JSON object which corresponds to the type of the saved query of the filter, i.e., if the resource type of the filter is Task the body should form a valid task query corresponding to the Task resource.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postExecuteFilterList(id: string, body?: any, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<any>>> {
            return FilterApiFp(configuration).postExecuteFilterList(id, body, firstResult, maxResults, options).then((request) => request(axios, basePath));
        },
        /**
         * Executes the saved query of the filter by id and returns the single result. This method is slightly more powerful then the [Get Execute Filter Single Result](https://docs.camunda.org/manual/7.18/reference/rest/filter/get-execute-single-result/) method because it allows to extend the saved query of the filter.
         * @summary Execute Filter Single Result (POST)
         * @param {string} id The id of the filter to execute.
         * @param {any} [body] A JSON object which corresponds to the type of the saved query of the filter, i.e., if the resource type of the filter is Task the body should form a valid task query corresponding to the Task resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postExecuteFilterSingleResult(id: string, body?: any, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return FilterApiFp(configuration).postExecuteFilterSingleResult(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing filter.
         * @summary Update Filter
         * @param {string} id The id of the filter to be updated.
         * @param {CreateFilterDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFilter(id: string, body?: CreateFilterDto, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return FilterApiFp(configuration).updateFilter(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilterApi - object-oriented interface
 * @export
 * @class FilterApi
 * @extends {BaseAPI}
 */
export class FilterApi extends BaseAPI {
    /**
     * Creates a new filter.
     * @summary Create Filter
     * @param {CreateFilterDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilterApi
     */
    public async createFilter(body?: CreateFilterDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<FilterDto>> {
        return FilterApiFp(this.configuration).createFilter(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes a filter by id.
     * @summary Delete Filter
     * @param {string} id The id of the filter to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilterApi
     */
    public async deleteFilter(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return FilterApiFp(this.configuration).deleteFilter(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Executes the saved query of the filter by id and returns the count.
     * @summary Execute Filter Count
     * @param {string} id The id of the filter to execute.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilterApi
     */
    public async executeFilterCount(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<CountResultDto>> {
        return FilterApiFp(this.configuration).executeFilterCount(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Executes the saved query of the filter by id and returns the result list.
     * @summary Execute Filter List
     * @param {string} id The id of the filter to execute.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilterApi
     */
    public async executeFilterList(id: string, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<any>>> {
        return FilterApiFp(this.configuration).executeFilterList(id, firstResult, maxResults, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Executes the saved query of the filter by id and returns the single result.
     * @summary Execute Filter Single Result
     * @param {string} id The id of the filter to execute.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilterApi
     */
    public async executeFilterSingleResult(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return FilterApiFp(this.configuration).executeFilterSingleResult(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * The OPTIONS request allows you to check for the set of available operations  that the currently authenticated user can perform on the `/filter` resource. Whether the user can perform an operation or not may depend on various factors, including the users authorizations to interact with this resource and the internal configuration of the process engine.
     * @summary Filter Resource Options
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilterApi
     */
    public async filterResourceOptions(options?: AxiosRequestConfig) : Promise<AxiosResponse<ResourceOptionsDto>> {
        return FilterApiFp(this.configuration).filterResourceOptions(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * The OPTIONS request allows you to check for the set of available operations  that the currently authenticated user can perform on the `/filter` resource. Whether the user can perform an operation or not may depend on various factors, including the users authorizations to interact with this resource and the internal configuration of the process engine.
     * @summary Filter Resource Options
     * @param {string} id The id of the filter to be checked.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilterApi
     */
    public async filterResourceOptionsSingle(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResourceOptionsDto>> {
        return FilterApiFp(this.configuration).filterResourceOptionsSingle(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the number of filters that fulfill a provided query. Corresponds to the size of the result set when using the  [Get Filters](https://docs.camunda.org/manual/7.18/reference/rest/filter/get-query/) method.
     * @summary Get Filter Count
     * @param {string} [filterId] Filter by the id of the filter.
     * @param {string} [resourceType] Filter by the resource type of the filter, e.g., &#x60;Task&#x60;.
     * @param {string} [name] Filter by the name of the filter.
     * @param {string} [nameLike] Filter by the name that the parameter is a substring of.
     * @param {string} [owner] Filter by the user id of the owner of the filter.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilterApi
     */
    public async getFilterCount(filterId?: string, resourceType?: string, name?: string, nameLike?: string, owner?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<CountResultDto>> {
        return FilterApiFp(this.configuration).getFilterCount(filterId, resourceType, name, nameLike, owner, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Queries for a list of filters using a list of parameters. The size of the result set can be retrieved by using the [Get Filter Count](https://docs.camunda.org/manual/7.18/reference/rest/filter/get-query-count/) method.
     * @summary Get Filters
     * @param {string} [filterId] Filter by the id of the filter.
     * @param {string} [resourceType] Filter by the resource type of the filter, e.g., &#x60;Task&#x60;.
     * @param {string} [name] Filter by the name of the filter.
     * @param {string} [nameLike] Filter by the name that the parameter is a substring of.
     * @param {string} [owner] Filter by the user id of the owner of the filter.
     * @param {boolean} [itemCount] If set to &#x60;true&#x60;, each filter result will contain an &#x60;itemCount&#x60; property with the number of items matched by the filter itself.
     * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilterApi
     */
    public async getFilterList(filterId?: string, resourceType?: string, name?: string, nameLike?: string, owner?: string, itemCount?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<FilterDto>>> {
        return FilterApiFp(this.configuration).getFilterList(filterId, resourceType, name, nameLike, owner, itemCount, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a single filter by id, according to the `Filter` interface in the engine.
     * @summary Get Single Filter
     * @param {string} id The id of the filter to be retrieved.
     * @param {boolean} [itemCount] If set to &#x60;true&#x60;, each filter result will contain an &#x60;itemCount&#x60; property with the number of items matched by the filter itself.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilterApi
     */
    public async getSingleFilter(id: string, itemCount?: boolean, options?: AxiosRequestConfig) : Promise<AxiosResponse<FilterDto>> {
        return FilterApiFp(this.configuration).getSingleFilter(id, itemCount, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Executes the saved query of the filter by id and returns the count. This method is slightly more powerful then the [Get Execute Filter Count](https://docs.camunda.org/manual/7.18/reference/rest/filter/get-execute-count/)  method because it allows to extend the saved query of the filter.
     * @summary Execute Filter Count (POST)
     * @param {string} id The id of the filter to execute.
     * @param {any} [body] A JSON object which corresponds to the type of the saved query of the filter, i.e., if the resource type of the filter is Task the body should form a valid task query corresponding to the Task resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilterApi
     */
    public async postExecuteFilterCount(id: string, body?: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<CountResultDto>> {
        return FilterApiFp(this.configuration).postExecuteFilterCount(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Executes the saved query of the filter by id and returns the result list. This method is slightly more powerful then the  [Get Execute FilterList](https://docs.camunda.org/manual/7.18/reference/rest/filter/get-execute-list/) method because it allows to extend the saved query of the filter.
     * @summary Execute Filter List (POST)
     * @param {string} id The id of the filter to execute.
     * @param {any} [body] A JSON object which corresponds to the type of the saved query of the filter, i.e., if the resource type of the filter is Task the body should form a valid task query corresponding to the Task resource.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilterApi
     */
    public async postExecuteFilterList(id: string, body?: any, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<any>>> {
        return FilterApiFp(this.configuration).postExecuteFilterList(id, body, firstResult, maxResults, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Executes the saved query of the filter by id and returns the single result. This method is slightly more powerful then the [Get Execute Filter Single Result](https://docs.camunda.org/manual/7.18/reference/rest/filter/get-execute-single-result/) method because it allows to extend the saved query of the filter.
     * @summary Execute Filter Single Result (POST)
     * @param {string} id The id of the filter to execute.
     * @param {any} [body] A JSON object which corresponds to the type of the saved query of the filter, i.e., if the resource type of the filter is Task the body should form a valid task query corresponding to the Task resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilterApi
     */
    public async postExecuteFilterSingleResult(id: string, body?: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return FilterApiFp(this.configuration).postExecuteFilterSingleResult(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates an existing filter.
     * @summary Update Filter
     * @param {string} id The id of the filter to be updated.
     * @param {CreateFilterDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilterApi
     */
    public async updateFilter(id: string, body?: CreateFilterDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return FilterApiFp(this.configuration).updateFilter(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}

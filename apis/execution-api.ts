/* tslint:disable */
/* eslint-disable */
/**
 * Camunda Platform REST API
 * OpenApi Spec for Camunda Platform REST API.
 *
 * OpenAPI spec version: 7.18.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { CountResultDto } from '../models';
import { CreateIncidentDto } from '../models';
import { EventSubscriptionDto } from '../models';
import { ExceptionDto } from '../models';
import { ExecutionDto } from '../models';
import { ExecutionQueryDto } from '../models';
import { ExecutionTriggerDto } from '../models';
import { IncidentDto } from '../models';
import { PatchVariablesDto } from '../models';
import { VariableValueDto } from '../models';
/**
 * ExecutionApi - axios parameter creator
 * @export
 */
export const ExecutionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a custom incident with given properties.
         * @summary Create Incident
         * @param {string} id The id of the execution to create a new incident for.
         * @param {CreateIncidentDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIncident: async (id: string, body?: CreateIncidentDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling createIncident.');
            }
            const localVarPath = `/execution/{id}/create-incident`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a variable in the context of a given execution by id. Deletion does not propagate upwards in the execution hierarchy.
         * @summary Delete Local Execution Variable
         * @param {string} id The id of the execution to delete the variable from.
         * @param {string} varName The name of the variable to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLocalExecutionVariable: async (id: string, varName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteLocalExecutionVariable.');
            }
            // verify required parameter 'varName' is not null or undefined
            if (varName === null || varName === undefined) {
                throw new RequiredError('varName','Required parameter varName was null or undefined when calling deleteLocalExecutionVariable.');
            }
            const localVarPath = `/execution/{id}/localVariables/{varName}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves an execution by id, according to the `Execution` interface in the engine.
         * @summary Get Execution
         * @param {string} id The id of the execution to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecution: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getExecution.');
            }
            const localVarPath = `/execution/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for the executions that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of executions. The size of the result set can be retrieved by using the [Get Execution Count](https://docs.camunda.org/manual/7.18/reference/rest/execution/get-query-count/) method.
         * @summary Get Executions
         * @param {string} [businessKey] Filter by the business key of the process instances the executions belong to.
         * @param {string} [processDefinitionId] Filter by the process definition the executions run on.
         * @param {string} [processDefinitionKey] Filter by the key of the process definition the executions run on.
         * @param {string} [processInstanceId] Filter by the id of the process instance the execution belongs to.
         * @param {string} [activityId] Filter by the id of the activity the execution currently executes.
         * @param {string} [signalEventSubscriptionName] Select only those executions that expect a signal of the given name.
         * @param {string} [messageEventSubscriptionName] Select only those executions that expect a message of the given name.
         * @param {boolean} [active] Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids.
         * @param {string} [variables] Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [processVariables] Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecutions: async (businessKey?: string, processDefinitionId?: string, processDefinitionKey?: string, processInstanceId?: string, activityId?: string, signalEventSubscriptionName?: string, messageEventSubscriptionName?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, variables?: string, processVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/execution`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (businessKey !== undefined) {
                localVarQueryParameter['businessKey'] = businessKey;
            }

            if (processDefinitionId !== undefined) {
                localVarQueryParameter['processDefinitionId'] = processDefinitionId;
            }

            if (processDefinitionKey !== undefined) {
                localVarQueryParameter['processDefinitionKey'] = processDefinitionKey;
            }

            if (processInstanceId !== undefined) {
                localVarQueryParameter['processInstanceId'] = processInstanceId;
            }

            if (activityId !== undefined) {
                localVarQueryParameter['activityId'] = activityId;
            }

            if (signalEventSubscriptionName !== undefined) {
                localVarQueryParameter['signalEventSubscriptionName'] = signalEventSubscriptionName;
            }

            if (messageEventSubscriptionName !== undefined) {
                localVarQueryParameter['messageEventSubscriptionName'] = messageEventSubscriptionName;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (suspended !== undefined) {
                localVarQueryParameter['suspended'] = suspended;
            }

            if (incidentId !== undefined) {
                localVarQueryParameter['incidentId'] = incidentId;
            }

            if (incidentType !== undefined) {
                localVarQueryParameter['incidentType'] = incidentType;
            }

            if (incidentMessage !== undefined) {
                localVarQueryParameter['incidentMessage'] = incidentMessage;
            }

            if (incidentMessageLike !== undefined) {
                localVarQueryParameter['incidentMessageLike'] = incidentMessageLike;
            }

            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }

            if (variables !== undefined) {
                localVarQueryParameter['variables'] = variables;
            }

            if (processVariables !== undefined) {
                localVarQueryParameter['processVariables'] = processVariables;
            }

            if (variableNamesIgnoreCase !== undefined) {
                localVarQueryParameter['variableNamesIgnoreCase'] = variableNamesIgnoreCase;
            }

            if (variableValuesIgnoreCase !== undefined) {
                localVarQueryParameter['variableValuesIgnoreCase'] = variableValuesIgnoreCase;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for the number of executions that fulfill given parameters. Takes the same parameters as the [Get Executions](https://docs.camunda.org/manual/7.18/reference/rest/execution/get-query/) method.
         * @summary Get Execution Count
         * @param {string} [businessKey] Filter by the business key of the process instances the executions belong to.
         * @param {string} [processDefinitionId] Filter by the process definition the executions run on.
         * @param {string} [processDefinitionKey] Filter by the key of the process definition the executions run on.
         * @param {string} [processInstanceId] Filter by the id of the process instance the execution belongs to.
         * @param {string} [activityId] Filter by the id of the activity the execution currently executes.
         * @param {string} [signalEventSubscriptionName] Select only those executions that expect a signal of the given name.
         * @param {string} [messageEventSubscriptionName] Select only those executions that expect a message of the given name.
         * @param {boolean} [active] Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids.
         * @param {string} [variables] Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [processVariables] Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecutionsCount: async (businessKey?: string, processDefinitionId?: string, processDefinitionKey?: string, processInstanceId?: string, activityId?: string, signalEventSubscriptionName?: string, messageEventSubscriptionName?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, variables?: string, processVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/execution/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (businessKey !== undefined) {
                localVarQueryParameter['businessKey'] = businessKey;
            }

            if (processDefinitionId !== undefined) {
                localVarQueryParameter['processDefinitionId'] = processDefinitionId;
            }

            if (processDefinitionKey !== undefined) {
                localVarQueryParameter['processDefinitionKey'] = processDefinitionKey;
            }

            if (processInstanceId !== undefined) {
                localVarQueryParameter['processInstanceId'] = processInstanceId;
            }

            if (activityId !== undefined) {
                localVarQueryParameter['activityId'] = activityId;
            }

            if (signalEventSubscriptionName !== undefined) {
                localVarQueryParameter['signalEventSubscriptionName'] = signalEventSubscriptionName;
            }

            if (messageEventSubscriptionName !== undefined) {
                localVarQueryParameter['messageEventSubscriptionName'] = messageEventSubscriptionName;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (suspended !== undefined) {
                localVarQueryParameter['suspended'] = suspended;
            }

            if (incidentId !== undefined) {
                localVarQueryParameter['incidentId'] = incidentId;
            }

            if (incidentType !== undefined) {
                localVarQueryParameter['incidentType'] = incidentType;
            }

            if (incidentMessage !== undefined) {
                localVarQueryParameter['incidentMessage'] = incidentMessage;
            }

            if (incidentMessageLike !== undefined) {
                localVarQueryParameter['incidentMessageLike'] = incidentMessageLike;
            }

            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }

            if (variables !== undefined) {
                localVarQueryParameter['variables'] = variables;
            }

            if (processVariables !== undefined) {
                localVarQueryParameter['processVariables'] = processVariables;
            }

            if (variableNamesIgnoreCase !== undefined) {
                localVarQueryParameter['variableNamesIgnoreCase'] = variableNamesIgnoreCase;
            }

            if (variableValuesIgnoreCase !== undefined) {
                localVarQueryParameter['variableValuesIgnoreCase'] = variableValuesIgnoreCase;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a variable from the context of a given execution by id. Does not traverse the parent execution hierarchy.
         * @summary Get Local Execution Variable
         * @param {string} id The id of the execution to retrieve the variable from.
         * @param {string} varName The name of the variable to get.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath. If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocalExecutionVariable: async (id: string, varName: string, deserializeValue?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getLocalExecutionVariable.');
            }
            // verify required parameter 'varName' is not null or undefined
            if (varName === null || varName === undefined) {
                throw new RequiredError('varName','Required parameter varName was null or undefined when calling getLocalExecutionVariable.');
            }
            const localVarPath = `/execution/{id}/localVariables/{varName}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (deserializeValue !== undefined) {
                localVarQueryParameter['deserializeValue'] = deserializeValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a binary variable from the context of a given execution by id. Does not traverse the parent execution hierarchy. Applicable for byte array and file variables.
         * @summary Get Local Execution Variable (Binary)
         * @param {string} id The id of the execution to retrieve the variable from.
         * @param {string} varName The name of the variable to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocalExecutionVariableBinary: async (id: string, varName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getLocalExecutionVariableBinary.');
            }
            // verify required parameter 'varName' is not null or undefined
            if (varName === null || varName === undefined) {
                throw new RequiredError('varName','Required parameter varName was null or undefined when calling getLocalExecutionVariableBinary.');
            }
            const localVarPath = `/execution/{id}/localVariables/{varName}/data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all variables of a given execution by id.
         * @summary Get Local Execution Variables
         * @param {string} id The id of the execution to retrieve the variables from.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocalExecutionVariables: async (id: string, deserializeValues?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getLocalExecutionVariables.');
            }
            const localVarPath = `/execution/{id}/localVariables`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (deserializeValues !== undefined) {
                localVarQueryParameter['deserializeValues'] = deserializeValues;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a message event subscription for a given execution by id and a message name.
         * @summary Get Message Event Subscription
         * @param {string} id The id of the execution that holds the subscription.
         * @param {string} messageName The name of the message that the subscription corresponds to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageEventSubscription: async (id: string, messageName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getMessageEventSubscription.');
            }
            // verify required parameter 'messageName' is not null or undefined
            if (messageName === null || messageName === undefined) {
                throw new RequiredError('messageName','Required parameter messageName was null or undefined when calling getMessageEventSubscription.');
            }
            const localVarPath = `/execution/{id}/messageSubscriptions/{messageName}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"messageName"}}`, encodeURIComponent(String(messageName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates or deletes the variables in the context of an execution by id. The updates do not propagate upwards in the execution hierarchy. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
         * @summary Update/Delete Local Execution Variables
         * @param {string} id The id of the execution to set variables for.
         * @param {PatchVariablesDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyLocalExecutionVariables: async (id: string, body?: PatchVariablesDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling modifyLocalExecutionVariables.');
            }
            const localVarPath = `/execution/{id}/localVariables`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets a variable in the context of a given execution by id. Update does not propagate upwards in the execution hierarchy.
         * @summary Put Local Execution Variable
         * @param {string} id The id of the execution to set the variable for.
         * @param {string} varName The name of the variable to set.
         * @param {VariableValueDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putLocalExecutionVariable: async (id: string, varName: string, body?: VariableValueDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling putLocalExecutionVariable.');
            }
            // verify required parameter 'varName' is not null or undefined
            if (varName === null || varName === undefined) {
                throw new RequiredError('varName','Required parameter varName was null or undefined when calling putLocalExecutionVariable.');
            }
            const localVarPath = `/execution/{id}/localVariables/{varName}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for executions that fulfill given parameters through a JSON object. This method is slightly more powerful than the [Get Executions](https://docs.camunda.org/manual/7.18/reference/rest/execution/get-query/) method because it allows to filter by multiple instance and execution variables of types `String`, `Number` or `Boolean`.
         * @summary Get Executions (POST)
         * @param {ExecutionQueryDto} [body] 
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryExecutions: async (body?: ExecutionQueryDto, firstResult?: number, maxResults?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/execution`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for the number of executions that fulfill given parameters. This method takes the same message body as the [Get Executions POST](https://docs.camunda.org/manual/7.18/reference/rest/execution/post-query/) method and therefore it is slightly more powerful than the [Get Execution Count](https://docs.camunda.org/manual/7.18/reference/rest/execution/get-query-count/) method.
         * @summary Get Execution Count (POST)
         * @param {ExecutionQueryDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryExecutionsCount: async (body?: ExecutionQueryDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/execution/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the serialized value for a binary variable or the binary value for a file variable in the context of a given execution by id.
         * @summary Post Local Execution Variable (Binary)
         * @param {string} id The id of the execution to set the variable for.
         * @param {string} varName The name of the variable to set.
         * @param {Blob} [data] 
         * @param {string} [valueType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setLocalExecutionVariableBinaryForm: async (id: string, varName: string, data?: Blob, valueType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling setLocalExecutionVariableBinaryForm.');
            }
            // verify required parameter 'varName' is not null or undefined
            if (varName === null || varName === undefined) {
                throw new RequiredError('varName','Required parameter varName was null or undefined when calling setLocalExecutionVariableBinaryForm.');
            }
            const localVarPath = `/execution/{id}/localVariables/{varName}/data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();


            if (data !== undefined) { 
                localVarFormParams.append('data', data as any);
            }

            if (valueType !== undefined) { 
                localVarFormParams.append('valueType', valueType as any);
            }

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Signals an execution by id. Can for example be used to explicitly skip user tasks or signal asynchronous continuations.
         * @summary Trigger Execution
         * @param {string} id The id of the execution to signal.
         * @param {ExecutionTriggerDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signalExecution: async (id: string, body?: ExecutionTriggerDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling signalExecution.');
            }
            const localVarPath = `/execution/{id}/signal`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Delivers a message to a specific execution by id, to trigger an existing message event subscription. Inject process variables as the message's payload.
         * @summary Trigger Message Event Subscription
         * @param {string} id The id of the execution to submit the message to.
         * @param {string} messageName The name of the message that the addressed subscription corresponds to.
         * @param {ExecutionTriggerDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerEvent: async (id: string, messageName: string, body?: ExecutionTriggerDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling triggerEvent.');
            }
            // verify required parameter 'messageName' is not null or undefined
            if (messageName === null || messageName === undefined) {
                throw new RequiredError('messageName','Required parameter messageName was null or undefined when calling triggerEvent.');
            }
            const localVarPath = `/execution/{id}/messageSubscriptions/{messageName}/trigger`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"messageName"}}`, encodeURIComponent(String(messageName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExecutionApi - functional programming interface
 * @export
 */
export const ExecutionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a custom incident with given properties.
         * @summary Create Incident
         * @param {string} id The id of the execution to create a new incident for.
         * @param {CreateIncidentDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createIncident(id: string, body?: CreateIncidentDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<IncidentDto>>> {
            const localVarAxiosArgs = await ExecutionApiAxiosParamCreator(configuration).createIncident(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes a variable in the context of a given execution by id. Deletion does not propagate upwards in the execution hierarchy.
         * @summary Delete Local Execution Variable
         * @param {string} id The id of the execution to delete the variable from.
         * @param {string} varName The name of the variable to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLocalExecutionVariable(id: string, varName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await ExecutionApiAxiosParamCreator(configuration).deleteLocalExecutionVariable(id, varName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves an execution by id, according to the `Execution` interface in the engine.
         * @summary Get Execution
         * @param {string} id The id of the execution to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExecution(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ExecutionDto>>> {
            const localVarAxiosArgs = await ExecutionApiAxiosParamCreator(configuration).getExecution(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Queries for the executions that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of executions. The size of the result set can be retrieved by using the [Get Execution Count](https://docs.camunda.org/manual/7.18/reference/rest/execution/get-query-count/) method.
         * @summary Get Executions
         * @param {string} [businessKey] Filter by the business key of the process instances the executions belong to.
         * @param {string} [processDefinitionId] Filter by the process definition the executions run on.
         * @param {string} [processDefinitionKey] Filter by the key of the process definition the executions run on.
         * @param {string} [processInstanceId] Filter by the id of the process instance the execution belongs to.
         * @param {string} [activityId] Filter by the id of the activity the execution currently executes.
         * @param {string} [signalEventSubscriptionName] Select only those executions that expect a signal of the given name.
         * @param {string} [messageEventSubscriptionName] Select only those executions that expect a message of the given name.
         * @param {boolean} [active] Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids.
         * @param {string} [variables] Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [processVariables] Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExecutions(businessKey?: string, processDefinitionId?: string, processDefinitionKey?: string, processInstanceId?: string, activityId?: string, signalEventSubscriptionName?: string, messageEventSubscriptionName?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, variables?: string, processVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<ExecutionDto>>>> {
            const localVarAxiosArgs = await ExecutionApiAxiosParamCreator(configuration).getExecutions(businessKey, processDefinitionId, processDefinitionKey, processInstanceId, activityId, signalEventSubscriptionName, messageEventSubscriptionName, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, variables, processVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, sortBy, sortOrder, firstResult, maxResults, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Queries for the number of executions that fulfill given parameters. Takes the same parameters as the [Get Executions](https://docs.camunda.org/manual/7.18/reference/rest/execution/get-query/) method.
         * @summary Get Execution Count
         * @param {string} [businessKey] Filter by the business key of the process instances the executions belong to.
         * @param {string} [processDefinitionId] Filter by the process definition the executions run on.
         * @param {string} [processDefinitionKey] Filter by the key of the process definition the executions run on.
         * @param {string} [processInstanceId] Filter by the id of the process instance the execution belongs to.
         * @param {string} [activityId] Filter by the id of the activity the execution currently executes.
         * @param {string} [signalEventSubscriptionName] Select only those executions that expect a signal of the given name.
         * @param {string} [messageEventSubscriptionName] Select only those executions that expect a message of the given name.
         * @param {boolean} [active] Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids.
         * @param {string} [variables] Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [processVariables] Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExecutionsCount(businessKey?: string, processDefinitionId?: string, processDefinitionKey?: string, processInstanceId?: string, activityId?: string, signalEventSubscriptionName?: string, messageEventSubscriptionName?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, variables?: string, processVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<CountResultDto>>> {
            const localVarAxiosArgs = await ExecutionApiAxiosParamCreator(configuration).getExecutionsCount(businessKey, processDefinitionId, processDefinitionKey, processInstanceId, activityId, signalEventSubscriptionName, messageEventSubscriptionName, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, variables, processVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves a variable from the context of a given execution by id. Does not traverse the parent execution hierarchy.
         * @summary Get Local Execution Variable
         * @param {string} id The id of the execution to retrieve the variable from.
         * @param {string} varName The name of the variable to get.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath. If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLocalExecutionVariable(id: string, varName: string, deserializeValue?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<VariableValueDto>>> {
            const localVarAxiosArgs = await ExecutionApiAxiosParamCreator(configuration).getLocalExecutionVariable(id, varName, deserializeValue, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves a binary variable from the context of a given execution by id. Does not traverse the parent execution hierarchy. Applicable for byte array and file variables.
         * @summary Get Local Execution Variable (Binary)
         * @param {string} id The id of the execution to retrieve the variable from.
         * @param {string} varName The name of the variable to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLocalExecutionVariableBinary(id: string, varName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Blob>>> {
            const localVarAxiosArgs = await ExecutionApiAxiosParamCreator(configuration).getLocalExecutionVariableBinary(id, varName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves all variables of a given execution by id.
         * @summary Get Local Execution Variables
         * @param {string} id The id of the execution to retrieve the variables from.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLocalExecutionVariables(id: string, deserializeValues?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<{ [key: string]: VariableValueDto; }>>> {
            const localVarAxiosArgs = await ExecutionApiAxiosParamCreator(configuration).getLocalExecutionVariables(id, deserializeValues, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves a message event subscription for a given execution by id and a message name.
         * @summary Get Message Event Subscription
         * @param {string} id The id of the execution that holds the subscription.
         * @param {string} messageName The name of the message that the subscription corresponds to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessageEventSubscription(id: string, messageName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<EventSubscriptionDto>>> {
            const localVarAxiosArgs = await ExecutionApiAxiosParamCreator(configuration).getMessageEventSubscription(id, messageName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates or deletes the variables in the context of an execution by id. The updates do not propagate upwards in the execution hierarchy. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
         * @summary Update/Delete Local Execution Variables
         * @param {string} id The id of the execution to set variables for.
         * @param {PatchVariablesDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyLocalExecutionVariables(id: string, body?: PatchVariablesDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await ExecutionApiAxiosParamCreator(configuration).modifyLocalExecutionVariables(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Sets a variable in the context of a given execution by id. Update does not propagate upwards in the execution hierarchy.
         * @summary Put Local Execution Variable
         * @param {string} id The id of the execution to set the variable for.
         * @param {string} varName The name of the variable to set.
         * @param {VariableValueDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putLocalExecutionVariable(id: string, varName: string, body?: VariableValueDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await ExecutionApiAxiosParamCreator(configuration).putLocalExecutionVariable(id, varName, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Queries for executions that fulfill given parameters through a JSON object. This method is slightly more powerful than the [Get Executions](https://docs.camunda.org/manual/7.18/reference/rest/execution/get-query/) method because it allows to filter by multiple instance and execution variables of types `String`, `Number` or `Boolean`.
         * @summary Get Executions (POST)
         * @param {ExecutionQueryDto} [body] 
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryExecutions(body?: ExecutionQueryDto, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<ExecutionDto>>>> {
            const localVarAxiosArgs = await ExecutionApiAxiosParamCreator(configuration).queryExecutions(body, firstResult, maxResults, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Queries for the number of executions that fulfill given parameters. This method takes the same message body as the [Get Executions POST](https://docs.camunda.org/manual/7.18/reference/rest/execution/post-query/) method and therefore it is slightly more powerful than the [Get Execution Count](https://docs.camunda.org/manual/7.18/reference/rest/execution/get-query-count/) method.
         * @summary Get Execution Count (POST)
         * @param {ExecutionQueryDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryExecutionsCount(body?: ExecutionQueryDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<CountResultDto>>> {
            const localVarAxiosArgs = await ExecutionApiAxiosParamCreator(configuration).queryExecutionsCount(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Sets the serialized value for a binary variable or the binary value for a file variable in the context of a given execution by id.
         * @summary Post Local Execution Variable (Binary)
         * @param {string} id The id of the execution to set the variable for.
         * @param {string} varName The name of the variable to set.
         * @param {Blob} [data] 
         * @param {string} [valueType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setLocalExecutionVariableBinaryForm(id: string, varName: string, data?: Blob, valueType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await ExecutionApiAxiosParamCreator(configuration).setLocalExecutionVariableBinaryForm(id, varName, data, valueType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Signals an execution by id. Can for example be used to explicitly skip user tasks or signal asynchronous continuations.
         * @summary Trigger Execution
         * @param {string} id The id of the execution to signal.
         * @param {ExecutionTriggerDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signalExecution(id: string, body?: ExecutionTriggerDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await ExecutionApiAxiosParamCreator(configuration).signalExecution(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delivers a message to a specific execution by id, to trigger an existing message event subscription. Inject process variables as the message's payload.
         * @summary Trigger Message Event Subscription
         * @param {string} id The id of the execution to submit the message to.
         * @param {string} messageName The name of the message that the addressed subscription corresponds to.
         * @param {ExecutionTriggerDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerEvent(id: string, messageName: string, body?: ExecutionTriggerDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await ExecutionApiAxiosParamCreator(configuration).triggerEvent(id, messageName, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ExecutionApi - factory interface
 * @export
 */
export const ExecutionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Creates a custom incident with given properties.
         * @summary Create Incident
         * @param {string} id The id of the execution to create a new incident for.
         * @param {CreateIncidentDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createIncident(id: string, body?: CreateIncidentDto, options?: AxiosRequestConfig): Promise<AxiosResponse<IncidentDto>> {
            return ExecutionApiFp(configuration).createIncident(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a variable in the context of a given execution by id. Deletion does not propagate upwards in the execution hierarchy.
         * @summary Delete Local Execution Variable
         * @param {string} id The id of the execution to delete the variable from.
         * @param {string} varName The name of the variable to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLocalExecutionVariable(id: string, varName: string, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return ExecutionApiFp(configuration).deleteLocalExecutionVariable(id, varName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves an execution by id, according to the `Execution` interface in the engine.
         * @summary Get Execution
         * @param {string} id The id of the execution to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExecution(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<ExecutionDto>> {
            return ExecutionApiFp(configuration).getExecution(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for the executions that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of executions. The size of the result set can be retrieved by using the [Get Execution Count](https://docs.camunda.org/manual/7.18/reference/rest/execution/get-query-count/) method.
         * @summary Get Executions
         * @param {string} [businessKey] Filter by the business key of the process instances the executions belong to.
         * @param {string} [processDefinitionId] Filter by the process definition the executions run on.
         * @param {string} [processDefinitionKey] Filter by the key of the process definition the executions run on.
         * @param {string} [processInstanceId] Filter by the id of the process instance the execution belongs to.
         * @param {string} [activityId] Filter by the id of the activity the execution currently executes.
         * @param {string} [signalEventSubscriptionName] Select only those executions that expect a signal of the given name.
         * @param {string} [messageEventSubscriptionName] Select only those executions that expect a message of the given name.
         * @param {boolean} [active] Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids.
         * @param {string} [variables] Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [processVariables] Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExecutions(businessKey?: string, processDefinitionId?: string, processDefinitionKey?: string, processInstanceId?: string, activityId?: string, signalEventSubscriptionName?: string, messageEventSubscriptionName?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, variables?: string, processVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<ExecutionDto>>> {
            return ExecutionApiFp(configuration).getExecutions(businessKey, processDefinitionId, processDefinitionKey, processInstanceId, activityId, signalEventSubscriptionName, messageEventSubscriptionName, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, variables, processVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for the number of executions that fulfill given parameters. Takes the same parameters as the [Get Executions](https://docs.camunda.org/manual/7.18/reference/rest/execution/get-query/) method.
         * @summary Get Execution Count
         * @param {string} [businessKey] Filter by the business key of the process instances the executions belong to.
         * @param {string} [processDefinitionId] Filter by the process definition the executions run on.
         * @param {string} [processDefinitionKey] Filter by the key of the process definition the executions run on.
         * @param {string} [processInstanceId] Filter by the id of the process instance the execution belongs to.
         * @param {string} [activityId] Filter by the id of the activity the execution currently executes.
         * @param {string} [signalEventSubscriptionName] Select only those executions that expect a signal of the given name.
         * @param {string} [messageEventSubscriptionName] Select only those executions that expect a message of the given name.
         * @param {boolean} [active] Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids.
         * @param {string} [variables] Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [processVariables] Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExecutionsCount(businessKey?: string, processDefinitionId?: string, processDefinitionKey?: string, processInstanceId?: string, activityId?: string, signalEventSubscriptionName?: string, messageEventSubscriptionName?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, variables?: string, processVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, options?: AxiosRequestConfig): Promise<AxiosResponse<CountResultDto>> {
            return ExecutionApiFp(configuration).getExecutionsCount(businessKey, processDefinitionId, processDefinitionKey, processInstanceId, activityId, signalEventSubscriptionName, messageEventSubscriptionName, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, variables, processVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a variable from the context of a given execution by id. Does not traverse the parent execution hierarchy.
         * @summary Get Local Execution Variable
         * @param {string} id The id of the execution to retrieve the variable from.
         * @param {string} varName The name of the variable to get.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath. If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLocalExecutionVariable(id: string, varName: string, deserializeValue?: boolean, options?: AxiosRequestConfig): Promise<AxiosResponse<VariableValueDto>> {
            return ExecutionApiFp(configuration).getLocalExecutionVariable(id, varName, deserializeValue, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a binary variable from the context of a given execution by id. Does not traverse the parent execution hierarchy. Applicable for byte array and file variables.
         * @summary Get Local Execution Variable (Binary)
         * @param {string} id The id of the execution to retrieve the variable from.
         * @param {string} varName The name of the variable to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLocalExecutionVariableBinary(id: string, varName: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Blob>> {
            return ExecutionApiFp(configuration).getLocalExecutionVariableBinary(id, varName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all variables of a given execution by id.
         * @summary Get Local Execution Variables
         * @param {string} id The id of the execution to retrieve the variables from.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLocalExecutionVariables(id: string, deserializeValues?: boolean, options?: AxiosRequestConfig): Promise<AxiosResponse<{ [key: string]: VariableValueDto; }>> {
            return ExecutionApiFp(configuration).getLocalExecutionVariables(id, deserializeValues, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a message event subscription for a given execution by id and a message name.
         * @summary Get Message Event Subscription
         * @param {string} id The id of the execution that holds the subscription.
         * @param {string} messageName The name of the message that the subscription corresponds to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessageEventSubscription(id: string, messageName: string, options?: AxiosRequestConfig): Promise<AxiosResponse<EventSubscriptionDto>> {
            return ExecutionApiFp(configuration).getMessageEventSubscription(id, messageName, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates or deletes the variables in the context of an execution by id. The updates do not propagate upwards in the execution hierarchy. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
         * @summary Update/Delete Local Execution Variables
         * @param {string} id The id of the execution to set variables for.
         * @param {PatchVariablesDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyLocalExecutionVariables(id: string, body?: PatchVariablesDto, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return ExecutionApiFp(configuration).modifyLocalExecutionVariables(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets a variable in the context of a given execution by id. Update does not propagate upwards in the execution hierarchy.
         * @summary Put Local Execution Variable
         * @param {string} id The id of the execution to set the variable for.
         * @param {string} varName The name of the variable to set.
         * @param {VariableValueDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putLocalExecutionVariable(id: string, varName: string, body?: VariableValueDto, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return ExecutionApiFp(configuration).putLocalExecutionVariable(id, varName, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for executions that fulfill given parameters through a JSON object. This method is slightly more powerful than the [Get Executions](https://docs.camunda.org/manual/7.18/reference/rest/execution/get-query/) method because it allows to filter by multiple instance and execution variables of types `String`, `Number` or `Boolean`.
         * @summary Get Executions (POST)
         * @param {ExecutionQueryDto} [body] 
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryExecutions(body?: ExecutionQueryDto, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<ExecutionDto>>> {
            return ExecutionApiFp(configuration).queryExecutions(body, firstResult, maxResults, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for the number of executions that fulfill given parameters. This method takes the same message body as the [Get Executions POST](https://docs.camunda.org/manual/7.18/reference/rest/execution/post-query/) method and therefore it is slightly more powerful than the [Get Execution Count](https://docs.camunda.org/manual/7.18/reference/rest/execution/get-query-count/) method.
         * @summary Get Execution Count (POST)
         * @param {ExecutionQueryDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryExecutionsCount(body?: ExecutionQueryDto, options?: AxiosRequestConfig): Promise<AxiosResponse<CountResultDto>> {
            return ExecutionApiFp(configuration).queryExecutionsCount(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the serialized value for a binary variable or the binary value for a file variable in the context of a given execution by id.
         * @summary Post Local Execution Variable (Binary)
         * @param {string} id The id of the execution to set the variable for.
         * @param {string} varName The name of the variable to set.
         * @param {Blob} [data] 
         * @param {string} [valueType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setLocalExecutionVariableBinaryForm(id: string, varName: string, data?: Blob, valueType?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return ExecutionApiFp(configuration).setLocalExecutionVariableBinaryForm(id, varName, data, valueType, options).then((request) => request(axios, basePath));
        },
        /**
         * Signals an execution by id. Can for example be used to explicitly skip user tasks or signal asynchronous continuations.
         * @summary Trigger Execution
         * @param {string} id The id of the execution to signal.
         * @param {ExecutionTriggerDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signalExecution(id: string, body?: ExecutionTriggerDto, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return ExecutionApiFp(configuration).signalExecution(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Delivers a message to a specific execution by id, to trigger an existing message event subscription. Inject process variables as the message's payload.
         * @summary Trigger Message Event Subscription
         * @param {string} id The id of the execution to submit the message to.
         * @param {string} messageName The name of the message that the addressed subscription corresponds to.
         * @param {ExecutionTriggerDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerEvent(id: string, messageName: string, body?: ExecutionTriggerDto, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return ExecutionApiFp(configuration).triggerEvent(id, messageName, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExecutionApi - object-oriented interface
 * @export
 * @class ExecutionApi
 * @extends {BaseAPI}
 */
export class ExecutionApi extends BaseAPI {
    /**
     * Creates a custom incident with given properties.
     * @summary Create Incident
     * @param {string} id The id of the execution to create a new incident for.
     * @param {CreateIncidentDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    public async createIncident(id: string, body?: CreateIncidentDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<IncidentDto>> {
        return ExecutionApiFp(this.configuration).createIncident(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes a variable in the context of a given execution by id. Deletion does not propagate upwards in the execution hierarchy.
     * @summary Delete Local Execution Variable
     * @param {string} id The id of the execution to delete the variable from.
     * @param {string} varName The name of the variable to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    public async deleteLocalExecutionVariable(id: string, varName: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return ExecutionApiFp(this.configuration).deleteLocalExecutionVariable(id, varName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves an execution by id, according to the `Execution` interface in the engine.
     * @summary Get Execution
     * @param {string} id The id of the execution to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    public async getExecution(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<ExecutionDto>> {
        return ExecutionApiFp(this.configuration).getExecution(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Queries for the executions that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of executions. The size of the result set can be retrieved by using the [Get Execution Count](https://docs.camunda.org/manual/7.18/reference/rest/execution/get-query-count/) method.
     * @summary Get Executions
     * @param {string} [businessKey] Filter by the business key of the process instances the executions belong to.
     * @param {string} [processDefinitionId] Filter by the process definition the executions run on.
     * @param {string} [processDefinitionKey] Filter by the key of the process definition the executions run on.
     * @param {string} [processInstanceId] Filter by the id of the process instance the execution belongs to.
     * @param {string} [activityId] Filter by the id of the activity the execution currently executes.
     * @param {string} [signalEventSubscriptionName] Select only those executions that expect a signal of the given name.
     * @param {string} [messageEventSubscriptionName] Select only those executions that expect a message of the given name.
     * @param {boolean} [active] Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [suspended] Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [incidentId] Filter by the incident id.
     * @param {string} [incidentType] Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param {string} [incidentMessage] Filter by the incident message. Exact match.
     * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
     * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids.
     * @param {string} [variables] Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {string} [processVariables] Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {boolean} [variableNamesIgnoreCase] Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal.
     * @param {boolean} [variableValuesIgnoreCase] Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal.
     * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    public async getExecutions(businessKey?: string, processDefinitionId?: string, processDefinitionKey?: string, processInstanceId?: string, activityId?: string, signalEventSubscriptionName?: string, messageEventSubscriptionName?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, variables?: string, processVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<ExecutionDto>>> {
        return ExecutionApiFp(this.configuration).getExecutions(businessKey, processDefinitionId, processDefinitionKey, processInstanceId, activityId, signalEventSubscriptionName, messageEventSubscriptionName, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, variables, processVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Queries for the number of executions that fulfill given parameters. Takes the same parameters as the [Get Executions](https://docs.camunda.org/manual/7.18/reference/rest/execution/get-query/) method.
     * @summary Get Execution Count
     * @param {string} [businessKey] Filter by the business key of the process instances the executions belong to.
     * @param {string} [processDefinitionId] Filter by the process definition the executions run on.
     * @param {string} [processDefinitionKey] Filter by the key of the process definition the executions run on.
     * @param {string} [processInstanceId] Filter by the id of the process instance the execution belongs to.
     * @param {string} [activityId] Filter by the id of the activity the execution currently executes.
     * @param {string} [signalEventSubscriptionName] Select only those executions that expect a signal of the given name.
     * @param {string} [messageEventSubscriptionName] Select only those executions that expect a message of the given name.
     * @param {boolean} [active] Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [suspended] Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [incidentId] Filter by the incident id.
     * @param {string} [incidentType] Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param {string} [incidentMessage] Filter by the incident message. Exact match.
     * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
     * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids.
     * @param {string} [variables] Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {string} [processVariables] Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {boolean} [variableNamesIgnoreCase] Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal.
     * @param {boolean} [variableValuesIgnoreCase] Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    public async getExecutionsCount(businessKey?: string, processDefinitionId?: string, processDefinitionKey?: string, processInstanceId?: string, activityId?: string, signalEventSubscriptionName?: string, messageEventSubscriptionName?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, variables?: string, processVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, options?: AxiosRequestConfig) : Promise<AxiosResponse<CountResultDto>> {
        return ExecutionApiFp(this.configuration).getExecutionsCount(businessKey, processDefinitionId, processDefinitionKey, processInstanceId, activityId, signalEventSubscriptionName, messageEventSubscriptionName, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, variables, processVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a variable from the context of a given execution by id. Does not traverse the parent execution hierarchy.
     * @summary Get Local Execution Variable
     * @param {string} id The id of the execution to retrieve the variable from.
     * @param {string} varName The name of the variable to get.
     * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath. If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    public async getLocalExecutionVariable(id: string, varName: string, deserializeValue?: boolean, options?: AxiosRequestConfig) : Promise<AxiosResponse<VariableValueDto>> {
        return ExecutionApiFp(this.configuration).getLocalExecutionVariable(id, varName, deserializeValue, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a binary variable from the context of a given execution by id. Does not traverse the parent execution hierarchy. Applicable for byte array and file variables.
     * @summary Get Local Execution Variable (Binary)
     * @param {string} id The id of the execution to retrieve the variable from.
     * @param {string} varName The name of the variable to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    public async getLocalExecutionVariableBinary(id: string, varName: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Blob>> {
        return ExecutionApiFp(this.configuration).getLocalExecutionVariableBinary(id, varName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves all variables of a given execution by id.
     * @summary Get Local Execution Variables
     * @param {string} id The id of the execution to retrieve the variables from.
     * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    public async getLocalExecutionVariables(id: string, deserializeValues?: boolean, options?: AxiosRequestConfig) : Promise<AxiosResponse<{ [key: string]: VariableValueDto; }>> {
        return ExecutionApiFp(this.configuration).getLocalExecutionVariables(id, deserializeValues, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a message event subscription for a given execution by id and a message name.
     * @summary Get Message Event Subscription
     * @param {string} id The id of the execution that holds the subscription.
     * @param {string} messageName The name of the message that the subscription corresponds to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    public async getMessageEventSubscription(id: string, messageName: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<EventSubscriptionDto>> {
        return ExecutionApiFp(this.configuration).getMessageEventSubscription(id, messageName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates or deletes the variables in the context of an execution by id. The updates do not propagate upwards in the execution hierarchy. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
     * @summary Update/Delete Local Execution Variables
     * @param {string} id The id of the execution to set variables for.
     * @param {PatchVariablesDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    public async modifyLocalExecutionVariables(id: string, body?: PatchVariablesDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return ExecutionApiFp(this.configuration).modifyLocalExecutionVariables(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sets a variable in the context of a given execution by id. Update does not propagate upwards in the execution hierarchy.
     * @summary Put Local Execution Variable
     * @param {string} id The id of the execution to set the variable for.
     * @param {string} varName The name of the variable to set.
     * @param {VariableValueDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    public async putLocalExecutionVariable(id: string, varName: string, body?: VariableValueDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return ExecutionApiFp(this.configuration).putLocalExecutionVariable(id, varName, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Queries for executions that fulfill given parameters through a JSON object. This method is slightly more powerful than the [Get Executions](https://docs.camunda.org/manual/7.18/reference/rest/execution/get-query/) method because it allows to filter by multiple instance and execution variables of types `String`, `Number` or `Boolean`.
     * @summary Get Executions (POST)
     * @param {ExecutionQueryDto} [body] 
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    public async queryExecutions(body?: ExecutionQueryDto, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<ExecutionDto>>> {
        return ExecutionApiFp(this.configuration).queryExecutions(body, firstResult, maxResults, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Queries for the number of executions that fulfill given parameters. This method takes the same message body as the [Get Executions POST](https://docs.camunda.org/manual/7.18/reference/rest/execution/post-query/) method and therefore it is slightly more powerful than the [Get Execution Count](https://docs.camunda.org/manual/7.18/reference/rest/execution/get-query-count/) method.
     * @summary Get Execution Count (POST)
     * @param {ExecutionQueryDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    public async queryExecutionsCount(body?: ExecutionQueryDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<CountResultDto>> {
        return ExecutionApiFp(this.configuration).queryExecutionsCount(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sets the serialized value for a binary variable or the binary value for a file variable in the context of a given execution by id.
     * @summary Post Local Execution Variable (Binary)
     * @param {string} id The id of the execution to set the variable for.
     * @param {string} varName The name of the variable to set.
     * @param {Blob} [data] 
     * @param {string} [valueType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    public async setLocalExecutionVariableBinaryForm(id: string, varName: string, data?: Blob, valueType?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return ExecutionApiFp(this.configuration).setLocalExecutionVariableBinaryForm(id, varName, data, valueType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Signals an execution by id. Can for example be used to explicitly skip user tasks or signal asynchronous continuations.
     * @summary Trigger Execution
     * @param {string} id The id of the execution to signal.
     * @param {ExecutionTriggerDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    public async signalExecution(id: string, body?: ExecutionTriggerDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return ExecutionApiFp(this.configuration).signalExecution(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delivers a message to a specific execution by id, to trigger an existing message event subscription. Inject process variables as the message's payload.
     * @summary Trigger Message Event Subscription
     * @param {string} id The id of the execution to submit the message to.
     * @param {string} messageName The name of the message that the addressed subscription corresponds to.
     * @param {ExecutionTriggerDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    public async triggerEvent(id: string, messageName: string, body?: ExecutionTriggerDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return ExecutionApiFp(this.configuration).triggerEvent(id, messageName, body, options).then((request) => request(this.axios, this.basePath));
    }
}

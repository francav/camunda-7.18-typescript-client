/* tslint:disable */
/* eslint-disable */
/**
 * Camunda Platform REST API
 * OpenApi Spec for Camunda Platform REST API.
 *
 * OpenAPI spec version: 7.18.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { AnnotationDto } from '../models';
import { CountResultDto } from '../models';
import { ExceptionDto } from '../models';
import { UserOperationLogEntryDto } from '../models';
/**
 * HistoricUserOperationLogApi - axios parameter creator
 * @export
 */
export const HistoricUserOperationLogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Clear the annotation which was previously set for auditing reasons.
         * @summary Clear Annotation of an User Operation Log (Historic)
         * @param {string} operationId The operation id of the operation log to be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearAnnotationUserOperationLog: async (operationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'operationId' is not null or undefined
            if (operationId === null || operationId === undefined) {
                throw new RequiredError('operationId','Required parameter operationId was null or undefined when calling clearAnnotationUserOperationLog.');
            }
            const localVarPath = `/history/user-operation/{operationId}/clear-annotation`
                .replace(`{${"operationId"}}`, encodeURIComponent(String(operationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for the number of user operation log entries that fulfill the given parameters. Takes the same parameters as the [Get User Operation Log (Historic)](https://docs.camunda.org/manual/7.18/reference/rest/history/user-operation-log/get-user-operation-log-query/) method.
         * @summary Get User Operation Log Count
         * @param {string} [deploymentId] Filter by deployment id.
         * @param {string} [processDefinitionId] Filter by process definition id.
         * @param {string} [processDefinitionKey] Filter by process definition key.
         * @param {string} [processInstanceId] Filter by process instance id.
         * @param {string} [executionId] Filter by execution id.
         * @param {string} [caseDefinitionId] Filter by case definition id.
         * @param {string} [caseInstanceId] Filter by case instance id.
         * @param {string} [caseExecutionId] Filter by case execution id.
         * @param {string} [taskId] Only include operations on this task.
         * @param {string} [externalTaskId] Only include operations on this external task.
         * @param {string} [batchId] Only include operations on this batch.
         * @param {string} [jobId] Filter by job id.
         * @param {string} [jobDefinitionId] Filter by job definition id.
         * @param {string} [userId] Only include operations of this user.
         * @param {string} [operationId] Filter by the id of the operation. This allows fetching of multiple entries which are part of a composite operation.
         * @param {string} [operationType] Filter by the type of the operation like &#x60;Claim&#x60; or &#x60;Delegate&#x60;. See the [Javadoc](https://docs.camunda.org/manual/7.18/reference/javadoc/?org/camunda/bpm/engine/history/UserOperationLogEntry.html) for a list of available operation types.
         * @param {string} [entityType] Filter by the type of the entity that was affected by this operation, possible values are &#x60;Task&#x60;, &#x60;Attachment&#x60; or &#x60;IdentityLink&#x60;.
         * @param {string} [entityTypeIn] Filter by a comma-separated list of types of the entities that was affected by this operation, possible values are &#x60;Task&#x60;, &#x60;Attachment&#x60; or &#x60;IdentityLink&#x60;.
         * @param {string} [category] Filter by the category that this operation is associated with, possible values are &#x60;TaskWorker&#x60;, &#x60;Admin&#x60; or &#x60;Operator&#x60;.
         * @param {string} [categoryIn] Filter by a comma-separated list of categories that this operation is associated with, possible values are &#x60;TaskWorker&#x60;, &#x60;Admin&#x60; or &#x60;Operator&#x60;.
         * @param {string} [property] Only include operations that changed this property, e.g., &#x60;owner&#x60; or &#x60;assignee&#x60;.
         * @param {Date} [afterTimestamp] Restrict to entries that were created after the given timestamp. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the timestamp must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., 2013-01-23T14:42:45.000+0200.
         * @param {Date} [beforeTimestamp] Restrict to entries that were created before the given timestamp. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the timestamp must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., 2013-01-23T14:42:45.000+0200.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryUserOperationCount: async (deploymentId?: string, processDefinitionId?: string, processDefinitionKey?: string, processInstanceId?: string, executionId?: string, caseDefinitionId?: string, caseInstanceId?: string, caseExecutionId?: string, taskId?: string, externalTaskId?: string, batchId?: string, jobId?: string, jobDefinitionId?: string, userId?: string, operationId?: string, operationType?: string, entityType?: string, entityTypeIn?: string, category?: string, categoryIn?: string, property?: string, afterTimestamp?: Date, beforeTimestamp?: Date, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/history/user-operation/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (deploymentId !== undefined) {
                localVarQueryParameter['deploymentId'] = deploymentId;
            }

            if (processDefinitionId !== undefined) {
                localVarQueryParameter['processDefinitionId'] = processDefinitionId;
            }

            if (processDefinitionKey !== undefined) {
                localVarQueryParameter['processDefinitionKey'] = processDefinitionKey;
            }

            if (processInstanceId !== undefined) {
                localVarQueryParameter['processInstanceId'] = processInstanceId;
            }

            if (executionId !== undefined) {
                localVarQueryParameter['executionId'] = executionId;
            }

            if (caseDefinitionId !== undefined) {
                localVarQueryParameter['caseDefinitionId'] = caseDefinitionId;
            }

            if (caseInstanceId !== undefined) {
                localVarQueryParameter['caseInstanceId'] = caseInstanceId;
            }

            if (caseExecutionId !== undefined) {
                localVarQueryParameter['caseExecutionId'] = caseExecutionId;
            }

            if (taskId !== undefined) {
                localVarQueryParameter['taskId'] = taskId;
            }

            if (externalTaskId !== undefined) {
                localVarQueryParameter['externalTaskId'] = externalTaskId;
            }

            if (batchId !== undefined) {
                localVarQueryParameter['batchId'] = batchId;
            }

            if (jobId !== undefined) {
                localVarQueryParameter['jobId'] = jobId;
            }

            if (jobDefinitionId !== undefined) {
                localVarQueryParameter['jobDefinitionId'] = jobDefinitionId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (operationId !== undefined) {
                localVarQueryParameter['operationId'] = operationId;
            }

            if (operationType !== undefined) {
                localVarQueryParameter['operationType'] = operationType;
            }

            if (entityType !== undefined) {
                localVarQueryParameter['entityType'] = entityType;
            }

            if (entityTypeIn !== undefined) {
                localVarQueryParameter['entityTypeIn'] = entityTypeIn;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (categoryIn !== undefined) {
                localVarQueryParameter['categoryIn'] = categoryIn;
            }

            if (property !== undefined) {
                localVarQueryParameter['property'] = property;
            }

            if (afterTimestamp !== undefined) {
                localVarQueryParameter['afterTimestamp'] = (afterTimestamp as any instanceof Date) ?
                    (afterTimestamp as any).toISOString() :
                    afterTimestamp;
            }

            if (beforeTimestamp !== undefined) {
                localVarQueryParameter['beforeTimestamp'] = (beforeTimestamp as any instanceof Date) ?
                    (beforeTimestamp as any).toISOString() :
                    beforeTimestamp;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for user operation log entries that fulfill the given parameters. The size of the result set can be retrieved by using the [Get User Operation Log Count](https://docs.camunda.org/manual/7.18/reference/rest/history/user-operation-log/get-user-operation-log-query-count/) method.  Note that the properties of operation log entries are interpreted as restrictions on the entities they apply to. That means, if a single process instance is updated, the field `processInstanceId` is populated. If a single operation updates all process instances of the same process definition, the field `processInstanceId` is `null` (a `null` restriction is viewed as a wildcard, i.e., matches a process instance with any id) and the field `processDefinitionId` is populated. This way, which entities were changed by a user operation can easily be reconstructed.
         * @summary Get User Operation Log (Historic)
         * @param {string} [deploymentId] Filter by deployment id.
         * @param {string} [processDefinitionId] Filter by process definition id.
         * @param {string} [processDefinitionKey] Filter by process definition key.
         * @param {string} [processInstanceId] Filter by process instance id.
         * @param {string} [executionId] Filter by execution id.
         * @param {string} [caseDefinitionId] Filter by case definition id.
         * @param {string} [caseInstanceId] Filter by case instance id.
         * @param {string} [caseExecutionId] Filter by case execution id.
         * @param {string} [taskId] Only include operations on this task.
         * @param {string} [externalTaskId] Only include operations on this external task.
         * @param {string} [batchId] Only include operations on this batch.
         * @param {string} [jobId] Filter by job id.
         * @param {string} [jobDefinitionId] Filter by job definition id.
         * @param {string} [userId] Only include operations of this user.
         * @param {string} [operationId] Filter by the id of the operation. This allows fetching of multiple entries which are part of a composite operation.
         * @param {string} [operationType] Filter by the type of the operation like &#x60;Claim&#x60; or &#x60;Delegate&#x60;. See the [Javadoc](https://docs.camunda.org/manual/7.18/reference/javadoc/?org/camunda/bpm/engine/history/UserOperationLogEntry.html) for a list of available operation types.
         * @param {string} [entityType] Filter by the type of the entity that was affected by this operation, possible values are &#x60;Task&#x60;, &#x60;Attachment&#x60; or &#x60;IdentityLink&#x60;.
         * @param {string} [entityTypeIn] Filter by a comma-separated list of types of the entities that was affected by this operation, possible values are &#x60;Task&#x60;, &#x60;Attachment&#x60; or &#x60;IdentityLink&#x60;.
         * @param {string} [category] Filter by the category that this operation is associated with, possible values are &#x60;TaskWorker&#x60;, &#x60;Admin&#x60; or &#x60;Operator&#x60;.
         * @param {string} [categoryIn] Filter by a comma-separated list of categories that this operation is associated with, possible values are &#x60;TaskWorker&#x60;, &#x60;Admin&#x60; or &#x60;Operator&#x60;.
         * @param {string} [property] Only include operations that changed this property, e.g., &#x60;owner&#x60; or &#x60;assignee&#x60;.
         * @param {Date} [afterTimestamp] Restrict to entries that were created after the given timestamp. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the timestamp must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., 2013-01-23T14:42:45.000+0200.
         * @param {Date} [beforeTimestamp] Restrict to entries that were created before the given timestamp. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the timestamp must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., 2013-01-23T14:42:45.000+0200.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryUserOperationEntries: async (deploymentId?: string, processDefinitionId?: string, processDefinitionKey?: string, processInstanceId?: string, executionId?: string, caseDefinitionId?: string, caseInstanceId?: string, caseExecutionId?: string, taskId?: string, externalTaskId?: string, batchId?: string, jobId?: string, jobDefinitionId?: string, userId?: string, operationId?: string, operationType?: string, entityType?: string, entityTypeIn?: string, category?: string, categoryIn?: string, property?: string, afterTimestamp?: Date, beforeTimestamp?: Date, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/history/user-operation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (deploymentId !== undefined) {
                localVarQueryParameter['deploymentId'] = deploymentId;
            }

            if (processDefinitionId !== undefined) {
                localVarQueryParameter['processDefinitionId'] = processDefinitionId;
            }

            if (processDefinitionKey !== undefined) {
                localVarQueryParameter['processDefinitionKey'] = processDefinitionKey;
            }

            if (processInstanceId !== undefined) {
                localVarQueryParameter['processInstanceId'] = processInstanceId;
            }

            if (executionId !== undefined) {
                localVarQueryParameter['executionId'] = executionId;
            }

            if (caseDefinitionId !== undefined) {
                localVarQueryParameter['caseDefinitionId'] = caseDefinitionId;
            }

            if (caseInstanceId !== undefined) {
                localVarQueryParameter['caseInstanceId'] = caseInstanceId;
            }

            if (caseExecutionId !== undefined) {
                localVarQueryParameter['caseExecutionId'] = caseExecutionId;
            }

            if (taskId !== undefined) {
                localVarQueryParameter['taskId'] = taskId;
            }

            if (externalTaskId !== undefined) {
                localVarQueryParameter['externalTaskId'] = externalTaskId;
            }

            if (batchId !== undefined) {
                localVarQueryParameter['batchId'] = batchId;
            }

            if (jobId !== undefined) {
                localVarQueryParameter['jobId'] = jobId;
            }

            if (jobDefinitionId !== undefined) {
                localVarQueryParameter['jobDefinitionId'] = jobDefinitionId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (operationId !== undefined) {
                localVarQueryParameter['operationId'] = operationId;
            }

            if (operationType !== undefined) {
                localVarQueryParameter['operationType'] = operationType;
            }

            if (entityType !== undefined) {
                localVarQueryParameter['entityType'] = entityType;
            }

            if (entityTypeIn !== undefined) {
                localVarQueryParameter['entityTypeIn'] = entityTypeIn;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (categoryIn !== undefined) {
                localVarQueryParameter['categoryIn'] = categoryIn;
            }

            if (property !== undefined) {
                localVarQueryParameter['property'] = property;
            }

            if (afterTimestamp !== undefined) {
                localVarQueryParameter['afterTimestamp'] = (afterTimestamp as any instanceof Date) ?
                    (afterTimestamp as any).toISOString() :
                    afterTimestamp;
            }

            if (beforeTimestamp !== undefined) {
                localVarQueryParameter['beforeTimestamp'] = (beforeTimestamp as any instanceof Date) ?
                    (beforeTimestamp as any).toISOString() :
                    beforeTimestamp;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Set an annotation for auditing reasons.
         * @summary Set Annotation to an User Operation Log (Historic)
         * @param {string} operationId The operation id of the operation log to be updated.
         * @param {AnnotationDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAnnotationUserOperationLog: async (operationId: string, body?: AnnotationDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'operationId' is not null or undefined
            if (operationId === null || operationId === undefined) {
                throw new RequiredError('operationId','Required parameter operationId was null or undefined when calling setAnnotationUserOperationLog.');
            }
            const localVarPath = `/history/user-operation/{operationId}/set-annotation`
                .replace(`{${"operationId"}}`, encodeURIComponent(String(operationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HistoricUserOperationLogApi - functional programming interface
 * @export
 */
export const HistoricUserOperationLogApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Clear the annotation which was previously set for auditing reasons.
         * @summary Clear Annotation of an User Operation Log (Historic)
         * @param {string} operationId The operation id of the operation log to be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clearAnnotationUserOperationLog(operationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await HistoricUserOperationLogApiAxiosParamCreator(configuration).clearAnnotationUserOperationLog(operationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Queries for the number of user operation log entries that fulfill the given parameters. Takes the same parameters as the [Get User Operation Log (Historic)](https://docs.camunda.org/manual/7.18/reference/rest/history/user-operation-log/get-user-operation-log-query/) method.
         * @summary Get User Operation Log Count
         * @param {string} [deploymentId] Filter by deployment id.
         * @param {string} [processDefinitionId] Filter by process definition id.
         * @param {string} [processDefinitionKey] Filter by process definition key.
         * @param {string} [processInstanceId] Filter by process instance id.
         * @param {string} [executionId] Filter by execution id.
         * @param {string} [caseDefinitionId] Filter by case definition id.
         * @param {string} [caseInstanceId] Filter by case instance id.
         * @param {string} [caseExecutionId] Filter by case execution id.
         * @param {string} [taskId] Only include operations on this task.
         * @param {string} [externalTaskId] Only include operations on this external task.
         * @param {string} [batchId] Only include operations on this batch.
         * @param {string} [jobId] Filter by job id.
         * @param {string} [jobDefinitionId] Filter by job definition id.
         * @param {string} [userId] Only include operations of this user.
         * @param {string} [operationId] Filter by the id of the operation. This allows fetching of multiple entries which are part of a composite operation.
         * @param {string} [operationType] Filter by the type of the operation like &#x60;Claim&#x60; or &#x60;Delegate&#x60;. See the [Javadoc](https://docs.camunda.org/manual/7.18/reference/javadoc/?org/camunda/bpm/engine/history/UserOperationLogEntry.html) for a list of available operation types.
         * @param {string} [entityType] Filter by the type of the entity that was affected by this operation, possible values are &#x60;Task&#x60;, &#x60;Attachment&#x60; or &#x60;IdentityLink&#x60;.
         * @param {string} [entityTypeIn] Filter by a comma-separated list of types of the entities that was affected by this operation, possible values are &#x60;Task&#x60;, &#x60;Attachment&#x60; or &#x60;IdentityLink&#x60;.
         * @param {string} [category] Filter by the category that this operation is associated with, possible values are &#x60;TaskWorker&#x60;, &#x60;Admin&#x60; or &#x60;Operator&#x60;.
         * @param {string} [categoryIn] Filter by a comma-separated list of categories that this operation is associated with, possible values are &#x60;TaskWorker&#x60;, &#x60;Admin&#x60; or &#x60;Operator&#x60;.
         * @param {string} [property] Only include operations that changed this property, e.g., &#x60;owner&#x60; or &#x60;assignee&#x60;.
         * @param {Date} [afterTimestamp] Restrict to entries that were created after the given timestamp. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the timestamp must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., 2013-01-23T14:42:45.000+0200.
         * @param {Date} [beforeTimestamp] Restrict to entries that were created before the given timestamp. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the timestamp must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., 2013-01-23T14:42:45.000+0200.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryUserOperationCount(deploymentId?: string, processDefinitionId?: string, processDefinitionKey?: string, processInstanceId?: string, executionId?: string, caseDefinitionId?: string, caseInstanceId?: string, caseExecutionId?: string, taskId?: string, externalTaskId?: string, batchId?: string, jobId?: string, jobDefinitionId?: string, userId?: string, operationId?: string, operationType?: string, entityType?: string, entityTypeIn?: string, category?: string, categoryIn?: string, property?: string, afterTimestamp?: Date, beforeTimestamp?: Date, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<CountResultDto>>> {
            const localVarAxiosArgs = await HistoricUserOperationLogApiAxiosParamCreator(configuration).queryUserOperationCount(deploymentId, processDefinitionId, processDefinitionKey, processInstanceId, executionId, caseDefinitionId, caseInstanceId, caseExecutionId, taskId, externalTaskId, batchId, jobId, jobDefinitionId, userId, operationId, operationType, entityType, entityTypeIn, category, categoryIn, property, afterTimestamp, beforeTimestamp, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Queries for user operation log entries that fulfill the given parameters. The size of the result set can be retrieved by using the [Get User Operation Log Count](https://docs.camunda.org/manual/7.18/reference/rest/history/user-operation-log/get-user-operation-log-query-count/) method.  Note that the properties of operation log entries are interpreted as restrictions on the entities they apply to. That means, if a single process instance is updated, the field `processInstanceId` is populated. If a single operation updates all process instances of the same process definition, the field `processInstanceId` is `null` (a `null` restriction is viewed as a wildcard, i.e., matches a process instance with any id) and the field `processDefinitionId` is populated. This way, which entities were changed by a user operation can easily be reconstructed.
         * @summary Get User Operation Log (Historic)
         * @param {string} [deploymentId] Filter by deployment id.
         * @param {string} [processDefinitionId] Filter by process definition id.
         * @param {string} [processDefinitionKey] Filter by process definition key.
         * @param {string} [processInstanceId] Filter by process instance id.
         * @param {string} [executionId] Filter by execution id.
         * @param {string} [caseDefinitionId] Filter by case definition id.
         * @param {string} [caseInstanceId] Filter by case instance id.
         * @param {string} [caseExecutionId] Filter by case execution id.
         * @param {string} [taskId] Only include operations on this task.
         * @param {string} [externalTaskId] Only include operations on this external task.
         * @param {string} [batchId] Only include operations on this batch.
         * @param {string} [jobId] Filter by job id.
         * @param {string} [jobDefinitionId] Filter by job definition id.
         * @param {string} [userId] Only include operations of this user.
         * @param {string} [operationId] Filter by the id of the operation. This allows fetching of multiple entries which are part of a composite operation.
         * @param {string} [operationType] Filter by the type of the operation like &#x60;Claim&#x60; or &#x60;Delegate&#x60;. See the [Javadoc](https://docs.camunda.org/manual/7.18/reference/javadoc/?org/camunda/bpm/engine/history/UserOperationLogEntry.html) for a list of available operation types.
         * @param {string} [entityType] Filter by the type of the entity that was affected by this operation, possible values are &#x60;Task&#x60;, &#x60;Attachment&#x60; or &#x60;IdentityLink&#x60;.
         * @param {string} [entityTypeIn] Filter by a comma-separated list of types of the entities that was affected by this operation, possible values are &#x60;Task&#x60;, &#x60;Attachment&#x60; or &#x60;IdentityLink&#x60;.
         * @param {string} [category] Filter by the category that this operation is associated with, possible values are &#x60;TaskWorker&#x60;, &#x60;Admin&#x60; or &#x60;Operator&#x60;.
         * @param {string} [categoryIn] Filter by a comma-separated list of categories that this operation is associated with, possible values are &#x60;TaskWorker&#x60;, &#x60;Admin&#x60; or &#x60;Operator&#x60;.
         * @param {string} [property] Only include operations that changed this property, e.g., &#x60;owner&#x60; or &#x60;assignee&#x60;.
         * @param {Date} [afterTimestamp] Restrict to entries that were created after the given timestamp. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the timestamp must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., 2013-01-23T14:42:45.000+0200.
         * @param {Date} [beforeTimestamp] Restrict to entries that were created before the given timestamp. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the timestamp must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., 2013-01-23T14:42:45.000+0200.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryUserOperationEntries(deploymentId?: string, processDefinitionId?: string, processDefinitionKey?: string, processInstanceId?: string, executionId?: string, caseDefinitionId?: string, caseInstanceId?: string, caseExecutionId?: string, taskId?: string, externalTaskId?: string, batchId?: string, jobId?: string, jobDefinitionId?: string, userId?: string, operationId?: string, operationType?: string, entityType?: string, entityTypeIn?: string, category?: string, categoryIn?: string, property?: string, afterTimestamp?: Date, beforeTimestamp?: Date, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<UserOperationLogEntryDto>>>> {
            const localVarAxiosArgs = await HistoricUserOperationLogApiAxiosParamCreator(configuration).queryUserOperationEntries(deploymentId, processDefinitionId, processDefinitionKey, processInstanceId, executionId, caseDefinitionId, caseInstanceId, caseExecutionId, taskId, externalTaskId, batchId, jobId, jobDefinitionId, userId, operationId, operationType, entityType, entityTypeIn, category, categoryIn, property, afterTimestamp, beforeTimestamp, sortBy, sortOrder, firstResult, maxResults, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Set an annotation for auditing reasons.
         * @summary Set Annotation to an User Operation Log (Historic)
         * @param {string} operationId The operation id of the operation log to be updated.
         * @param {AnnotationDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setAnnotationUserOperationLog(operationId: string, body?: AnnotationDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await HistoricUserOperationLogApiAxiosParamCreator(configuration).setAnnotationUserOperationLog(operationId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * HistoricUserOperationLogApi - factory interface
 * @export
 */
export const HistoricUserOperationLogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Clear the annotation which was previously set for auditing reasons.
         * @summary Clear Annotation of an User Operation Log (Historic)
         * @param {string} operationId The operation id of the operation log to be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clearAnnotationUserOperationLog(operationId: string, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return HistoricUserOperationLogApiFp(configuration).clearAnnotationUserOperationLog(operationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for the number of user operation log entries that fulfill the given parameters. Takes the same parameters as the [Get User Operation Log (Historic)](https://docs.camunda.org/manual/7.18/reference/rest/history/user-operation-log/get-user-operation-log-query/) method.
         * @summary Get User Operation Log Count
         * @param {string} [deploymentId] Filter by deployment id.
         * @param {string} [processDefinitionId] Filter by process definition id.
         * @param {string} [processDefinitionKey] Filter by process definition key.
         * @param {string} [processInstanceId] Filter by process instance id.
         * @param {string} [executionId] Filter by execution id.
         * @param {string} [caseDefinitionId] Filter by case definition id.
         * @param {string} [caseInstanceId] Filter by case instance id.
         * @param {string} [caseExecutionId] Filter by case execution id.
         * @param {string} [taskId] Only include operations on this task.
         * @param {string} [externalTaskId] Only include operations on this external task.
         * @param {string} [batchId] Only include operations on this batch.
         * @param {string} [jobId] Filter by job id.
         * @param {string} [jobDefinitionId] Filter by job definition id.
         * @param {string} [userId] Only include operations of this user.
         * @param {string} [operationId] Filter by the id of the operation. This allows fetching of multiple entries which are part of a composite operation.
         * @param {string} [operationType] Filter by the type of the operation like &#x60;Claim&#x60; or &#x60;Delegate&#x60;. See the [Javadoc](https://docs.camunda.org/manual/7.18/reference/javadoc/?org/camunda/bpm/engine/history/UserOperationLogEntry.html) for a list of available operation types.
         * @param {string} [entityType] Filter by the type of the entity that was affected by this operation, possible values are &#x60;Task&#x60;, &#x60;Attachment&#x60; or &#x60;IdentityLink&#x60;.
         * @param {string} [entityTypeIn] Filter by a comma-separated list of types of the entities that was affected by this operation, possible values are &#x60;Task&#x60;, &#x60;Attachment&#x60; or &#x60;IdentityLink&#x60;.
         * @param {string} [category] Filter by the category that this operation is associated with, possible values are &#x60;TaskWorker&#x60;, &#x60;Admin&#x60; or &#x60;Operator&#x60;.
         * @param {string} [categoryIn] Filter by a comma-separated list of categories that this operation is associated with, possible values are &#x60;TaskWorker&#x60;, &#x60;Admin&#x60; or &#x60;Operator&#x60;.
         * @param {string} [property] Only include operations that changed this property, e.g., &#x60;owner&#x60; or &#x60;assignee&#x60;.
         * @param {Date} [afterTimestamp] Restrict to entries that were created after the given timestamp. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the timestamp must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., 2013-01-23T14:42:45.000+0200.
         * @param {Date} [beforeTimestamp] Restrict to entries that were created before the given timestamp. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the timestamp must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., 2013-01-23T14:42:45.000+0200.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryUserOperationCount(deploymentId?: string, processDefinitionId?: string, processDefinitionKey?: string, processInstanceId?: string, executionId?: string, caseDefinitionId?: string, caseInstanceId?: string, caseExecutionId?: string, taskId?: string, externalTaskId?: string, batchId?: string, jobId?: string, jobDefinitionId?: string, userId?: string, operationId?: string, operationType?: string, entityType?: string, entityTypeIn?: string, category?: string, categoryIn?: string, property?: string, afterTimestamp?: Date, beforeTimestamp?: Date, options?: AxiosRequestConfig): Promise<AxiosResponse<CountResultDto>> {
            return HistoricUserOperationLogApiFp(configuration).queryUserOperationCount(deploymentId, processDefinitionId, processDefinitionKey, processInstanceId, executionId, caseDefinitionId, caseInstanceId, caseExecutionId, taskId, externalTaskId, batchId, jobId, jobDefinitionId, userId, operationId, operationType, entityType, entityTypeIn, category, categoryIn, property, afterTimestamp, beforeTimestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for user operation log entries that fulfill the given parameters. The size of the result set can be retrieved by using the [Get User Operation Log Count](https://docs.camunda.org/manual/7.18/reference/rest/history/user-operation-log/get-user-operation-log-query-count/) method.  Note that the properties of operation log entries are interpreted as restrictions on the entities they apply to. That means, if a single process instance is updated, the field `processInstanceId` is populated. If a single operation updates all process instances of the same process definition, the field `processInstanceId` is `null` (a `null` restriction is viewed as a wildcard, i.e., matches a process instance with any id) and the field `processDefinitionId` is populated. This way, which entities were changed by a user operation can easily be reconstructed.
         * @summary Get User Operation Log (Historic)
         * @param {string} [deploymentId] Filter by deployment id.
         * @param {string} [processDefinitionId] Filter by process definition id.
         * @param {string} [processDefinitionKey] Filter by process definition key.
         * @param {string} [processInstanceId] Filter by process instance id.
         * @param {string} [executionId] Filter by execution id.
         * @param {string} [caseDefinitionId] Filter by case definition id.
         * @param {string} [caseInstanceId] Filter by case instance id.
         * @param {string} [caseExecutionId] Filter by case execution id.
         * @param {string} [taskId] Only include operations on this task.
         * @param {string} [externalTaskId] Only include operations on this external task.
         * @param {string} [batchId] Only include operations on this batch.
         * @param {string} [jobId] Filter by job id.
         * @param {string} [jobDefinitionId] Filter by job definition id.
         * @param {string} [userId] Only include operations of this user.
         * @param {string} [operationId] Filter by the id of the operation. This allows fetching of multiple entries which are part of a composite operation.
         * @param {string} [operationType] Filter by the type of the operation like &#x60;Claim&#x60; or &#x60;Delegate&#x60;. See the [Javadoc](https://docs.camunda.org/manual/7.18/reference/javadoc/?org/camunda/bpm/engine/history/UserOperationLogEntry.html) for a list of available operation types.
         * @param {string} [entityType] Filter by the type of the entity that was affected by this operation, possible values are &#x60;Task&#x60;, &#x60;Attachment&#x60; or &#x60;IdentityLink&#x60;.
         * @param {string} [entityTypeIn] Filter by a comma-separated list of types of the entities that was affected by this operation, possible values are &#x60;Task&#x60;, &#x60;Attachment&#x60; or &#x60;IdentityLink&#x60;.
         * @param {string} [category] Filter by the category that this operation is associated with, possible values are &#x60;TaskWorker&#x60;, &#x60;Admin&#x60; or &#x60;Operator&#x60;.
         * @param {string} [categoryIn] Filter by a comma-separated list of categories that this operation is associated with, possible values are &#x60;TaskWorker&#x60;, &#x60;Admin&#x60; or &#x60;Operator&#x60;.
         * @param {string} [property] Only include operations that changed this property, e.g., &#x60;owner&#x60; or &#x60;assignee&#x60;.
         * @param {Date} [afterTimestamp] Restrict to entries that were created after the given timestamp. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the timestamp must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., 2013-01-23T14:42:45.000+0200.
         * @param {Date} [beforeTimestamp] Restrict to entries that were created before the given timestamp. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the timestamp must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., 2013-01-23T14:42:45.000+0200.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryUserOperationEntries(deploymentId?: string, processDefinitionId?: string, processDefinitionKey?: string, processInstanceId?: string, executionId?: string, caseDefinitionId?: string, caseInstanceId?: string, caseExecutionId?: string, taskId?: string, externalTaskId?: string, batchId?: string, jobId?: string, jobDefinitionId?: string, userId?: string, operationId?: string, operationType?: string, entityType?: string, entityTypeIn?: string, category?: string, categoryIn?: string, property?: string, afterTimestamp?: Date, beforeTimestamp?: Date, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<UserOperationLogEntryDto>>> {
            return HistoricUserOperationLogApiFp(configuration).queryUserOperationEntries(deploymentId, processDefinitionId, processDefinitionKey, processInstanceId, executionId, caseDefinitionId, caseInstanceId, caseExecutionId, taskId, externalTaskId, batchId, jobId, jobDefinitionId, userId, operationId, operationType, entityType, entityTypeIn, category, categoryIn, property, afterTimestamp, beforeTimestamp, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(axios, basePath));
        },
        /**
         * Set an annotation for auditing reasons.
         * @summary Set Annotation to an User Operation Log (Historic)
         * @param {string} operationId The operation id of the operation log to be updated.
         * @param {AnnotationDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setAnnotationUserOperationLog(operationId: string, body?: AnnotationDto, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return HistoricUserOperationLogApiFp(configuration).setAnnotationUserOperationLog(operationId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HistoricUserOperationLogApi - object-oriented interface
 * @export
 * @class HistoricUserOperationLogApi
 * @extends {BaseAPI}
 */
export class HistoricUserOperationLogApi extends BaseAPI {
    /**
     * Clear the annotation which was previously set for auditing reasons.
     * @summary Clear Annotation of an User Operation Log (Historic)
     * @param {string} operationId The operation id of the operation log to be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoricUserOperationLogApi
     */
    public async clearAnnotationUserOperationLog(operationId: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return HistoricUserOperationLogApiFp(this.configuration).clearAnnotationUserOperationLog(operationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Queries for the number of user operation log entries that fulfill the given parameters. Takes the same parameters as the [Get User Operation Log (Historic)](https://docs.camunda.org/manual/7.18/reference/rest/history/user-operation-log/get-user-operation-log-query/) method.
     * @summary Get User Operation Log Count
     * @param {string} [deploymentId] Filter by deployment id.
     * @param {string} [processDefinitionId] Filter by process definition id.
     * @param {string} [processDefinitionKey] Filter by process definition key.
     * @param {string} [processInstanceId] Filter by process instance id.
     * @param {string} [executionId] Filter by execution id.
     * @param {string} [caseDefinitionId] Filter by case definition id.
     * @param {string} [caseInstanceId] Filter by case instance id.
     * @param {string} [caseExecutionId] Filter by case execution id.
     * @param {string} [taskId] Only include operations on this task.
     * @param {string} [externalTaskId] Only include operations on this external task.
     * @param {string} [batchId] Only include operations on this batch.
     * @param {string} [jobId] Filter by job id.
     * @param {string} [jobDefinitionId] Filter by job definition id.
     * @param {string} [userId] Only include operations of this user.
     * @param {string} [operationId] Filter by the id of the operation. This allows fetching of multiple entries which are part of a composite operation.
     * @param {string} [operationType] Filter by the type of the operation like &#x60;Claim&#x60; or &#x60;Delegate&#x60;. See the [Javadoc](https://docs.camunda.org/manual/7.18/reference/javadoc/?org/camunda/bpm/engine/history/UserOperationLogEntry.html) for a list of available operation types.
     * @param {string} [entityType] Filter by the type of the entity that was affected by this operation, possible values are &#x60;Task&#x60;, &#x60;Attachment&#x60; or &#x60;IdentityLink&#x60;.
     * @param {string} [entityTypeIn] Filter by a comma-separated list of types of the entities that was affected by this operation, possible values are &#x60;Task&#x60;, &#x60;Attachment&#x60; or &#x60;IdentityLink&#x60;.
     * @param {string} [category] Filter by the category that this operation is associated with, possible values are &#x60;TaskWorker&#x60;, &#x60;Admin&#x60; or &#x60;Operator&#x60;.
     * @param {string} [categoryIn] Filter by a comma-separated list of categories that this operation is associated with, possible values are &#x60;TaskWorker&#x60;, &#x60;Admin&#x60; or &#x60;Operator&#x60;.
     * @param {string} [property] Only include operations that changed this property, e.g., &#x60;owner&#x60; or &#x60;assignee&#x60;.
     * @param {Date} [afterTimestamp] Restrict to entries that were created after the given timestamp. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the timestamp must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., 2013-01-23T14:42:45.000+0200.
     * @param {Date} [beforeTimestamp] Restrict to entries that were created before the given timestamp. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the timestamp must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., 2013-01-23T14:42:45.000+0200.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoricUserOperationLogApi
     */
    public async queryUserOperationCount(deploymentId?: string, processDefinitionId?: string, processDefinitionKey?: string, processInstanceId?: string, executionId?: string, caseDefinitionId?: string, caseInstanceId?: string, caseExecutionId?: string, taskId?: string, externalTaskId?: string, batchId?: string, jobId?: string, jobDefinitionId?: string, userId?: string, operationId?: string, operationType?: string, entityType?: string, entityTypeIn?: string, category?: string, categoryIn?: string, property?: string, afterTimestamp?: Date, beforeTimestamp?: Date, options?: AxiosRequestConfig) : Promise<AxiosResponse<CountResultDto>> {
        return HistoricUserOperationLogApiFp(this.configuration).queryUserOperationCount(deploymentId, processDefinitionId, processDefinitionKey, processInstanceId, executionId, caseDefinitionId, caseInstanceId, caseExecutionId, taskId, externalTaskId, batchId, jobId, jobDefinitionId, userId, operationId, operationType, entityType, entityTypeIn, category, categoryIn, property, afterTimestamp, beforeTimestamp, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Queries for user operation log entries that fulfill the given parameters. The size of the result set can be retrieved by using the [Get User Operation Log Count](https://docs.camunda.org/manual/7.18/reference/rest/history/user-operation-log/get-user-operation-log-query-count/) method.  Note that the properties of operation log entries are interpreted as restrictions on the entities they apply to. That means, if a single process instance is updated, the field `processInstanceId` is populated. If a single operation updates all process instances of the same process definition, the field `processInstanceId` is `null` (a `null` restriction is viewed as a wildcard, i.e., matches a process instance with any id) and the field `processDefinitionId` is populated. This way, which entities were changed by a user operation can easily be reconstructed.
     * @summary Get User Operation Log (Historic)
     * @param {string} [deploymentId] Filter by deployment id.
     * @param {string} [processDefinitionId] Filter by process definition id.
     * @param {string} [processDefinitionKey] Filter by process definition key.
     * @param {string} [processInstanceId] Filter by process instance id.
     * @param {string} [executionId] Filter by execution id.
     * @param {string} [caseDefinitionId] Filter by case definition id.
     * @param {string} [caseInstanceId] Filter by case instance id.
     * @param {string} [caseExecutionId] Filter by case execution id.
     * @param {string} [taskId] Only include operations on this task.
     * @param {string} [externalTaskId] Only include operations on this external task.
     * @param {string} [batchId] Only include operations on this batch.
     * @param {string} [jobId] Filter by job id.
     * @param {string} [jobDefinitionId] Filter by job definition id.
     * @param {string} [userId] Only include operations of this user.
     * @param {string} [operationId] Filter by the id of the operation. This allows fetching of multiple entries which are part of a composite operation.
     * @param {string} [operationType] Filter by the type of the operation like &#x60;Claim&#x60; or &#x60;Delegate&#x60;. See the [Javadoc](https://docs.camunda.org/manual/7.18/reference/javadoc/?org/camunda/bpm/engine/history/UserOperationLogEntry.html) for a list of available operation types.
     * @param {string} [entityType] Filter by the type of the entity that was affected by this operation, possible values are &#x60;Task&#x60;, &#x60;Attachment&#x60; or &#x60;IdentityLink&#x60;.
     * @param {string} [entityTypeIn] Filter by a comma-separated list of types of the entities that was affected by this operation, possible values are &#x60;Task&#x60;, &#x60;Attachment&#x60; or &#x60;IdentityLink&#x60;.
     * @param {string} [category] Filter by the category that this operation is associated with, possible values are &#x60;TaskWorker&#x60;, &#x60;Admin&#x60; or &#x60;Operator&#x60;.
     * @param {string} [categoryIn] Filter by a comma-separated list of categories that this operation is associated with, possible values are &#x60;TaskWorker&#x60;, &#x60;Admin&#x60; or &#x60;Operator&#x60;.
     * @param {string} [property] Only include operations that changed this property, e.g., &#x60;owner&#x60; or &#x60;assignee&#x60;.
     * @param {Date} [afterTimestamp] Restrict to entries that were created after the given timestamp. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the timestamp must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., 2013-01-23T14:42:45.000+0200.
     * @param {Date} [beforeTimestamp] Restrict to entries that were created before the given timestamp. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the timestamp must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., 2013-01-23T14:42:45.000+0200.
     * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoricUserOperationLogApi
     */
    public async queryUserOperationEntries(deploymentId?: string, processDefinitionId?: string, processDefinitionKey?: string, processInstanceId?: string, executionId?: string, caseDefinitionId?: string, caseInstanceId?: string, caseExecutionId?: string, taskId?: string, externalTaskId?: string, batchId?: string, jobId?: string, jobDefinitionId?: string, userId?: string, operationId?: string, operationType?: string, entityType?: string, entityTypeIn?: string, category?: string, categoryIn?: string, property?: string, afterTimestamp?: Date, beforeTimestamp?: Date, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<UserOperationLogEntryDto>>> {
        return HistoricUserOperationLogApiFp(this.configuration).queryUserOperationEntries(deploymentId, processDefinitionId, processDefinitionKey, processInstanceId, executionId, caseDefinitionId, caseInstanceId, caseExecutionId, taskId, externalTaskId, batchId, jobId, jobDefinitionId, userId, operationId, operationType, entityType, entityTypeIn, category, categoryIn, property, afterTimestamp, beforeTimestamp, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Set an annotation for auditing reasons.
     * @summary Set Annotation to an User Operation Log (Historic)
     * @param {string} operationId The operation id of the operation log to be updated.
     * @param {AnnotationDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoricUserOperationLogApi
     */
    public async setAnnotationUserOperationLog(operationId: string, body?: AnnotationDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return HistoricUserOperationLogApiFp(this.configuration).setAnnotationUserOperationLog(operationId, body, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Camunda Platform REST API
 * OpenApi Spec for Camunda Platform REST API.
 *
 * OpenAPI spec version: 7.18.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { ActivityStatisticsResultDto } from '../models';
import { AuthorizationExceptionDto } from '../models';
import { BatchDto } from '../models';
import { CalledProcessDefinitionDto } from '../models';
import { CountResultDto } from '../models';
import { ExceptionDto } from '../models';
import { FormDto } from '../models';
import { HistoryTimeToLiveDto } from '../models';
import { ProcessDefinitionDiagramDto } from '../models';
import { ProcessDefinitionDto } from '../models';
import { ProcessDefinitionStatisticsResultDto } from '../models';
import { ProcessDefinitionSuspensionStateDto } from '../models';
import { ProcessInstanceDto } from '../models';
import { ProcessInstanceWithVariablesDto } from '../models';
import { RestartProcessInstanceDto } from '../models';
import { StartProcessInstanceDto } from '../models';
import { StartProcessInstanceFormDto } from '../models';
import { VariableValueDto } from '../models';
/**
 * ProcessDefinitionApi - axios parameter creator
 * @export
 */
export const ProcessDefinitionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a running process instance by id.
         * @summary Delete
         * @param {string} id The id of the process definition to be deleted.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessDefinition: async (id: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteProcessDefinition.');
            }
            const localVarPath = `/process-definition/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cascade !== undefined) {
                localVarQueryParameter['cascade'] = cascade;
            }

            if (skipCustomListeners !== undefined) {
                localVarQueryParameter['skipCustomListeners'] = skipCustomListeners;
            }

            if (skipIoMappings !== undefined) {
                localVarQueryParameter['skipIoMappings'] = skipIoMappings;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes process definitions by a given key which belong to no tenant id.
         * @summary Delete By Key
         * @param {string} key The key of the process definitions to be deleted.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessDefinitionsByKey: async (key: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling deleteProcessDefinitionsByKey.');
            }
            const localVarPath = `/process-definition/key/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cascade !== undefined) {
                localVarQueryParameter['cascade'] = cascade;
            }

            if (skipCustomListeners !== undefined) {
                localVarQueryParameter['skipCustomListeners'] = skipCustomListeners;
            }

            if (skipIoMappings !== undefined) {
                localVarQueryParameter['skipIoMappings'] = skipIoMappings;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes process definitions by a given key and which belong to a tenant id.
         * @summary Delete By Key
         * @param {string} key The key of the process definitions to be deleted.
         * @param {string} tenantId The id of the tenant the process definitions belong to.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessDefinitionsByKeyAndTenantId: async (key: string, tenantId: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling deleteProcessDefinitionsByKeyAndTenantId.');
            }
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling deleteProcessDefinitionsByKeyAndTenantId.');
            }
            const localVarPath = `/process-definition/key/{key}/tenant-id/{tenant-id}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cascade !== undefined) {
                localVarQueryParameter['cascade'] = cascade;
            }

            if (skipCustomListeners !== undefined) {
                localVarQueryParameter['skipCustomListeners'] = skipCustomListeners;
            }

            if (skipIoMappings !== undefined) {
                localVarQueryParameter['skipIoMappings'] = skipIoMappings;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves runtime statistics of a given process definition, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Activity Instance Statistics
         * @param {string} id The id of the process definition.
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityStatistics: async (id: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getActivityStatistics.');
            }
            const localVarPath = `/process-definition/{id}/statistics`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (failedJobs !== undefined) {
                localVarQueryParameter['failedJobs'] = failedJobs;
            }

            if (incidents !== undefined) {
                localVarQueryParameter['incidents'] = incidents;
            }

            if (incidentsForType !== undefined) {
                localVarQueryParameter['incidentsForType'] = incidentsForType;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves runtime statistics of the latest version of the given process definition which belongs to no tenant, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Activity Instance Statistics
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityStatisticsByProcessDefinitionKey: async (key: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getActivityStatisticsByProcessDefinitionKey.');
            }
            const localVarPath = `/process-definition/key/{key}/statistics`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (failedJobs !== undefined) {
                localVarQueryParameter['failedJobs'] = failedJobs;
            }

            if (incidents !== undefined) {
                localVarQueryParameter['incidents'] = incidents;
            }

            if (incidentsForType !== undefined) {
                localVarQueryParameter['incidentsForType'] = incidentsForType;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves runtime statistics of the latest version of the given process definition for a tenant, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Activity Instance Statistics
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityStatisticsByProcessDefinitionKeyAndTenantId: async (key: string, tenantId: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getActivityStatisticsByProcessDefinitionKeyAndTenantId.');
            }
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling getActivityStatisticsByProcessDefinitionKeyAndTenantId.');
            }
            const localVarPath = `/process-definition/key/{key}/tenant-id/{tenant-id}/statistics`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (failedJobs !== undefined) {
                localVarQueryParameter['failedJobs'] = failedJobs;
            }

            if (incidents !== undefined) {
                localVarQueryParameter['incidents'] = incidents;
            }

            if (incidentsForType !== undefined) {
                localVarQueryParameter['incidentsForType'] = incidentsForType;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Start Form
         * @param {string} id The id of the process definition to get the deployed start form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedStartForm: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDeployedStartForm.');
            }
            const localVarPath = `/process-definition/{id}/deployed-start-form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedStartFormByKey: async (key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getDeployedStartFormByKey.');
            }
            const localVarPath = `/process-definition/key/{key}/deployed-start-form`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definitions belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedStartFormByKeyAndTenantId: async (key: string, tenantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getDeployedStartFormByKeyAndTenantId.');
            }
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling getDeployedStartFormByKeyAndTenantId.');
            }
            const localVarPath = `/process-definition/key/{key}/tenant-id/{tenant-id}/deployed-start-form`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the latest version of the process definition for tenant according to the `ProcessDefinition` interface in the engine.
         * @summary Get
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestProcessDefinitionByTenantId: async (key: string, tenantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getLatestProcessDefinitionByTenantId.');
            }
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling getLatestProcessDefinitionByTenantId.');
            }
            const localVarPath = `/process-definition/key/{key}/tenant-id/{tenant-id}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a process definition according to the `ProcessDefinition` interface in the engine.
         * @summary Get
         * @param {string} id The id of the process definition to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinition: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getProcessDefinition.');
            }
            const localVarPath = `/process-definition/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the BPMN 2.0 XML of a process definition.
         * @summary Get XML
         * @param {string} id The id of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionBpmn20Xml: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getProcessDefinitionBpmn20Xml.');
            }
            const localVarPath = `/process-definition/{id}/xml`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves latest version the BPMN 2.0 XML of a process definition.
         * @summary Get XML
         * @param {string} key The key of the process definition (the latest version thereof) whose XML should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionBpmn20XmlByKey: async (key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getProcessDefinitionBpmn20XmlByKey.');
            }
            const localVarPath = `/process-definition/key/{key}/xml`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves latest version the BPMN 2.0 XML of a process definition. Returns the XML for the latest version of the process definition for tenant.
         * @summary Get XML
         * @param {string} key The key of the process definition (the latest version thereof) whose XML should be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionBpmn20XmlByKeyAndTenantId: async (key: string, tenantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getProcessDefinitionBpmn20XmlByKeyAndTenantId.');
            }
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling getProcessDefinitionBpmn20XmlByKeyAndTenantId.');
            }
            const localVarPath = `/process-definition/key/{key}/tenant-id/{tenant-id}/xml`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the latest version of the process definition which belongs to no tenant according to the `ProcessDefinition` interface in the engine.
         * @summary Get
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionByKey: async (key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getProcessDefinitionByKey.');
            }
            const localVarPath = `/process-definition/key/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the diagram of a process definition.  If the process definition's deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
         * @summary Get Diagram
         * @param {string} id The id of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionDiagram: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getProcessDefinitionDiagram.');
            }
            const localVarPath = `/process-definition/{id}/diagram`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the diagram for the latest version of the process definition which belongs to no tenant.  If the process definition's deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
         * @summary Get Diagram
         * @param {string} key The key of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionDiagramByKey: async (key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getProcessDefinitionDiagramByKey.');
            }
            const localVarPath = `/process-definition/key/{key}/diagram`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the diagram for the latest version of the process definition for tenant.  If the process definition's deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
         * @summary Get Diagram
         * @param {string} key The key of the process definition.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionDiagramByKeyAndTenantId: async (key: string, tenantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getProcessDefinitionDiagramByKeyAndTenantId.');
            }
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling getProcessDefinitionDiagramByKeyAndTenantId.');
            }
            const localVarPath = `/process-definition/key/{key}/tenant-id/{tenant-id}/diagram`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves runtime statistics of the process engine, grouped by process definitions. These statistics include the number of running process instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Process Instance Statistics
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {boolean} [rootIncidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of root incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60; or &#x60;incidents&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionStatistics: async (failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, rootIncidents?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/process-definition/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (failedJobs !== undefined) {
                localVarQueryParameter['failedJobs'] = failedJobs;
            }

            if (incidents !== undefined) {
                localVarQueryParameter['incidents'] = incidents;
            }

            if (incidentsForType !== undefined) {
                localVarQueryParameter['incidentsForType'] = incidentsForType;
            }

            if (rootIncidents !== undefined) {
                localVarQueryParameter['rootIncidents'] = rootIncidents;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for process definitions that fulfill given parameters. Parameters may be the properties of  process definitions, such as the name, key or version. The size of the result set can be retrieved by using the [Get Definition Count](https://docs.camunda.org/manual/7.18/reference/rest/process-definition/get-query-count/) method.
         * @summary Get List
         * @param {string} [processDefinitionId] Filter by process definition id.
         * @param {string} [processDefinitionIdIn] Filter by a comma-separated list of process definition ids.
         * @param {string} [name] Filter by process definition name.
         * @param {string} [nameLike] Filter by process definition names that the parameter is a substring of.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {Date} [deployedAfter] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {Date} [deployedAt] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [key] Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match.
         * @param {string} [keysIn] Filter by a comma-separated list of process definition keys.
         * @param {string} [keyLike] Filter by process definition keys that the parameter is a substring of.
         * @param {string} [category] Filter by process definition category. Exact match.
         * @param {string} [categoryLike] Filter by process definition categories that the parameter is a substring of.
         * @param {number} [version] Filter by process definition version.
         * @param {boolean} [latestVersion] Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [resourceName] Filter by the name of the process definition resource. Exact match.
         * @param {string} [resourceNameLike] Filter by names of those process definition resources that the parameter is a substring of.
         * @param {string} [startableBy] Filter by a user name who is allowed to start the process.
         * @param {boolean} [active] Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior.
         * @param {boolean} [includeProcessDefinitionsWithoutTenantId] Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [versionTag] Filter by the version tag.
         * @param {string} [versionTagLike] Filter by the version tag that the parameter is a substring of.
         * @param {boolean} [withoutVersionTag] Only include process definitions without a &#x60;versionTag&#x60;.
         * @param {boolean} [startableInTasklist] Filter by process definitions which are startable in Tasklist..
         * @param {boolean} [notStartableInTasklist] Filter by process definitions which are not startable in Tasklist.
         * @param {boolean} [startablePermissionCheck] Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn&#x27;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitions: async (processDefinitionId?: string, processDefinitionIdIn?: string, name?: string, nameLike?: string, deploymentId?: string, deployedAfter?: Date, deployedAt?: Date, key?: string, keysIn?: string, keyLike?: string, category?: string, categoryLike?: string, version?: number, latestVersion?: boolean, resourceName?: string, resourceNameLike?: string, startableBy?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeProcessDefinitionsWithoutTenantId?: boolean, versionTag?: string, versionTagLike?: string, withoutVersionTag?: boolean, startableInTasklist?: boolean, notStartableInTasklist?: boolean, startablePermissionCheck?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/process-definition`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (processDefinitionId !== undefined) {
                localVarQueryParameter['processDefinitionId'] = processDefinitionId;
            }

            if (processDefinitionIdIn !== undefined) {
                localVarQueryParameter['processDefinitionIdIn'] = processDefinitionIdIn;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameLike !== undefined) {
                localVarQueryParameter['nameLike'] = nameLike;
            }

            if (deploymentId !== undefined) {
                localVarQueryParameter['deploymentId'] = deploymentId;
            }

            if (deployedAfter !== undefined) {
                localVarQueryParameter['deployedAfter'] = (deployedAfter as any instanceof Date) ?
                    (deployedAfter as any).toISOString() :
                    deployedAfter;
            }

            if (deployedAt !== undefined) {
                localVarQueryParameter['deployedAt'] = (deployedAt as any instanceof Date) ?
                    (deployedAt as any).toISOString() :
                    deployedAt;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }

            if (keysIn !== undefined) {
                localVarQueryParameter['keysIn'] = keysIn;
            }

            if (keyLike !== undefined) {
                localVarQueryParameter['keyLike'] = keyLike;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (categoryLike !== undefined) {
                localVarQueryParameter['categoryLike'] = categoryLike;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (latestVersion !== undefined) {
                localVarQueryParameter['latestVersion'] = latestVersion;
            }

            if (resourceName !== undefined) {
                localVarQueryParameter['resourceName'] = resourceName;
            }

            if (resourceNameLike !== undefined) {
                localVarQueryParameter['resourceNameLike'] = resourceNameLike;
            }

            if (startableBy !== undefined) {
                localVarQueryParameter['startableBy'] = startableBy;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (suspended !== undefined) {
                localVarQueryParameter['suspended'] = suspended;
            }

            if (incidentId !== undefined) {
                localVarQueryParameter['incidentId'] = incidentId;
            }

            if (incidentType !== undefined) {
                localVarQueryParameter['incidentType'] = incidentType;
            }

            if (incidentMessage !== undefined) {
                localVarQueryParameter['incidentMessage'] = incidentMessage;
            }

            if (incidentMessageLike !== undefined) {
                localVarQueryParameter['incidentMessageLike'] = incidentMessageLike;
            }

            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }

            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }

            if (includeProcessDefinitionsWithoutTenantId !== undefined) {
                localVarQueryParameter['includeProcessDefinitionsWithoutTenantId'] = includeProcessDefinitionsWithoutTenantId;
            }

            if (versionTag !== undefined) {
                localVarQueryParameter['versionTag'] = versionTag;
            }

            if (versionTagLike !== undefined) {
                localVarQueryParameter['versionTagLike'] = versionTagLike;
            }

            if (withoutVersionTag !== undefined) {
                localVarQueryParameter['withoutVersionTag'] = withoutVersionTag;
            }

            if (startableInTasklist !== undefined) {
                localVarQueryParameter['startableInTasklist'] = startableInTasklist;
            }

            if (notStartableInTasklist !== undefined) {
                localVarQueryParameter['notStartableInTasklist'] = notStartableInTasklist;
            }

            if (startablePermissionCheck !== undefined) {
                localVarQueryParameter['startablePermissionCheck'] = startablePermissionCheck;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requests the number of process definitions that fulfill the query criteria. Takes the same filtering parameters as the [Get Definitions](https://docs.camunda.org/manual/7.18/reference/rest/process-definition/get-query/) method.
         * @summary Get List Count
         * @param {string} [processDefinitionId] Filter by process definition id.
         * @param {string} [processDefinitionIdIn] Filter by a comma-separated list of process definition ids.
         * @param {string} [name] Filter by process definition name.
         * @param {string} [nameLike] Filter by process definition names that the parameter is a substring of.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {Date} [deployedAfter] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {Date} [deployedAt] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [key] Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match.
         * @param {string} [keysIn] Filter by a comma-separated list of process definition keys.
         * @param {string} [keyLike] Filter by process definition keys that the parameter is a substring of.
         * @param {string} [category] Filter by process definition category. Exact match.
         * @param {string} [categoryLike] Filter by process definition categories that the parameter is a substring of.
         * @param {number} [version] Filter by process definition version.
         * @param {boolean} [latestVersion] Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [resourceName] Filter by the name of the process definition resource. Exact match.
         * @param {string} [resourceNameLike] Filter by names of those process definition resources that the parameter is a substring of.
         * @param {string} [startableBy] Filter by a user name who is allowed to start the process.
         * @param {boolean} [active] Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior.
         * @param {boolean} [includeProcessDefinitionsWithoutTenantId] Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [versionTag] Filter by the version tag.
         * @param {string} [versionTagLike] Filter by the version tag that the parameter is a substring of.
         * @param {boolean} [withoutVersionTag] Only include process definitions without a &#x60;versionTag&#x60;.
         * @param {boolean} [startableInTasklist] Filter by process definitions which are startable in Tasklist..
         * @param {boolean} [notStartableInTasklist] Filter by process definitions which are not startable in Tasklist.
         * @param {boolean} [startablePermissionCheck] Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn&#x27;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionsCount: async (processDefinitionId?: string, processDefinitionIdIn?: string, name?: string, nameLike?: string, deploymentId?: string, deployedAfter?: Date, deployedAt?: Date, key?: string, keysIn?: string, keyLike?: string, category?: string, categoryLike?: string, version?: number, latestVersion?: boolean, resourceName?: string, resourceNameLike?: string, startableBy?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeProcessDefinitionsWithoutTenantId?: boolean, versionTag?: string, versionTagLike?: string, withoutVersionTag?: boolean, startableInTasklist?: boolean, notStartableInTasklist?: boolean, startablePermissionCheck?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/process-definition/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (processDefinitionId !== undefined) {
                localVarQueryParameter['processDefinitionId'] = processDefinitionId;
            }

            if (processDefinitionIdIn !== undefined) {
                localVarQueryParameter['processDefinitionIdIn'] = processDefinitionIdIn;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameLike !== undefined) {
                localVarQueryParameter['nameLike'] = nameLike;
            }

            if (deploymentId !== undefined) {
                localVarQueryParameter['deploymentId'] = deploymentId;
            }

            if (deployedAfter !== undefined) {
                localVarQueryParameter['deployedAfter'] = (deployedAfter as any instanceof Date) ?
                    (deployedAfter as any).toISOString() :
                    deployedAfter;
            }

            if (deployedAt !== undefined) {
                localVarQueryParameter['deployedAt'] = (deployedAt as any instanceof Date) ?
                    (deployedAt as any).toISOString() :
                    deployedAt;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }

            if (keysIn !== undefined) {
                localVarQueryParameter['keysIn'] = keysIn;
            }

            if (keyLike !== undefined) {
                localVarQueryParameter['keyLike'] = keyLike;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (categoryLike !== undefined) {
                localVarQueryParameter['categoryLike'] = categoryLike;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (latestVersion !== undefined) {
                localVarQueryParameter['latestVersion'] = latestVersion;
            }

            if (resourceName !== undefined) {
                localVarQueryParameter['resourceName'] = resourceName;
            }

            if (resourceNameLike !== undefined) {
                localVarQueryParameter['resourceNameLike'] = resourceNameLike;
            }

            if (startableBy !== undefined) {
                localVarQueryParameter['startableBy'] = startableBy;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (suspended !== undefined) {
                localVarQueryParameter['suspended'] = suspended;
            }

            if (incidentId !== undefined) {
                localVarQueryParameter['incidentId'] = incidentId;
            }

            if (incidentType !== undefined) {
                localVarQueryParameter['incidentType'] = incidentType;
            }

            if (incidentMessage !== undefined) {
                localVarQueryParameter['incidentMessage'] = incidentMessage;
            }

            if (incidentMessageLike !== undefined) {
                localVarQueryParameter['incidentMessageLike'] = incidentMessageLike;
            }

            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }

            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }

            if (includeProcessDefinitionsWithoutTenantId !== undefined) {
                localVarQueryParameter['includeProcessDefinitionsWithoutTenantId'] = includeProcessDefinitionsWithoutTenantId;
            }

            if (versionTag !== undefined) {
                localVarQueryParameter['versionTag'] = versionTag;
            }

            if (versionTagLike !== undefined) {
                localVarQueryParameter['versionTagLike'] = versionTagLike;
            }

            if (withoutVersionTag !== undefined) {
                localVarQueryParameter['withoutVersionTag'] = withoutVersionTag;
            }

            if (startableInTasklist !== undefined) {
                localVarQueryParameter['startableInTasklist'] = startableInTasklist;
            }

            if (notStartableInTasklist !== undefined) {
                localVarQueryParameter['notStartableInTasklist'] = notStartableInTasklist;
            }

            if (startablePermissionCheck !== undefined) {
                localVarQueryParameter['startablePermissionCheck'] = startablePermissionCheck;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the rendered form for a process definition. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Start Form
         * @param {string} id The id of the process definition to get the rendered start form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRenderedStartForm: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRenderedStartForm.');
            }
            const localVarPath = `/process-definition/{id}/rendered-form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves  the rendered form for the latest version of the process definition which belongs to no tenant. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRenderedStartFormByKey: async (key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getRenderedStartFormByKey.');
            }
            const localVarPath = `/process-definition/key/{key}/rendered-form`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves  the rendered form for the latest version of the process definition for a tenant. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRenderedStartFormByKeyAndTenantId: async (key: string, tenantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getRenderedStartFormByKeyAndTenantId.');
            }
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling getRenderedStartFormByKeyAndTenantId.');
            }
            const localVarPath = `/process-definition/key/{key}/tenant-id/{tenant-id}/rendered-form`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the key of the start form for a process definition. The form key corresponds to the `FormData#formKey` property in the engine.
         * @summary Get Start Form Key
         * @param {string} id The id of the process definition to get the start form key for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartForm: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getStartForm.');
            }
            const localVarPath = `/process-definition/{id}/startForm`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the key of the start form for the latest version of the process definition which belongs to no tenant. The form key corresponds to the `FormData#formKey` property in the engine.
         * @summary Get Start Form Key
         * @param {string} key The key of the process definition (the latest version thereof) for which the form key is to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormByKey: async (key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getStartFormByKey.');
            }
            const localVarPath = `/process-definition/key/{key}/startForm`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the key of the start form for the latest version of the process definition for a tenant. The form key corresponds to the `FormData#formKey` property in the engine.
         * @summary Get Start Form Key
         * @param {string} key The key of the process definition (the latest version thereof) for which the form key is to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormByKeyAndTenantId: async (key: string, tenantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getStartFormByKeyAndTenantId.');
            }
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling getStartFormByKeyAndTenantId.');
            }
            const localVarPath = `/process-definition/key/{key}/tenant-id/{tenant-id}/startForm`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the start form variables for a process definition (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Start Form Variables
         * @param {string} id The id of the process definition to retrieve the variables for.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormVariables: async (id: string, variableNames?: string, deserializeValues?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getStartFormVariables.');
            }
            const localVarPath = `/process-definition/{id}/form-variables`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (variableNames !== undefined) {
                localVarQueryParameter['variableNames'] = variableNames;
            }

            if (deserializeValues !== undefined) {
                localVarQueryParameter['deserializeValues'] = deserializeValues;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the start form variables for the latest process definition which belongs to no tenant (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Start Form Variables
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormVariablesByKey: async (key: string, variableNames?: string, deserializeValues?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getStartFormVariablesByKey.');
            }
            const localVarPath = `/process-definition/key/{key}/form-variables`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (variableNames !== undefined) {
                localVarQueryParameter['variableNames'] = variableNames;
            }

            if (deserializeValues !== undefined) {
                localVarQueryParameter['deserializeValues'] = deserializeValues;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the start form variables for the latest process definition for a tenant (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Start Form Variables
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormVariablesByKeyAndTenantId: async (key: string, tenantId: string, variableNames?: string, deserializeValues?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getStartFormVariablesByKeyAndTenantId.');
            }
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling getStartFormVariablesByKeyAndTenantId.');
            }
            const localVarPath = `/process-definition/key/{key}/tenant-id/{tenant-id}/form-variables`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (variableNames !== undefined) {
                localVarQueryParameter['variableNames'] = variableNames;
            }

            if (deserializeValues !== undefined) {
                localVarQueryParameter['deserializeValues'] = deserializeValues;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * For the given process, returns a list of called process definitions corresponding to the `CalledProcessDefinition` interface in the engine. The list contains all process definitions that are referenced statically by call activities in the given process. This endpoint does not resolve process definitions that are referenced with expressions. Each called process definition contains a list of call activity ids, which specifies the call activities that are calling that process. This endpoint does not resolve references to case definitions.
         * @summary Get Static Called Process Definitions
         * @param {string} id The id of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStaticCalledProcessDefinitions: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getStaticCalledProcessDefinitions.');
            }
            const localVarPath = `/process-definition/{id}/static-called-process-definitions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Restarts process instances that were canceled or terminated synchronously. Can also restart completed process instances. It will create a new instance using the original instance information. To execute the restart asynchronously, use the [Restart Process Instance Async](https://docs.camunda.org/manual/7.18/reference/rest/process-definition/post-restart-process-instance-async/) method.  For more information about the difference between synchronous and asynchronous execution, please refer to the related section of the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/process-instance-restart/#execution).
         * @summary Restart Process Instance
         * @param {string} id The id of the process definition of the process instances to restart.
         * @param {RestartProcessInstanceDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartProcessInstance: async (id: string, body?: RestartProcessInstanceDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling restartProcessInstance.');
            }
            const localVarPath = `/process-definition/{id}/restart`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Restarts process instances that were canceled or terminated asynchronously. Can also restart completed process instances. It will create a new instance using the original instance information. To execute the restart asynchronously, use the [Restart Process Instance](https://docs.camunda.org/manual/7.18/reference/rest/process-definition/post-restart-process-instance-sync/) method.  For more information about the difference between synchronous and asynchronous execution, please refer to the related section of the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/process-instance-restart/#execution).
         * @summary Restart Process Instance Async
         * @param {string} id The id of the process definition of the process instances to restart.
         * @param {RestartProcessInstanceDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartProcessInstanceAsyncOperation: async (id: string, body?: RestartProcessInstanceDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling restartProcessInstanceAsyncOperation.');
            }
            const localVarPath = `/process-definition/{id}/restart-async`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Instantiates a given process definition. Process variables and business key may be supplied in the request body.
         * @summary Start Instance
         * @param {string} id The id of the process definition to be retrieved.
         * @param {StartProcessInstanceDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProcessInstance: async (id: string, body?: StartProcessInstanceDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling startProcessInstance.');
            }
            const localVarPath = `/process-definition/{id}/start`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Instantiates a given process definition, starts the latest version of the process definition which belongs to no tenant. Process variables and business key may be supplied in the request body.
         * @summary Start Instance
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {StartProcessInstanceDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProcessInstanceByKey: async (key: string, body?: StartProcessInstanceDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling startProcessInstanceByKey.');
            }
            const localVarPath = `/process-definition/key/{key}/start`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Instantiates a given process definition, starts the latest version of the process definition for tenant. Process variables and business key may be supplied in the request body.
         * @summary Start Instance
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {StartProcessInstanceDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProcessInstanceByKeyAndTenantId: async (key: string, tenantId: string, body?: StartProcessInstanceDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling startProcessInstanceByKeyAndTenantId.');
            }
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling startProcessInstanceByKeyAndTenantId.');
            }
            const localVarPath = `/process-definition/key/{key}/tenant-id/{tenant-id}/start`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts a process instance using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms).
         * @summary Submit Start Form
         * @param {string} id The id of the process definition to submit the form for.
         * @param {StartProcessInstanceFormDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitForm: async (id: string, body?: StartProcessInstanceFormDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling submitForm.');
            }
            const localVarPath = `/process-definition/{id}/submit-form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts the latest version of the process definition which belongs to no tenant using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms).
         * @summary Submit Start Form
         * @param {string} key The key of the process definition to submit the form for.
         * @param {StartProcessInstanceFormDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitFormByKey: async (key: string, body?: StartProcessInstanceFormDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling submitFormByKey.');
            }
            const localVarPath = `/process-definition/key/{key}/submit-form`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts the latest version of the process definition for a tenant using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms).
         * @summary Submit Start Form
         * @param {string} key The key of the process definition to submit the form for.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {StartProcessInstanceFormDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitFormByKeyAndTenantId: async (key: string, tenantId: string, body?: StartProcessInstanceFormDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling submitFormByKeyAndTenantId.');
            }
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling submitFormByKeyAndTenantId.');
            }
            const localVarPath = `/process-definition/key/{key}/tenant-id/{tenant-id}/submit-form`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates history time to live for process definition. The field is used within [History cleanup](https://docs.camunda.org/manual/7.18/user-guide/process-engine/history/#history-cleanup).
         * @summary Update History Time to Live
         * @param {string} id The id of the process definition to change history time to live.
         * @param {HistoryTimeToLiveDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHistoryTimeToLiveByProcessDefinitionId: async (id: string, body?: HistoryTimeToLiveDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateHistoryTimeToLiveByProcessDefinitionId.');
            }
            const localVarPath = `/process-definition/{id}/history-time-to-live`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates history time to live for the latest version of the process definition which belongs to no tenant. The field is used within [History cleanup](https://docs.camunda.org/manual/7.18/user-guide/process-engine/history/#history-cleanup).
         * @summary Update History Time to Live
         * @param {string} key The key of the process definition to change history time to live.
         * @param {HistoryTimeToLiveDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHistoryTimeToLiveByProcessDefinitionKey: async (key: string, body?: HistoryTimeToLiveDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling updateHistoryTimeToLiveByProcessDefinitionKey.');
            }
            const localVarPath = `/process-definition/key/{key}/history-time-to-live`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates history time to live for the latest version of the process definition for a tenant. The field is used within [History cleanup](https://docs.camunda.org/manual/7.18/user-guide/process-engine/history/#history-cleanup).
         * @summary Update History Time to Live
         * @param {string} key The key of the process definition to change history time to live.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {HistoryTimeToLiveDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId: async (key: string, tenantId: string, body?: HistoryTimeToLiveDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId.');
            }
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId.');
            }
            const localVarPath = `/process-definition/key/{key}/tenant-id/{tenant-id}/history-time-to-live`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Activates or suspends process definitions with the given process definition key.
         * @summary Activate/Suspend By Key
         * @param {ProcessDefinitionSuspensionStateDto} [body] **Note**: Unallowed property is &#x60;processDefinitionId&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcessDefinitionSuspensionState: async (body?: ProcessDefinitionSuspensionStateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/process-definition/suspended`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Activates or suspends a given process definition by id.
         * @summary Activate/Suspend By Id
         * @param {string} id The id of the process definition to activate or suspend.
         * @param {ProcessDefinitionSuspensionStateDto} [body] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcessDefinitionSuspensionStateById: async (id: string, body?: ProcessDefinitionSuspensionStateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateProcessDefinitionSuspensionStateById.');
            }
            const localVarPath = `/process-definition/{id}/suspended`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Activates or suspends a given process definition by latest version of process definition key which belongs to no tenant.
         * @summary Activate/Suspend by Id
         * @param {string} key The key of the process definition (the latest version thereof) to be activated/suspended.
         * @param {ProcessDefinitionSuspensionStateDto} [body] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcessDefinitionSuspensionStateByKey: async (key: string, body?: ProcessDefinitionSuspensionStateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling updateProcessDefinitionSuspensionStateByKey.');
            }
            const localVarPath = `/process-definition/key/{key}/suspended`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Activates or suspends a given process definition by the latest version of the process definition for tenant.
         * @summary Activate/Suspend by Id
         * @param {string} key The key of the process definition (the latest version thereof) to be activated/suspended.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {ProcessDefinitionSuspensionStateDto} [body] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcessDefinitionSuspensionStateByKeyAndTenantId: async (key: string, tenantId: string, body?: ProcessDefinitionSuspensionStateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling updateProcessDefinitionSuspensionStateByKeyAndTenantId.');
            }
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling updateProcessDefinitionSuspensionStateByKeyAndTenantId.');
            }
            const localVarPath = `/process-definition/key/{key}/tenant-id/{tenant-id}/suspended`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProcessDefinitionApi - functional programming interface
 * @export
 */
export const ProcessDefinitionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes a running process instance by id.
         * @summary Delete
         * @param {string} id The id of the process definition to be deleted.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProcessDefinition(id: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).deleteProcessDefinition(id, cascade, skipCustomListeners, skipIoMappings, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes process definitions by a given key which belong to no tenant id.
         * @summary Delete By Key
         * @param {string} key The key of the process definitions to be deleted.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProcessDefinitionsByKey(key: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).deleteProcessDefinitionsByKey(key, cascade, skipCustomListeners, skipIoMappings, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes process definitions by a given key and which belong to a tenant id.
         * @summary Delete By Key
         * @param {string} key The key of the process definitions to be deleted.
         * @param {string} tenantId The id of the tenant the process definitions belong to.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProcessDefinitionsByKeyAndTenantId(key: string, tenantId: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).deleteProcessDefinitionsByKeyAndTenantId(key, tenantId, cascade, skipCustomListeners, skipIoMappings, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves runtime statistics of a given process definition, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Activity Instance Statistics
         * @param {string} id The id of the process definition.
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivityStatistics(id: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<ActivityStatisticsResultDto>>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).getActivityStatistics(id, failedJobs, incidents, incidentsForType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves runtime statistics of the latest version of the given process definition which belongs to no tenant, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Activity Instance Statistics
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivityStatisticsByProcessDefinitionKey(key: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<ActivityStatisticsResultDto>>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).getActivityStatisticsByProcessDefinitionKey(key, failedJobs, incidents, incidentsForType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves runtime statistics of the latest version of the given process definition for a tenant, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Activity Instance Statistics
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivityStatisticsByProcessDefinitionKeyAndTenantId(key: string, tenantId: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<ActivityStatisticsResultDto>>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).getActivityStatisticsByProcessDefinitionKeyAndTenantId(key, tenantId, failedJobs, incidents, incidentsForType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Start Form
         * @param {string} id The id of the process definition to get the deployed start form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeployedStartForm(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Blob>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).getDeployedStartForm(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeployedStartFormByKey(key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Blob>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).getDeployedStartFormByKey(key, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definitions belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeployedStartFormByKeyAndTenantId(key: string, tenantId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Blob>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).getDeployedStartFormByKeyAndTenantId(key, tenantId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves the latest version of the process definition for tenant according to the `ProcessDefinition` interface in the engine.
         * @summary Get
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestProcessDefinitionByTenantId(key: string, tenantId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ProcessDefinitionDto>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).getLatestProcessDefinitionByTenantId(key, tenantId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves a process definition according to the `ProcessDefinition` interface in the engine.
         * @summary Get
         * @param {string} id The id of the process definition to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinition(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ProcessDefinitionDto>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).getProcessDefinition(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves the BPMN 2.0 XML of a process definition.
         * @summary Get XML
         * @param {string} id The id of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitionBpmn20Xml(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ProcessDefinitionDiagramDto>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).getProcessDefinitionBpmn20Xml(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves latest version the BPMN 2.0 XML of a process definition.
         * @summary Get XML
         * @param {string} key The key of the process definition (the latest version thereof) whose XML should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitionBpmn20XmlByKey(key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ProcessDefinitionDiagramDto>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).getProcessDefinitionBpmn20XmlByKey(key, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves latest version the BPMN 2.0 XML of a process definition. Returns the XML for the latest version of the process definition for tenant.
         * @summary Get XML
         * @param {string} key The key of the process definition (the latest version thereof) whose XML should be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitionBpmn20XmlByKeyAndTenantId(key: string, tenantId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ProcessDefinitionDiagramDto>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).getProcessDefinitionBpmn20XmlByKeyAndTenantId(key, tenantId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves the latest version of the process definition which belongs to no tenant according to the `ProcessDefinition` interface in the engine.
         * @summary Get
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitionByKey(key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ProcessDefinitionDto>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).getProcessDefinitionByKey(key, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves the diagram of a process definition.  If the process definition's deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
         * @summary Get Diagram
         * @param {string} id The id of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitionDiagram(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Blob>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).getProcessDefinitionDiagram(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves the diagram for the latest version of the process definition which belongs to no tenant.  If the process definition's deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
         * @summary Get Diagram
         * @param {string} key The key of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitionDiagramByKey(key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Blob>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).getProcessDefinitionDiagramByKey(key, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves the diagram for the latest version of the process definition for tenant.  If the process definition's deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
         * @summary Get Diagram
         * @param {string} key The key of the process definition.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitionDiagramByKeyAndTenantId(key: string, tenantId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Blob>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).getProcessDefinitionDiagramByKeyAndTenantId(key, tenantId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves runtime statistics of the process engine, grouped by process definitions. These statistics include the number of running process instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Process Instance Statistics
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {boolean} [rootIncidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of root incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60; or &#x60;incidents&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitionStatistics(failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, rootIncidents?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<ProcessDefinitionStatisticsResultDto>>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).getProcessDefinitionStatistics(failedJobs, incidents, incidentsForType, rootIncidents, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Queries for process definitions that fulfill given parameters. Parameters may be the properties of  process definitions, such as the name, key or version. The size of the result set can be retrieved by using the [Get Definition Count](https://docs.camunda.org/manual/7.18/reference/rest/process-definition/get-query-count/) method.
         * @summary Get List
         * @param {string} [processDefinitionId] Filter by process definition id.
         * @param {string} [processDefinitionIdIn] Filter by a comma-separated list of process definition ids.
         * @param {string} [name] Filter by process definition name.
         * @param {string} [nameLike] Filter by process definition names that the parameter is a substring of.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {Date} [deployedAfter] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {Date} [deployedAt] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [key] Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match.
         * @param {string} [keysIn] Filter by a comma-separated list of process definition keys.
         * @param {string} [keyLike] Filter by process definition keys that the parameter is a substring of.
         * @param {string} [category] Filter by process definition category. Exact match.
         * @param {string} [categoryLike] Filter by process definition categories that the parameter is a substring of.
         * @param {number} [version] Filter by process definition version.
         * @param {boolean} [latestVersion] Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [resourceName] Filter by the name of the process definition resource. Exact match.
         * @param {string} [resourceNameLike] Filter by names of those process definition resources that the parameter is a substring of.
         * @param {string} [startableBy] Filter by a user name who is allowed to start the process.
         * @param {boolean} [active] Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior.
         * @param {boolean} [includeProcessDefinitionsWithoutTenantId] Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [versionTag] Filter by the version tag.
         * @param {string} [versionTagLike] Filter by the version tag that the parameter is a substring of.
         * @param {boolean} [withoutVersionTag] Only include process definitions without a &#x60;versionTag&#x60;.
         * @param {boolean} [startableInTasklist] Filter by process definitions which are startable in Tasklist..
         * @param {boolean} [notStartableInTasklist] Filter by process definitions which are not startable in Tasklist.
         * @param {boolean} [startablePermissionCheck] Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn&#x27;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitions(processDefinitionId?: string, processDefinitionIdIn?: string, name?: string, nameLike?: string, deploymentId?: string, deployedAfter?: Date, deployedAt?: Date, key?: string, keysIn?: string, keyLike?: string, category?: string, categoryLike?: string, version?: number, latestVersion?: boolean, resourceName?: string, resourceNameLike?: string, startableBy?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeProcessDefinitionsWithoutTenantId?: boolean, versionTag?: string, versionTagLike?: string, withoutVersionTag?: boolean, startableInTasklist?: boolean, notStartableInTasklist?: boolean, startablePermissionCheck?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<ProcessDefinitionDto>>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).getProcessDefinitions(processDefinitionId, processDefinitionIdIn, name, nameLike, deploymentId, deployedAfter, deployedAt, key, keysIn, keyLike, category, categoryLike, version, latestVersion, resourceName, resourceNameLike, startableBy, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, includeProcessDefinitionsWithoutTenantId, versionTag, versionTagLike, withoutVersionTag, startableInTasklist, notStartableInTasklist, startablePermissionCheck, sortBy, sortOrder, firstResult, maxResults, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requests the number of process definitions that fulfill the query criteria. Takes the same filtering parameters as the [Get Definitions](https://docs.camunda.org/manual/7.18/reference/rest/process-definition/get-query/) method.
         * @summary Get List Count
         * @param {string} [processDefinitionId] Filter by process definition id.
         * @param {string} [processDefinitionIdIn] Filter by a comma-separated list of process definition ids.
         * @param {string} [name] Filter by process definition name.
         * @param {string} [nameLike] Filter by process definition names that the parameter is a substring of.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {Date} [deployedAfter] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {Date} [deployedAt] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [key] Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match.
         * @param {string} [keysIn] Filter by a comma-separated list of process definition keys.
         * @param {string} [keyLike] Filter by process definition keys that the parameter is a substring of.
         * @param {string} [category] Filter by process definition category. Exact match.
         * @param {string} [categoryLike] Filter by process definition categories that the parameter is a substring of.
         * @param {number} [version] Filter by process definition version.
         * @param {boolean} [latestVersion] Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [resourceName] Filter by the name of the process definition resource. Exact match.
         * @param {string} [resourceNameLike] Filter by names of those process definition resources that the parameter is a substring of.
         * @param {string} [startableBy] Filter by a user name who is allowed to start the process.
         * @param {boolean} [active] Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior.
         * @param {boolean} [includeProcessDefinitionsWithoutTenantId] Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [versionTag] Filter by the version tag.
         * @param {string} [versionTagLike] Filter by the version tag that the parameter is a substring of.
         * @param {boolean} [withoutVersionTag] Only include process definitions without a &#x60;versionTag&#x60;.
         * @param {boolean} [startableInTasklist] Filter by process definitions which are startable in Tasklist..
         * @param {boolean} [notStartableInTasklist] Filter by process definitions which are not startable in Tasklist.
         * @param {boolean} [startablePermissionCheck] Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn&#x27;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitionsCount(processDefinitionId?: string, processDefinitionIdIn?: string, name?: string, nameLike?: string, deploymentId?: string, deployedAfter?: Date, deployedAt?: Date, key?: string, keysIn?: string, keyLike?: string, category?: string, categoryLike?: string, version?: number, latestVersion?: boolean, resourceName?: string, resourceNameLike?: string, startableBy?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeProcessDefinitionsWithoutTenantId?: boolean, versionTag?: string, versionTagLike?: string, withoutVersionTag?: boolean, startableInTasklist?: boolean, notStartableInTasklist?: boolean, startablePermissionCheck?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<CountResultDto>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).getProcessDefinitionsCount(processDefinitionId, processDefinitionIdIn, name, nameLike, deploymentId, deployedAfter, deployedAt, key, keysIn, keyLike, category, categoryLike, version, latestVersion, resourceName, resourceNameLike, startableBy, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, includeProcessDefinitionsWithoutTenantId, versionTag, versionTagLike, withoutVersionTag, startableInTasklist, notStartableInTasklist, startablePermissionCheck, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves the rendered form for a process definition. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Start Form
         * @param {string} id The id of the process definition to get the rendered start form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRenderedStartForm(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Blob>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).getRenderedStartForm(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves  the rendered form for the latest version of the process definition which belongs to no tenant. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRenderedStartFormByKey(key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Blob>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).getRenderedStartFormByKey(key, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves  the rendered form for the latest version of the process definition for a tenant. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRenderedStartFormByKeyAndTenantId(key: string, tenantId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Blob>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).getRenderedStartFormByKeyAndTenantId(key, tenantId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves the key of the start form for a process definition. The form key corresponds to the `FormData#formKey` property in the engine.
         * @summary Get Start Form Key
         * @param {string} id The id of the process definition to get the start form key for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStartForm(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<FormDto>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).getStartForm(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves the key of the start form for the latest version of the process definition which belongs to no tenant. The form key corresponds to the `FormData#formKey` property in the engine.
         * @summary Get Start Form Key
         * @param {string} key The key of the process definition (the latest version thereof) for which the form key is to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStartFormByKey(key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<FormDto>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).getStartFormByKey(key, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves the key of the start form for the latest version of the process definition for a tenant. The form key corresponds to the `FormData#formKey` property in the engine.
         * @summary Get Start Form Key
         * @param {string} key The key of the process definition (the latest version thereof) for which the form key is to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStartFormByKeyAndTenantId(key: string, tenantId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<FormDto>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).getStartFormByKeyAndTenantId(key, tenantId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves the start form variables for a process definition (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Start Form Variables
         * @param {string} id The id of the process definition to retrieve the variables for.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStartFormVariables(id: string, variableNames?: string, deserializeValues?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<{ [key: string]: VariableValueDto; }>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).getStartFormVariables(id, variableNames, deserializeValues, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves the start form variables for the latest process definition which belongs to no tenant (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Start Form Variables
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStartFormVariablesByKey(key: string, variableNames?: string, deserializeValues?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<{ [key: string]: VariableValueDto; }>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).getStartFormVariablesByKey(key, variableNames, deserializeValues, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves the start form variables for the latest process definition for a tenant (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Start Form Variables
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStartFormVariablesByKeyAndTenantId(key: string, tenantId: string, variableNames?: string, deserializeValues?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<{ [key: string]: VariableValueDto; }>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).getStartFormVariablesByKeyAndTenantId(key, tenantId, variableNames, deserializeValues, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * For the given process, returns a list of called process definitions corresponding to the `CalledProcessDefinition` interface in the engine. The list contains all process definitions that are referenced statically by call activities in the given process. This endpoint does not resolve process definitions that are referenced with expressions. Each called process definition contains a list of call activity ids, which specifies the call activities that are calling that process. This endpoint does not resolve references to case definitions.
         * @summary Get Static Called Process Definitions
         * @param {string} id The id of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStaticCalledProcessDefinitions(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<CalledProcessDefinitionDto>>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).getStaticCalledProcessDefinitions(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Restarts process instances that were canceled or terminated synchronously. Can also restart completed process instances. It will create a new instance using the original instance information. To execute the restart asynchronously, use the [Restart Process Instance Async](https://docs.camunda.org/manual/7.18/reference/rest/process-definition/post-restart-process-instance-async/) method.  For more information about the difference between synchronous and asynchronous execution, please refer to the related section of the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/process-instance-restart/#execution).
         * @summary Restart Process Instance
         * @param {string} id The id of the process definition of the process instances to restart.
         * @param {RestartProcessInstanceDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restartProcessInstance(id: string, body?: RestartProcessInstanceDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).restartProcessInstance(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Restarts process instances that were canceled or terminated asynchronously. Can also restart completed process instances. It will create a new instance using the original instance information. To execute the restart asynchronously, use the [Restart Process Instance](https://docs.camunda.org/manual/7.18/reference/rest/process-definition/post-restart-process-instance-sync/) method.  For more information about the difference between synchronous and asynchronous execution, please refer to the related section of the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/process-instance-restart/#execution).
         * @summary Restart Process Instance Async
         * @param {string} id The id of the process definition of the process instances to restart.
         * @param {RestartProcessInstanceDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restartProcessInstanceAsyncOperation(id: string, body?: RestartProcessInstanceDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<BatchDto>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).restartProcessInstanceAsyncOperation(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Instantiates a given process definition. Process variables and business key may be supplied in the request body.
         * @summary Start Instance
         * @param {string} id The id of the process definition to be retrieved.
         * @param {StartProcessInstanceDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startProcessInstance(id: string, body?: StartProcessInstanceDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ProcessInstanceWithVariablesDto>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).startProcessInstance(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Instantiates a given process definition, starts the latest version of the process definition which belongs to no tenant. Process variables and business key may be supplied in the request body.
         * @summary Start Instance
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {StartProcessInstanceDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startProcessInstanceByKey(key: string, body?: StartProcessInstanceDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ProcessInstanceWithVariablesDto>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).startProcessInstanceByKey(key, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Instantiates a given process definition, starts the latest version of the process definition for tenant. Process variables and business key may be supplied in the request body.
         * @summary Start Instance
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {StartProcessInstanceDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startProcessInstanceByKeyAndTenantId(key: string, tenantId: string, body?: StartProcessInstanceDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ProcessInstanceWithVariablesDto>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).startProcessInstanceByKeyAndTenantId(key, tenantId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Starts a process instance using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms).
         * @summary Submit Start Form
         * @param {string} id The id of the process definition to submit the form for.
         * @param {StartProcessInstanceFormDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitForm(id: string, body?: StartProcessInstanceFormDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ProcessInstanceDto>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).submitForm(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Starts the latest version of the process definition which belongs to no tenant using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms).
         * @summary Submit Start Form
         * @param {string} key The key of the process definition to submit the form for.
         * @param {StartProcessInstanceFormDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitFormByKey(key: string, body?: StartProcessInstanceFormDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ProcessInstanceDto>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).submitFormByKey(key, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Starts the latest version of the process definition for a tenant using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms).
         * @summary Submit Start Form
         * @param {string} key The key of the process definition to submit the form for.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {StartProcessInstanceFormDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitFormByKeyAndTenantId(key: string, tenantId: string, body?: StartProcessInstanceFormDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ProcessInstanceDto>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).submitFormByKeyAndTenantId(key, tenantId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates history time to live for process definition. The field is used within [History cleanup](https://docs.camunda.org/manual/7.18/user-guide/process-engine/history/#history-cleanup).
         * @summary Update History Time to Live
         * @param {string} id The id of the process definition to change history time to live.
         * @param {HistoryTimeToLiveDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateHistoryTimeToLiveByProcessDefinitionId(id: string, body?: HistoryTimeToLiveDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).updateHistoryTimeToLiveByProcessDefinitionId(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates history time to live for the latest version of the process definition which belongs to no tenant. The field is used within [History cleanup](https://docs.camunda.org/manual/7.18/user-guide/process-engine/history/#history-cleanup).
         * @summary Update History Time to Live
         * @param {string} key The key of the process definition to change history time to live.
         * @param {HistoryTimeToLiveDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateHistoryTimeToLiveByProcessDefinitionKey(key: string, body?: HistoryTimeToLiveDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).updateHistoryTimeToLiveByProcessDefinitionKey(key, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates history time to live for the latest version of the process definition for a tenant. The field is used within [History cleanup](https://docs.camunda.org/manual/7.18/user-guide/process-engine/history/#history-cleanup).
         * @summary Update History Time to Live
         * @param {string} key The key of the process definition to change history time to live.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {HistoryTimeToLiveDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId(key: string, tenantId: string, body?: HistoryTimeToLiveDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId(key, tenantId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Activates or suspends process definitions with the given process definition key.
         * @summary Activate/Suspend By Key
         * @param {ProcessDefinitionSuspensionStateDto} [body] **Note**: Unallowed property is &#x60;processDefinitionId&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProcessDefinitionSuspensionState(body?: ProcessDefinitionSuspensionStateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).updateProcessDefinitionSuspensionState(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Activates or suspends a given process definition by id.
         * @summary Activate/Suspend By Id
         * @param {string} id The id of the process definition to activate or suspend.
         * @param {ProcessDefinitionSuspensionStateDto} [body] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProcessDefinitionSuspensionStateById(id: string, body?: ProcessDefinitionSuspensionStateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).updateProcessDefinitionSuspensionStateById(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Activates or suspends a given process definition by latest version of process definition key which belongs to no tenant.
         * @summary Activate/Suspend by Id
         * @param {string} key The key of the process definition (the latest version thereof) to be activated/suspended.
         * @param {ProcessDefinitionSuspensionStateDto} [body] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProcessDefinitionSuspensionStateByKey(key: string, body?: ProcessDefinitionSuspensionStateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).updateProcessDefinitionSuspensionStateByKey(key, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Activates or suspends a given process definition by the latest version of the process definition for tenant.
         * @summary Activate/Suspend by Id
         * @param {string} key The key of the process definition (the latest version thereof) to be activated/suspended.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {ProcessDefinitionSuspensionStateDto} [body] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProcessDefinitionSuspensionStateByKeyAndTenantId(key: string, tenantId: string, body?: ProcessDefinitionSuspensionStateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await ProcessDefinitionApiAxiosParamCreator(configuration).updateProcessDefinitionSuspensionStateByKeyAndTenantId(key, tenantId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ProcessDefinitionApi - factory interface
 * @export
 */
export const ProcessDefinitionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Deletes a running process instance by id.
         * @summary Delete
         * @param {string} id The id of the process definition to be deleted.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProcessDefinition(id: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return ProcessDefinitionApiFp(configuration).deleteProcessDefinition(id, cascade, skipCustomListeners, skipIoMappings, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes process definitions by a given key which belong to no tenant id.
         * @summary Delete By Key
         * @param {string} key The key of the process definitions to be deleted.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProcessDefinitionsByKey(key: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return ProcessDefinitionApiFp(configuration).deleteProcessDefinitionsByKey(key, cascade, skipCustomListeners, skipIoMappings, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes process definitions by a given key and which belong to a tenant id.
         * @summary Delete By Key
         * @param {string} key The key of the process definitions to be deleted.
         * @param {string} tenantId The id of the tenant the process definitions belong to.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProcessDefinitionsByKeyAndTenantId(key: string, tenantId: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return ProcessDefinitionApiFp(configuration).deleteProcessDefinitionsByKeyAndTenantId(key, tenantId, cascade, skipCustomListeners, skipIoMappings, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves runtime statistics of a given process definition, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Activity Instance Statistics
         * @param {string} id The id of the process definition.
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivityStatistics(id: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<ActivityStatisticsResultDto>>> {
            return ProcessDefinitionApiFp(configuration).getActivityStatistics(id, failedJobs, incidents, incidentsForType, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves runtime statistics of the latest version of the given process definition which belongs to no tenant, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Activity Instance Statistics
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivityStatisticsByProcessDefinitionKey(key: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<ActivityStatisticsResultDto>>> {
            return ProcessDefinitionApiFp(configuration).getActivityStatisticsByProcessDefinitionKey(key, failedJobs, incidents, incidentsForType, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves runtime statistics of the latest version of the given process definition for a tenant, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Activity Instance Statistics
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivityStatisticsByProcessDefinitionKeyAndTenantId(key: string, tenantId: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<ActivityStatisticsResultDto>>> {
            return ProcessDefinitionApiFp(configuration).getActivityStatisticsByProcessDefinitionKeyAndTenantId(key, tenantId, failedJobs, incidents, incidentsForType, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Start Form
         * @param {string} id The id of the process definition to get the deployed start form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeployedStartForm(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Blob>> {
            return ProcessDefinitionApiFp(configuration).getDeployedStartForm(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeployedStartFormByKey(key: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Blob>> {
            return ProcessDefinitionApiFp(configuration).getDeployedStartFormByKey(key, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definitions belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeployedStartFormByKeyAndTenantId(key: string, tenantId: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Blob>> {
            return ProcessDefinitionApiFp(configuration).getDeployedStartFormByKeyAndTenantId(key, tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the latest version of the process definition for tenant according to the `ProcessDefinition` interface in the engine.
         * @summary Get
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestProcessDefinitionByTenantId(key: string, tenantId: string, options?: AxiosRequestConfig): Promise<AxiosResponse<ProcessDefinitionDto>> {
            return ProcessDefinitionApiFp(configuration).getLatestProcessDefinitionByTenantId(key, tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a process definition according to the `ProcessDefinition` interface in the engine.
         * @summary Get
         * @param {string} id The id of the process definition to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinition(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<ProcessDefinitionDto>> {
            return ProcessDefinitionApiFp(configuration).getProcessDefinition(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the BPMN 2.0 XML of a process definition.
         * @summary Get XML
         * @param {string} id The id of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitionBpmn20Xml(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<ProcessDefinitionDiagramDto>> {
            return ProcessDefinitionApiFp(configuration).getProcessDefinitionBpmn20Xml(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves latest version the BPMN 2.0 XML of a process definition.
         * @summary Get XML
         * @param {string} key The key of the process definition (the latest version thereof) whose XML should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitionBpmn20XmlByKey(key: string, options?: AxiosRequestConfig): Promise<AxiosResponse<ProcessDefinitionDiagramDto>> {
            return ProcessDefinitionApiFp(configuration).getProcessDefinitionBpmn20XmlByKey(key, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves latest version the BPMN 2.0 XML of a process definition. Returns the XML for the latest version of the process definition for tenant.
         * @summary Get XML
         * @param {string} key The key of the process definition (the latest version thereof) whose XML should be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitionBpmn20XmlByKeyAndTenantId(key: string, tenantId: string, options?: AxiosRequestConfig): Promise<AxiosResponse<ProcessDefinitionDiagramDto>> {
            return ProcessDefinitionApiFp(configuration).getProcessDefinitionBpmn20XmlByKeyAndTenantId(key, tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the latest version of the process definition which belongs to no tenant according to the `ProcessDefinition` interface in the engine.
         * @summary Get
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitionByKey(key: string, options?: AxiosRequestConfig): Promise<AxiosResponse<ProcessDefinitionDto>> {
            return ProcessDefinitionApiFp(configuration).getProcessDefinitionByKey(key, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the diagram of a process definition.  If the process definition's deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
         * @summary Get Diagram
         * @param {string} id The id of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitionDiagram(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Blob>> {
            return ProcessDefinitionApiFp(configuration).getProcessDefinitionDiagram(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the diagram for the latest version of the process definition which belongs to no tenant.  If the process definition's deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
         * @summary Get Diagram
         * @param {string} key The key of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitionDiagramByKey(key: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Blob>> {
            return ProcessDefinitionApiFp(configuration).getProcessDefinitionDiagramByKey(key, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the diagram for the latest version of the process definition for tenant.  If the process definition's deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
         * @summary Get Diagram
         * @param {string} key The key of the process definition.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitionDiagramByKeyAndTenantId(key: string, tenantId: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Blob>> {
            return ProcessDefinitionApiFp(configuration).getProcessDefinitionDiagramByKeyAndTenantId(key, tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves runtime statistics of the process engine, grouped by process definitions. These statistics include the number of running process instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Process Instance Statistics
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {boolean} [rootIncidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of root incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60; or &#x60;incidents&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitionStatistics(failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, rootIncidents?: boolean, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<ProcessDefinitionStatisticsResultDto>>> {
            return ProcessDefinitionApiFp(configuration).getProcessDefinitionStatistics(failedJobs, incidents, incidentsForType, rootIncidents, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for process definitions that fulfill given parameters. Parameters may be the properties of  process definitions, such as the name, key or version. The size of the result set can be retrieved by using the [Get Definition Count](https://docs.camunda.org/manual/7.18/reference/rest/process-definition/get-query-count/) method.
         * @summary Get List
         * @param {string} [processDefinitionId] Filter by process definition id.
         * @param {string} [processDefinitionIdIn] Filter by a comma-separated list of process definition ids.
         * @param {string} [name] Filter by process definition name.
         * @param {string} [nameLike] Filter by process definition names that the parameter is a substring of.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {Date} [deployedAfter] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {Date} [deployedAt] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [key] Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match.
         * @param {string} [keysIn] Filter by a comma-separated list of process definition keys.
         * @param {string} [keyLike] Filter by process definition keys that the parameter is a substring of.
         * @param {string} [category] Filter by process definition category. Exact match.
         * @param {string} [categoryLike] Filter by process definition categories that the parameter is a substring of.
         * @param {number} [version] Filter by process definition version.
         * @param {boolean} [latestVersion] Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [resourceName] Filter by the name of the process definition resource. Exact match.
         * @param {string} [resourceNameLike] Filter by names of those process definition resources that the parameter is a substring of.
         * @param {string} [startableBy] Filter by a user name who is allowed to start the process.
         * @param {boolean} [active] Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior.
         * @param {boolean} [includeProcessDefinitionsWithoutTenantId] Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [versionTag] Filter by the version tag.
         * @param {string} [versionTagLike] Filter by the version tag that the parameter is a substring of.
         * @param {boolean} [withoutVersionTag] Only include process definitions without a &#x60;versionTag&#x60;.
         * @param {boolean} [startableInTasklist] Filter by process definitions which are startable in Tasklist..
         * @param {boolean} [notStartableInTasklist] Filter by process definitions which are not startable in Tasklist.
         * @param {boolean} [startablePermissionCheck] Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn&#x27;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitions(processDefinitionId?: string, processDefinitionIdIn?: string, name?: string, nameLike?: string, deploymentId?: string, deployedAfter?: Date, deployedAt?: Date, key?: string, keysIn?: string, keyLike?: string, category?: string, categoryLike?: string, version?: number, latestVersion?: boolean, resourceName?: string, resourceNameLike?: string, startableBy?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeProcessDefinitionsWithoutTenantId?: boolean, versionTag?: string, versionTagLike?: string, withoutVersionTag?: boolean, startableInTasklist?: boolean, notStartableInTasklist?: boolean, startablePermissionCheck?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<ProcessDefinitionDto>>> {
            return ProcessDefinitionApiFp(configuration).getProcessDefinitions(processDefinitionId, processDefinitionIdIn, name, nameLike, deploymentId, deployedAfter, deployedAt, key, keysIn, keyLike, category, categoryLike, version, latestVersion, resourceName, resourceNameLike, startableBy, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, includeProcessDefinitionsWithoutTenantId, versionTag, versionTagLike, withoutVersionTag, startableInTasklist, notStartableInTasklist, startablePermissionCheck, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(axios, basePath));
        },
        /**
         * Requests the number of process definitions that fulfill the query criteria. Takes the same filtering parameters as the [Get Definitions](https://docs.camunda.org/manual/7.18/reference/rest/process-definition/get-query/) method.
         * @summary Get List Count
         * @param {string} [processDefinitionId] Filter by process definition id.
         * @param {string} [processDefinitionIdIn] Filter by a comma-separated list of process definition ids.
         * @param {string} [name] Filter by process definition name.
         * @param {string} [nameLike] Filter by process definition names that the parameter is a substring of.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {Date} [deployedAfter] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {Date} [deployedAt] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [key] Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match.
         * @param {string} [keysIn] Filter by a comma-separated list of process definition keys.
         * @param {string} [keyLike] Filter by process definition keys that the parameter is a substring of.
         * @param {string} [category] Filter by process definition category. Exact match.
         * @param {string} [categoryLike] Filter by process definition categories that the parameter is a substring of.
         * @param {number} [version] Filter by process definition version.
         * @param {boolean} [latestVersion] Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [resourceName] Filter by the name of the process definition resource. Exact match.
         * @param {string} [resourceNameLike] Filter by names of those process definition resources that the parameter is a substring of.
         * @param {string} [startableBy] Filter by a user name who is allowed to start the process.
         * @param {boolean} [active] Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior.
         * @param {boolean} [includeProcessDefinitionsWithoutTenantId] Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [versionTag] Filter by the version tag.
         * @param {string} [versionTagLike] Filter by the version tag that the parameter is a substring of.
         * @param {boolean} [withoutVersionTag] Only include process definitions without a &#x60;versionTag&#x60;.
         * @param {boolean} [startableInTasklist] Filter by process definitions which are startable in Tasklist..
         * @param {boolean} [notStartableInTasklist] Filter by process definitions which are not startable in Tasklist.
         * @param {boolean} [startablePermissionCheck] Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn&#x27;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessDefinitionsCount(processDefinitionId?: string, processDefinitionIdIn?: string, name?: string, nameLike?: string, deploymentId?: string, deployedAfter?: Date, deployedAt?: Date, key?: string, keysIn?: string, keyLike?: string, category?: string, categoryLike?: string, version?: number, latestVersion?: boolean, resourceName?: string, resourceNameLike?: string, startableBy?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeProcessDefinitionsWithoutTenantId?: boolean, versionTag?: string, versionTagLike?: string, withoutVersionTag?: boolean, startableInTasklist?: boolean, notStartableInTasklist?: boolean, startablePermissionCheck?: boolean, options?: AxiosRequestConfig): Promise<AxiosResponse<CountResultDto>> {
            return ProcessDefinitionApiFp(configuration).getProcessDefinitionsCount(processDefinitionId, processDefinitionIdIn, name, nameLike, deploymentId, deployedAfter, deployedAt, key, keysIn, keyLike, category, categoryLike, version, latestVersion, resourceName, resourceNameLike, startableBy, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, includeProcessDefinitionsWithoutTenantId, versionTag, versionTagLike, withoutVersionTag, startableInTasklist, notStartableInTasklist, startablePermissionCheck, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the rendered form for a process definition. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Start Form
         * @param {string} id The id of the process definition to get the rendered start form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRenderedStartForm(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Blob>> {
            return ProcessDefinitionApiFp(configuration).getRenderedStartForm(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves  the rendered form for the latest version of the process definition which belongs to no tenant. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRenderedStartFormByKey(key: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Blob>> {
            return ProcessDefinitionApiFp(configuration).getRenderedStartFormByKey(key, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves  the rendered form for the latest version of the process definition for a tenant. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRenderedStartFormByKeyAndTenantId(key: string, tenantId: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Blob>> {
            return ProcessDefinitionApiFp(configuration).getRenderedStartFormByKeyAndTenantId(key, tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the key of the start form for a process definition. The form key corresponds to the `FormData#formKey` property in the engine.
         * @summary Get Start Form Key
         * @param {string} id The id of the process definition to get the start form key for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStartForm(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<FormDto>> {
            return ProcessDefinitionApiFp(configuration).getStartForm(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the key of the start form for the latest version of the process definition which belongs to no tenant. The form key corresponds to the `FormData#formKey` property in the engine.
         * @summary Get Start Form Key
         * @param {string} key The key of the process definition (the latest version thereof) for which the form key is to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStartFormByKey(key: string, options?: AxiosRequestConfig): Promise<AxiosResponse<FormDto>> {
            return ProcessDefinitionApiFp(configuration).getStartFormByKey(key, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the key of the start form for the latest version of the process definition for a tenant. The form key corresponds to the `FormData#formKey` property in the engine.
         * @summary Get Start Form Key
         * @param {string} key The key of the process definition (the latest version thereof) for which the form key is to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStartFormByKeyAndTenantId(key: string, tenantId: string, options?: AxiosRequestConfig): Promise<AxiosResponse<FormDto>> {
            return ProcessDefinitionApiFp(configuration).getStartFormByKeyAndTenantId(key, tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the start form variables for a process definition (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Start Form Variables
         * @param {string} id The id of the process definition to retrieve the variables for.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStartFormVariables(id: string, variableNames?: string, deserializeValues?: boolean, options?: AxiosRequestConfig): Promise<AxiosResponse<{ [key: string]: VariableValueDto; }>> {
            return ProcessDefinitionApiFp(configuration).getStartFormVariables(id, variableNames, deserializeValues, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the start form variables for the latest process definition which belongs to no tenant (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Start Form Variables
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStartFormVariablesByKey(key: string, variableNames?: string, deserializeValues?: boolean, options?: AxiosRequestConfig): Promise<AxiosResponse<{ [key: string]: VariableValueDto; }>> {
            return ProcessDefinitionApiFp(configuration).getStartFormVariablesByKey(key, variableNames, deserializeValues, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the start form variables for the latest process definition for a tenant (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Start Form Variables
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStartFormVariablesByKeyAndTenantId(key: string, tenantId: string, variableNames?: string, deserializeValues?: boolean, options?: AxiosRequestConfig): Promise<AxiosResponse<{ [key: string]: VariableValueDto; }>> {
            return ProcessDefinitionApiFp(configuration).getStartFormVariablesByKeyAndTenantId(key, tenantId, variableNames, deserializeValues, options).then((request) => request(axios, basePath));
        },
        /**
         * For the given process, returns a list of called process definitions corresponding to the `CalledProcessDefinition` interface in the engine. The list contains all process definitions that are referenced statically by call activities in the given process. This endpoint does not resolve process definitions that are referenced with expressions. Each called process definition contains a list of call activity ids, which specifies the call activities that are calling that process. This endpoint does not resolve references to case definitions.
         * @summary Get Static Called Process Definitions
         * @param {string} id The id of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStaticCalledProcessDefinitions(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<CalledProcessDefinitionDto>>> {
            return ProcessDefinitionApiFp(configuration).getStaticCalledProcessDefinitions(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Restarts process instances that were canceled or terminated synchronously. Can also restart completed process instances. It will create a new instance using the original instance information. To execute the restart asynchronously, use the [Restart Process Instance Async](https://docs.camunda.org/manual/7.18/reference/rest/process-definition/post-restart-process-instance-async/) method.  For more information about the difference between synchronous and asynchronous execution, please refer to the related section of the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/process-instance-restart/#execution).
         * @summary Restart Process Instance
         * @param {string} id The id of the process definition of the process instances to restart.
         * @param {RestartProcessInstanceDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restartProcessInstance(id: string, body?: RestartProcessInstanceDto, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return ProcessDefinitionApiFp(configuration).restartProcessInstance(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Restarts process instances that were canceled or terminated asynchronously. Can also restart completed process instances. It will create a new instance using the original instance information. To execute the restart asynchronously, use the [Restart Process Instance](https://docs.camunda.org/manual/7.18/reference/rest/process-definition/post-restart-process-instance-sync/) method.  For more information about the difference between synchronous and asynchronous execution, please refer to the related section of the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/process-instance-restart/#execution).
         * @summary Restart Process Instance Async
         * @param {string} id The id of the process definition of the process instances to restart.
         * @param {RestartProcessInstanceDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restartProcessInstanceAsyncOperation(id: string, body?: RestartProcessInstanceDto, options?: AxiosRequestConfig): Promise<AxiosResponse<BatchDto>> {
            return ProcessDefinitionApiFp(configuration).restartProcessInstanceAsyncOperation(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Instantiates a given process definition. Process variables and business key may be supplied in the request body.
         * @summary Start Instance
         * @param {string} id The id of the process definition to be retrieved.
         * @param {StartProcessInstanceDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startProcessInstance(id: string, body?: StartProcessInstanceDto, options?: AxiosRequestConfig): Promise<AxiosResponse<ProcessInstanceWithVariablesDto>> {
            return ProcessDefinitionApiFp(configuration).startProcessInstance(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Instantiates a given process definition, starts the latest version of the process definition which belongs to no tenant. Process variables and business key may be supplied in the request body.
         * @summary Start Instance
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {StartProcessInstanceDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startProcessInstanceByKey(key: string, body?: StartProcessInstanceDto, options?: AxiosRequestConfig): Promise<AxiosResponse<ProcessInstanceWithVariablesDto>> {
            return ProcessDefinitionApiFp(configuration).startProcessInstanceByKey(key, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Instantiates a given process definition, starts the latest version of the process definition for tenant. Process variables and business key may be supplied in the request body.
         * @summary Start Instance
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {StartProcessInstanceDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startProcessInstanceByKeyAndTenantId(key: string, tenantId: string, body?: StartProcessInstanceDto, options?: AxiosRequestConfig): Promise<AxiosResponse<ProcessInstanceWithVariablesDto>> {
            return ProcessDefinitionApiFp(configuration).startProcessInstanceByKeyAndTenantId(key, tenantId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Starts a process instance using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms).
         * @summary Submit Start Form
         * @param {string} id The id of the process definition to submit the form for.
         * @param {StartProcessInstanceFormDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitForm(id: string, body?: StartProcessInstanceFormDto, options?: AxiosRequestConfig): Promise<AxiosResponse<ProcessInstanceDto>> {
            return ProcessDefinitionApiFp(configuration).submitForm(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Starts the latest version of the process definition which belongs to no tenant using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms).
         * @summary Submit Start Form
         * @param {string} key The key of the process definition to submit the form for.
         * @param {StartProcessInstanceFormDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitFormByKey(key: string, body?: StartProcessInstanceFormDto, options?: AxiosRequestConfig): Promise<AxiosResponse<ProcessInstanceDto>> {
            return ProcessDefinitionApiFp(configuration).submitFormByKey(key, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Starts the latest version of the process definition for a tenant using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms).
         * @summary Submit Start Form
         * @param {string} key The key of the process definition to submit the form for.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {StartProcessInstanceFormDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitFormByKeyAndTenantId(key: string, tenantId: string, body?: StartProcessInstanceFormDto, options?: AxiosRequestConfig): Promise<AxiosResponse<ProcessInstanceDto>> {
            return ProcessDefinitionApiFp(configuration).submitFormByKeyAndTenantId(key, tenantId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates history time to live for process definition. The field is used within [History cleanup](https://docs.camunda.org/manual/7.18/user-guide/process-engine/history/#history-cleanup).
         * @summary Update History Time to Live
         * @param {string} id The id of the process definition to change history time to live.
         * @param {HistoryTimeToLiveDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateHistoryTimeToLiveByProcessDefinitionId(id: string, body?: HistoryTimeToLiveDto, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return ProcessDefinitionApiFp(configuration).updateHistoryTimeToLiveByProcessDefinitionId(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates history time to live for the latest version of the process definition which belongs to no tenant. The field is used within [History cleanup](https://docs.camunda.org/manual/7.18/user-guide/process-engine/history/#history-cleanup).
         * @summary Update History Time to Live
         * @param {string} key The key of the process definition to change history time to live.
         * @param {HistoryTimeToLiveDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateHistoryTimeToLiveByProcessDefinitionKey(key: string, body?: HistoryTimeToLiveDto, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return ProcessDefinitionApiFp(configuration).updateHistoryTimeToLiveByProcessDefinitionKey(key, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates history time to live for the latest version of the process definition for a tenant. The field is used within [History cleanup](https://docs.camunda.org/manual/7.18/user-guide/process-engine/history/#history-cleanup).
         * @summary Update History Time to Live
         * @param {string} key The key of the process definition to change history time to live.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {HistoryTimeToLiveDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId(key: string, tenantId: string, body?: HistoryTimeToLiveDto, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return ProcessDefinitionApiFp(configuration).updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId(key, tenantId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Activates or suspends process definitions with the given process definition key.
         * @summary Activate/Suspend By Key
         * @param {ProcessDefinitionSuspensionStateDto} [body] **Note**: Unallowed property is &#x60;processDefinitionId&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProcessDefinitionSuspensionState(body?: ProcessDefinitionSuspensionStateDto, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return ProcessDefinitionApiFp(configuration).updateProcessDefinitionSuspensionState(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Activates or suspends a given process definition by id.
         * @summary Activate/Suspend By Id
         * @param {string} id The id of the process definition to activate or suspend.
         * @param {ProcessDefinitionSuspensionStateDto} [body] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProcessDefinitionSuspensionStateById(id: string, body?: ProcessDefinitionSuspensionStateDto, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return ProcessDefinitionApiFp(configuration).updateProcessDefinitionSuspensionStateById(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Activates or suspends a given process definition by latest version of process definition key which belongs to no tenant.
         * @summary Activate/Suspend by Id
         * @param {string} key The key of the process definition (the latest version thereof) to be activated/suspended.
         * @param {ProcessDefinitionSuspensionStateDto} [body] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProcessDefinitionSuspensionStateByKey(key: string, body?: ProcessDefinitionSuspensionStateDto, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return ProcessDefinitionApiFp(configuration).updateProcessDefinitionSuspensionStateByKey(key, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Activates or suspends a given process definition by the latest version of the process definition for tenant.
         * @summary Activate/Suspend by Id
         * @param {string} key The key of the process definition (the latest version thereof) to be activated/suspended.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {ProcessDefinitionSuspensionStateDto} [body] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProcessDefinitionSuspensionStateByKeyAndTenantId(key: string, tenantId: string, body?: ProcessDefinitionSuspensionStateDto, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return ProcessDefinitionApiFp(configuration).updateProcessDefinitionSuspensionStateByKeyAndTenantId(key, tenantId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProcessDefinitionApi - object-oriented interface
 * @export
 * @class ProcessDefinitionApi
 * @extends {BaseAPI}
 */
export class ProcessDefinitionApi extends BaseAPI {
    /**
     * Deletes a running process instance by id.
     * @summary Delete
     * @param {string} id The id of the process definition to be deleted.
     * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
     * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
     * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async deleteProcessDefinition(id: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return ProcessDefinitionApiFp(this.configuration).deleteProcessDefinition(id, cascade, skipCustomListeners, skipIoMappings, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes process definitions by a given key which belong to no tenant id.
     * @summary Delete By Key
     * @param {string} key The key of the process definitions to be deleted.
     * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
     * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
     * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async deleteProcessDefinitionsByKey(key: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return ProcessDefinitionApiFp(this.configuration).deleteProcessDefinitionsByKey(key, cascade, skipCustomListeners, skipIoMappings, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes process definitions by a given key and which belong to a tenant id.
     * @summary Delete By Key
     * @param {string} key The key of the process definitions to be deleted.
     * @param {string} tenantId The id of the tenant the process definitions belong to.
     * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
     * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
     * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async deleteProcessDefinitionsByKeyAndTenantId(key: string, tenantId: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return ProcessDefinitionApiFp(this.configuration).deleteProcessDefinitionsByKeyAndTenantId(key, tenantId, cascade, skipCustomListeners, skipIoMappings, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves runtime statistics of a given process definition, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
     * @summary Get Activity Instance Statistics
     * @param {string} id The id of the process definition.
     * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
     * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
     * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async getActivityStatistics(id: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<ActivityStatisticsResultDto>>> {
        return ProcessDefinitionApiFp(this.configuration).getActivityStatistics(id, failedJobs, incidents, incidentsForType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves runtime statistics of the latest version of the given process definition which belongs to no tenant, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
     * @summary Get Activity Instance Statistics
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
     * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
     * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async getActivityStatisticsByProcessDefinitionKey(key: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<ActivityStatisticsResultDto>>> {
        return ProcessDefinitionApiFp(this.configuration).getActivityStatisticsByProcessDefinitionKey(key, failedJobs, incidents, incidentsForType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves runtime statistics of the latest version of the given process definition for a tenant, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
     * @summary Get Activity Instance Statistics
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
     * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
     * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async getActivityStatisticsByProcessDefinitionKeyAndTenantId(key: string, tenantId: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<ActivityStatisticsResultDto>>> {
        return ProcessDefinitionApiFp(this.configuration).getActivityStatisticsByProcessDefinitionKeyAndTenantId(key, tenantId, failedJobs, incidents, incidentsForType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#embedded-task-forms).
     * @summary Get Deployed Start Form
     * @param {string} id The id of the process definition to get the deployed start form for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async getDeployedStartForm(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Blob>> {
        return ProcessDefinitionApiFp(this.configuration).getDeployedStartForm(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#embedded-task-forms).
     * @summary Get Deployed Start Form
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async getDeployedStartFormByKey(key: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Blob>> {
        return ProcessDefinitionApiFp(this.configuration).getDeployedStartFormByKey(key, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#embedded-task-forms).
     * @summary Get Deployed Start Form
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {string} tenantId The id of the tenant the process definitions belong to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async getDeployedStartFormByKeyAndTenantId(key: string, tenantId: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Blob>> {
        return ProcessDefinitionApiFp(this.configuration).getDeployedStartFormByKeyAndTenantId(key, tenantId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the latest version of the process definition for tenant according to the `ProcessDefinition` interface in the engine.
     * @summary Get
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async getLatestProcessDefinitionByTenantId(key: string, tenantId: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<ProcessDefinitionDto>> {
        return ProcessDefinitionApiFp(this.configuration).getLatestProcessDefinitionByTenantId(key, tenantId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a process definition according to the `ProcessDefinition` interface in the engine.
     * @summary Get
     * @param {string} id The id of the process definition to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async getProcessDefinition(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<ProcessDefinitionDto>> {
        return ProcessDefinitionApiFp(this.configuration).getProcessDefinition(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the BPMN 2.0 XML of a process definition.
     * @summary Get XML
     * @param {string} id The id of the process definition.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async getProcessDefinitionBpmn20Xml(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<ProcessDefinitionDiagramDto>> {
        return ProcessDefinitionApiFp(this.configuration).getProcessDefinitionBpmn20Xml(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves latest version the BPMN 2.0 XML of a process definition.
     * @summary Get XML
     * @param {string} key The key of the process definition (the latest version thereof) whose XML should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async getProcessDefinitionBpmn20XmlByKey(key: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<ProcessDefinitionDiagramDto>> {
        return ProcessDefinitionApiFp(this.configuration).getProcessDefinitionBpmn20XmlByKey(key, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves latest version the BPMN 2.0 XML of a process definition. Returns the XML for the latest version of the process definition for tenant.
     * @summary Get XML
     * @param {string} key The key of the process definition (the latest version thereof) whose XML should be retrieved.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async getProcessDefinitionBpmn20XmlByKeyAndTenantId(key: string, tenantId: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<ProcessDefinitionDiagramDto>> {
        return ProcessDefinitionApiFp(this.configuration).getProcessDefinitionBpmn20XmlByKeyAndTenantId(key, tenantId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the latest version of the process definition which belongs to no tenant according to the `ProcessDefinition` interface in the engine.
     * @summary Get
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async getProcessDefinitionByKey(key: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<ProcessDefinitionDto>> {
        return ProcessDefinitionApiFp(this.configuration).getProcessDefinitionByKey(key, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the diagram of a process definition.  If the process definition's deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
     * @summary Get Diagram
     * @param {string} id The id of the process definition.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async getProcessDefinitionDiagram(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Blob>> {
        return ProcessDefinitionApiFp(this.configuration).getProcessDefinitionDiagram(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the diagram for the latest version of the process definition which belongs to no tenant.  If the process definition's deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
     * @summary Get Diagram
     * @param {string} key The key of the process definition.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async getProcessDefinitionDiagramByKey(key: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Blob>> {
        return ProcessDefinitionApiFp(this.configuration).getProcessDefinitionDiagramByKey(key, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the diagram for the latest version of the process definition for tenant.  If the process definition's deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
     * @summary Get Diagram
     * @param {string} key The key of the process definition.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async getProcessDefinitionDiagramByKeyAndTenantId(key: string, tenantId: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Blob>> {
        return ProcessDefinitionApiFp(this.configuration).getProcessDefinitionDiagramByKeyAndTenantId(key, tenantId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves runtime statistics of the process engine, grouped by process definitions. These statistics include the number of running process instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
     * @summary Get Process Instance Statistics
     * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
     * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
     * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param {boolean} [rootIncidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of root incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60; or &#x60;incidents&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async getProcessDefinitionStatistics(failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, rootIncidents?: boolean, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<ProcessDefinitionStatisticsResultDto>>> {
        return ProcessDefinitionApiFp(this.configuration).getProcessDefinitionStatistics(failedJobs, incidents, incidentsForType, rootIncidents, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Queries for process definitions that fulfill given parameters. Parameters may be the properties of  process definitions, such as the name, key or version. The size of the result set can be retrieved by using the [Get Definition Count](https://docs.camunda.org/manual/7.18/reference/rest/process-definition/get-query-count/) method.
     * @summary Get List
     * @param {string} [processDefinitionId] Filter by process definition id.
     * @param {string} [processDefinitionIdIn] Filter by a comma-separated list of process definition ids.
     * @param {string} [name] Filter by process definition name.
     * @param {string} [nameLike] Filter by process definition names that the parameter is a substring of.
     * @param {string} [deploymentId] Filter by the deployment the id belongs to.
     * @param {Date} [deployedAfter] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
     * @param {Date} [deployedAt] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
     * @param {string} [key] Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match.
     * @param {string} [keysIn] Filter by a comma-separated list of process definition keys.
     * @param {string} [keyLike] Filter by process definition keys that the parameter is a substring of.
     * @param {string} [category] Filter by process definition category. Exact match.
     * @param {string} [categoryLike] Filter by process definition categories that the parameter is a substring of.
     * @param {number} [version] Filter by process definition version.
     * @param {boolean} [latestVersion] Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [resourceName] Filter by the name of the process definition resource. Exact match.
     * @param {string} [resourceNameLike] Filter by names of those process definition resources that the parameter is a substring of.
     * @param {string} [startableBy] Filter by a user name who is allowed to start the process.
     * @param {boolean} [active] Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [suspended] Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [incidentId] Filter by the incident id.
     * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param {string} [incidentMessage] Filter by the incident message. Exact match.
     * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
     * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids.
     * @param {boolean} [withoutTenantId] Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior.
     * @param {boolean} [includeProcessDefinitionsWithoutTenantId] Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [versionTag] Filter by the version tag.
     * @param {string} [versionTagLike] Filter by the version tag that the parameter is a substring of.
     * @param {boolean} [withoutVersionTag] Only include process definitions without a &#x60;versionTag&#x60;.
     * @param {boolean} [startableInTasklist] Filter by process definitions which are startable in Tasklist..
     * @param {boolean} [notStartableInTasklist] Filter by process definitions which are not startable in Tasklist.
     * @param {boolean} [startablePermissionCheck] Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn&#x27;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level
     * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async getProcessDefinitions(processDefinitionId?: string, processDefinitionIdIn?: string, name?: string, nameLike?: string, deploymentId?: string, deployedAfter?: Date, deployedAt?: Date, key?: string, keysIn?: string, keyLike?: string, category?: string, categoryLike?: string, version?: number, latestVersion?: boolean, resourceName?: string, resourceNameLike?: string, startableBy?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeProcessDefinitionsWithoutTenantId?: boolean, versionTag?: string, versionTagLike?: string, withoutVersionTag?: boolean, startableInTasklist?: boolean, notStartableInTasklist?: boolean, startablePermissionCheck?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<ProcessDefinitionDto>>> {
        return ProcessDefinitionApiFp(this.configuration).getProcessDefinitions(processDefinitionId, processDefinitionIdIn, name, nameLike, deploymentId, deployedAfter, deployedAt, key, keysIn, keyLike, category, categoryLike, version, latestVersion, resourceName, resourceNameLike, startableBy, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, includeProcessDefinitionsWithoutTenantId, versionTag, versionTagLike, withoutVersionTag, startableInTasklist, notStartableInTasklist, startablePermissionCheck, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requests the number of process definitions that fulfill the query criteria. Takes the same filtering parameters as the [Get Definitions](https://docs.camunda.org/manual/7.18/reference/rest/process-definition/get-query/) method.
     * @summary Get List Count
     * @param {string} [processDefinitionId] Filter by process definition id.
     * @param {string} [processDefinitionIdIn] Filter by a comma-separated list of process definition ids.
     * @param {string} [name] Filter by process definition name.
     * @param {string} [nameLike] Filter by process definition names that the parameter is a substring of.
     * @param {string} [deploymentId] Filter by the deployment the id belongs to.
     * @param {Date} [deployedAfter] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
     * @param {Date} [deployedAt] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
     * @param {string} [key] Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match.
     * @param {string} [keysIn] Filter by a comma-separated list of process definition keys.
     * @param {string} [keyLike] Filter by process definition keys that the parameter is a substring of.
     * @param {string} [category] Filter by process definition category. Exact match.
     * @param {string} [categoryLike] Filter by process definition categories that the parameter is a substring of.
     * @param {number} [version] Filter by process definition version.
     * @param {boolean} [latestVersion] Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [resourceName] Filter by the name of the process definition resource. Exact match.
     * @param {string} [resourceNameLike] Filter by names of those process definition resources that the parameter is a substring of.
     * @param {string} [startableBy] Filter by a user name who is allowed to start the process.
     * @param {boolean} [active] Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [suspended] Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [incidentId] Filter by the incident id.
     * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param {string} [incidentMessage] Filter by the incident message. Exact match.
     * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
     * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids.
     * @param {boolean} [withoutTenantId] Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior.
     * @param {boolean} [includeProcessDefinitionsWithoutTenantId] Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [versionTag] Filter by the version tag.
     * @param {string} [versionTagLike] Filter by the version tag that the parameter is a substring of.
     * @param {boolean} [withoutVersionTag] Only include process definitions without a &#x60;versionTag&#x60;.
     * @param {boolean} [startableInTasklist] Filter by process definitions which are startable in Tasklist..
     * @param {boolean} [notStartableInTasklist] Filter by process definitions which are not startable in Tasklist.
     * @param {boolean} [startablePermissionCheck] Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn&#x27;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async getProcessDefinitionsCount(processDefinitionId?: string, processDefinitionIdIn?: string, name?: string, nameLike?: string, deploymentId?: string, deployedAfter?: Date, deployedAt?: Date, key?: string, keysIn?: string, keyLike?: string, category?: string, categoryLike?: string, version?: number, latestVersion?: boolean, resourceName?: string, resourceNameLike?: string, startableBy?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeProcessDefinitionsWithoutTenantId?: boolean, versionTag?: string, versionTagLike?: string, withoutVersionTag?: boolean, startableInTasklist?: boolean, notStartableInTasklist?: boolean, startablePermissionCheck?: boolean, options?: AxiosRequestConfig) : Promise<AxiosResponse<CountResultDto>> {
        return ProcessDefinitionApiFp(this.configuration).getProcessDefinitionsCount(processDefinitionId, processDefinitionIdIn, name, nameLike, deploymentId, deployedAfter, deployedAt, key, keysIn, keyLike, category, categoryLike, version, latestVersion, resourceName, resourceNameLike, startableBy, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, includeProcessDefinitionsWithoutTenantId, versionTag, versionTagLike, withoutVersionTag, startableInTasklist, notStartableInTasklist, startablePermissionCheck, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the rendered form for a process definition. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms).
     * @summary Get Rendered Start Form
     * @param {string} id The id of the process definition to get the rendered start form for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async getRenderedStartForm(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Blob>> {
        return ProcessDefinitionApiFp(this.configuration).getRenderedStartForm(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves  the rendered form for the latest version of the process definition which belongs to no tenant. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms).
     * @summary Get Rendered Start Form
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async getRenderedStartFormByKey(key: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Blob>> {
        return ProcessDefinitionApiFp(this.configuration).getRenderedStartFormByKey(key, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves  the rendered form for the latest version of the process definition for a tenant. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms).
     * @summary Get Rendered Start Form
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async getRenderedStartFormByKeyAndTenantId(key: string, tenantId: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Blob>> {
        return ProcessDefinitionApiFp(this.configuration).getRenderedStartFormByKeyAndTenantId(key, tenantId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the key of the start form for a process definition. The form key corresponds to the `FormData#formKey` property in the engine.
     * @summary Get Start Form Key
     * @param {string} id The id of the process definition to get the start form key for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async getStartForm(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<FormDto>> {
        return ProcessDefinitionApiFp(this.configuration).getStartForm(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the key of the start form for the latest version of the process definition which belongs to no tenant. The form key corresponds to the `FormData#formKey` property in the engine.
     * @summary Get Start Form Key
     * @param {string} key The key of the process definition (the latest version thereof) for which the form key is to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async getStartFormByKey(key: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<FormDto>> {
        return ProcessDefinitionApiFp(this.configuration).getStartFormByKey(key, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the key of the start form for the latest version of the process definition for a tenant. The form key corresponds to the `FormData#formKey` property in the engine.
     * @summary Get Start Form Key
     * @param {string} key The key of the process definition (the latest version thereof) for which the form key is to be retrieved.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async getStartFormByKeyAndTenantId(key: string, tenantId: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<FormDto>> {
        return ProcessDefinitionApiFp(this.configuration).getStartFormByKeyAndTenantId(key, tenantId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the start form variables for a process definition (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
     * @summary Get Start Form Variables
     * @param {string} id The id of the process definition to retrieve the variables for.
     * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
     * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async getStartFormVariables(id: string, variableNames?: string, deserializeValues?: boolean, options?: AxiosRequestConfig) : Promise<AxiosResponse<{ [key: string]: VariableValueDto; }>> {
        return ProcessDefinitionApiFp(this.configuration).getStartFormVariables(id, variableNames, deserializeValues, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the start form variables for the latest process definition which belongs to no tenant (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
     * @summary Get Start Form Variables
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
     * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async getStartFormVariablesByKey(key: string, variableNames?: string, deserializeValues?: boolean, options?: AxiosRequestConfig) : Promise<AxiosResponse<{ [key: string]: VariableValueDto; }>> {
        return ProcessDefinitionApiFp(this.configuration).getStartFormVariablesByKey(key, variableNames, deserializeValues, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the start form variables for the latest process definition for a tenant (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
     * @summary Get Start Form Variables
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
     * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async getStartFormVariablesByKeyAndTenantId(key: string, tenantId: string, variableNames?: string, deserializeValues?: boolean, options?: AxiosRequestConfig) : Promise<AxiosResponse<{ [key: string]: VariableValueDto; }>> {
        return ProcessDefinitionApiFp(this.configuration).getStartFormVariablesByKeyAndTenantId(key, tenantId, variableNames, deserializeValues, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * For the given process, returns a list of called process definitions corresponding to the `CalledProcessDefinition` interface in the engine. The list contains all process definitions that are referenced statically by call activities in the given process. This endpoint does not resolve process definitions that are referenced with expressions. Each called process definition contains a list of call activity ids, which specifies the call activities that are calling that process. This endpoint does not resolve references to case definitions.
     * @summary Get Static Called Process Definitions
     * @param {string} id The id of the process definition.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async getStaticCalledProcessDefinitions(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<CalledProcessDefinitionDto>>> {
        return ProcessDefinitionApiFp(this.configuration).getStaticCalledProcessDefinitions(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Restarts process instances that were canceled or terminated synchronously. Can also restart completed process instances. It will create a new instance using the original instance information. To execute the restart asynchronously, use the [Restart Process Instance Async](https://docs.camunda.org/manual/7.18/reference/rest/process-definition/post-restart-process-instance-async/) method.  For more information about the difference between synchronous and asynchronous execution, please refer to the related section of the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/process-instance-restart/#execution).
     * @summary Restart Process Instance
     * @param {string} id The id of the process definition of the process instances to restart.
     * @param {RestartProcessInstanceDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async restartProcessInstance(id: string, body?: RestartProcessInstanceDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return ProcessDefinitionApiFp(this.configuration).restartProcessInstance(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Restarts process instances that were canceled or terminated asynchronously. Can also restart completed process instances. It will create a new instance using the original instance information. To execute the restart asynchronously, use the [Restart Process Instance](https://docs.camunda.org/manual/7.18/reference/rest/process-definition/post-restart-process-instance-sync/) method.  For more information about the difference between synchronous and asynchronous execution, please refer to the related section of the [User Guide](https://docs.camunda.org/manual/7.18/user-guide/process-engine/process-instance-restart/#execution).
     * @summary Restart Process Instance Async
     * @param {string} id The id of the process definition of the process instances to restart.
     * @param {RestartProcessInstanceDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async restartProcessInstanceAsyncOperation(id: string, body?: RestartProcessInstanceDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<BatchDto>> {
        return ProcessDefinitionApiFp(this.configuration).restartProcessInstanceAsyncOperation(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Instantiates a given process definition. Process variables and business key may be supplied in the request body.
     * @summary Start Instance
     * @param {string} id The id of the process definition to be retrieved.
     * @param {StartProcessInstanceDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async startProcessInstance(id: string, body?: StartProcessInstanceDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<ProcessInstanceWithVariablesDto>> {
        return ProcessDefinitionApiFp(this.configuration).startProcessInstance(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Instantiates a given process definition, starts the latest version of the process definition which belongs to no tenant. Process variables and business key may be supplied in the request body.
     * @summary Start Instance
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {StartProcessInstanceDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async startProcessInstanceByKey(key: string, body?: StartProcessInstanceDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<ProcessInstanceWithVariablesDto>> {
        return ProcessDefinitionApiFp(this.configuration).startProcessInstanceByKey(key, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Instantiates a given process definition, starts the latest version of the process definition for tenant. Process variables and business key may be supplied in the request body.
     * @summary Start Instance
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {StartProcessInstanceDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async startProcessInstanceByKeyAndTenantId(key: string, tenantId: string, body?: StartProcessInstanceDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<ProcessInstanceWithVariablesDto>> {
        return ProcessDefinitionApiFp(this.configuration).startProcessInstanceByKeyAndTenantId(key, tenantId, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Starts a process instance using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms).
     * @summary Submit Start Form
     * @param {string} id The id of the process definition to submit the form for.
     * @param {StartProcessInstanceFormDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async submitForm(id: string, body?: StartProcessInstanceFormDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<ProcessInstanceDto>> {
        return ProcessDefinitionApiFp(this.configuration).submitForm(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Starts the latest version of the process definition which belongs to no tenant using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms).
     * @summary Submit Start Form
     * @param {string} key The key of the process definition to submit the form for.
     * @param {StartProcessInstanceFormDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async submitFormByKey(key: string, body?: StartProcessInstanceFormDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<ProcessInstanceDto>> {
        return ProcessDefinitionApiFp(this.configuration).submitFormByKey(key, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Starts the latest version of the process definition for a tenant using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.18/user-guide/task-forms/#generated-task-forms).
     * @summary Submit Start Form
     * @param {string} key The key of the process definition to submit the form for.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {StartProcessInstanceFormDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async submitFormByKeyAndTenantId(key: string, tenantId: string, body?: StartProcessInstanceFormDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<ProcessInstanceDto>> {
        return ProcessDefinitionApiFp(this.configuration).submitFormByKeyAndTenantId(key, tenantId, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates history time to live for process definition. The field is used within [History cleanup](https://docs.camunda.org/manual/7.18/user-guide/process-engine/history/#history-cleanup).
     * @summary Update History Time to Live
     * @param {string} id The id of the process definition to change history time to live.
     * @param {HistoryTimeToLiveDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async updateHistoryTimeToLiveByProcessDefinitionId(id: string, body?: HistoryTimeToLiveDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return ProcessDefinitionApiFp(this.configuration).updateHistoryTimeToLiveByProcessDefinitionId(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates history time to live for the latest version of the process definition which belongs to no tenant. The field is used within [History cleanup](https://docs.camunda.org/manual/7.18/user-guide/process-engine/history/#history-cleanup).
     * @summary Update History Time to Live
     * @param {string} key The key of the process definition to change history time to live.
     * @param {HistoryTimeToLiveDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async updateHistoryTimeToLiveByProcessDefinitionKey(key: string, body?: HistoryTimeToLiveDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return ProcessDefinitionApiFp(this.configuration).updateHistoryTimeToLiveByProcessDefinitionKey(key, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates history time to live for the latest version of the process definition for a tenant. The field is used within [History cleanup](https://docs.camunda.org/manual/7.18/user-guide/process-engine/history/#history-cleanup).
     * @summary Update History Time to Live
     * @param {string} key The key of the process definition to change history time to live.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {HistoryTimeToLiveDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId(key: string, tenantId: string, body?: HistoryTimeToLiveDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return ProcessDefinitionApiFp(this.configuration).updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId(key, tenantId, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Activates or suspends process definitions with the given process definition key.
     * @summary Activate/Suspend By Key
     * @param {ProcessDefinitionSuspensionStateDto} [body] **Note**: Unallowed property is &#x60;processDefinitionId&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async updateProcessDefinitionSuspensionState(body?: ProcessDefinitionSuspensionStateDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return ProcessDefinitionApiFp(this.configuration).updateProcessDefinitionSuspensionState(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Activates or suspends a given process definition by id.
     * @summary Activate/Suspend By Id
     * @param {string} id The id of the process definition to activate or suspend.
     * @param {ProcessDefinitionSuspensionStateDto} [body] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async updateProcessDefinitionSuspensionStateById(id: string, body?: ProcessDefinitionSuspensionStateDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return ProcessDefinitionApiFp(this.configuration).updateProcessDefinitionSuspensionStateById(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Activates or suspends a given process definition by latest version of process definition key which belongs to no tenant.
     * @summary Activate/Suspend by Id
     * @param {string} key The key of the process definition (the latest version thereof) to be activated/suspended.
     * @param {ProcessDefinitionSuspensionStateDto} [body] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async updateProcessDefinitionSuspensionStateByKey(key: string, body?: ProcessDefinitionSuspensionStateDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return ProcessDefinitionApiFp(this.configuration).updateProcessDefinitionSuspensionStateByKey(key, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Activates or suspends a given process definition by the latest version of the process definition for tenant.
     * @summary Activate/Suspend by Id
     * @param {string} key The key of the process definition (the latest version thereof) to be activated/suspended.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {ProcessDefinitionSuspensionStateDto} [body] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public async updateProcessDefinitionSuspensionStateByKeyAndTenantId(key: string, tenantId: string, body?: ProcessDefinitionSuspensionStateDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return ProcessDefinitionApiFp(this.configuration).updateProcessDefinitionSuspensionStateByKeyAndTenantId(key, tenantId, body, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Camunda Platform REST API
 * OpenApi Spec for Camunda Platform REST API.
 *
 * OpenAPI spec version: 7.18.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { CountResultDto } from '../models';
import { ExceptionDto } from '../models';
import { HistoricTaskInstanceDto } from '../models';
import { HistoricTaskInstanceQueryDto } from '../models';
import { HistoricTaskInstanceReportResultDto } from '../models';
/**
 * HistoricTaskInstanceApi - axios parameter creator
 * @export
 */
export const HistoricTaskInstanceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a report of completed tasks. When the report type is set to `count`, the report contains a list of completed task counts where an entry contains the task name, the definition key of the task, the process definition id, the process definition key, the process definition name and the count of how many tasks were completed for the specified key in a given period. When the report type is set to `duration`, the report contains a minimum, maximum and average duration value of all completed task instances in a given period.
         * @summary Get Task Report (Historic)
         * @param {string} [reportType] **Mandatory.** Specifies the kind of the report to execute. To retrieve a report about the duration of process instances the value must be set to &#x60;duration&#x60;. For a report of the completed tasks in a specific timespan the value must be set to &#x60;count&#x60;.
         * @param {string} [periodUnit] When the report type is set to &#x60;duration&#x60;, this parameter is **mandatory**. Specifies the granularity of the report. Valid values are &#x60;month&#x60; and &#x60;quarter&#x60;.
         * @param {Date} [completedBefore] Restrict to tasks that were completed before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [completedAfter] Restrict to tasks that were completed after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [groupBy] When the report type is set to &#x60;count&#x60;, this parameter is **mandatory**. Groups the tasks report by a given criterion. Valid values are &#x60;taskName&#x60; and &#x60;processDefinition&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricTaskInstanceReport: async (reportType?: string, periodUnit?: string, completedBefore?: Date, completedAfter?: Date, groupBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/history/task/report`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (reportType !== undefined) {
                localVarQueryParameter['reportType'] = reportType;
            }

            if (periodUnit !== undefined) {
                localVarQueryParameter['periodUnit'] = periodUnit;
            }

            if (completedBefore !== undefined) {
                localVarQueryParameter['completedBefore'] = (completedBefore as any instanceof Date) ?
                    (completedBefore as any).toISOString() :
                    completedBefore;
            }

            if (completedAfter !== undefined) {
                localVarQueryParameter['completedAfter'] = (completedAfter as any instanceof Date) ?
                    (completedAfter as any).toISOString() :
                    completedAfter;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['groupBy'] = groupBy;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for historic tasks that fulfill the given parameters. The size of the result set can be retrieved by using the [Get Task Count](https://docs.camunda.org/manual/7.18/reference/rest/history/task/get-task-query-count/) method.
         * @summary Get Tasks (Historic)
         * @param {string} [taskId] Filter by task id.
         * @param {string} [taskParentTaskId] Filter by parent task id.
         * @param {string} [processInstanceId] Filter by process instance id.
         * @param {string} [processInstanceBusinessKey] Filter by process instance business key.
         * @param {string} [processInstanceBusinessKeyIn] Filter by process instances with one of the give business keys. The keys need to be in a comma-separated list.
         * @param {string} [processInstanceBusinessKeyLike] Filter by  process instance business key that has the parameter value as a substring.
         * @param {string} [executionId] Filter by the id of the execution that executed the task.
         * @param {string} [processDefinitionId] Filter by process definition id.
         * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
         * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
         * @param {string} [caseInstanceId] Filter by case instance id.
         * @param {string} [caseExecutionId] Filter by the id of the case execution that executed the task.
         * @param {string} [caseDefinitionId] Filter by case definition id.
         * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
         * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
         * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed comma-separated activity instance ids.
         * @param {string} [taskName] Restrict to tasks that have the given name.
         * @param {string} [taskNameLike] Restrict to tasks that have a name with the given parameter value as substring.
         * @param {string} [taskDescription] Restrict to tasks that have the given description.
         * @param {string} [taskDescriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
         * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
         * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the passed comma-separated task definition keys.
         * @param {string} [taskDeleteReason] Restrict to tasks that have the given delete reason.
         * @param {string} [taskDeleteReasonLike] Restrict to tasks that have a delete reason that has the parameter value as a substring.
         * @param {string} [taskAssignee] Restrict to tasks that the given user is assigned to.
         * @param {string} [taskAssigneeLike] Restrict to tasks that are assigned to users with the parameter value as a substring.
         * @param {string} [taskOwner] Restrict to tasks that the given user owns.
         * @param {string} [taskOwnerLike] Restrict to tasks that are owned by users with the parameter value as a substring.
         * @param {number} [taskPriority] Restrict to tasks that have the given priority.
         * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
         * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
         * @param {boolean} [finished] Only include finished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [unfinished] Only include unfinished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [processFinished] Only include tasks of finished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [processUnfinished] Only include tasks of unfinished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {Date} [taskDueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [taskDueDateBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [taskDueDateAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {boolean} [withoutTaskDueDate] Only include tasks which have no due date. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {Date} [taskFollowUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [taskFollowUpDateBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [taskFollowUpDateAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [startedBefore] Restrict to tasks that were started before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [startedAfter] Restrict to tasks that were started after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [finishedBefore] Restrict to tasks that were finished before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [finishedAfter] Restrict to tasks that were finished after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A task instance must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include historic task instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;; * &#x60;notLike&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match the variable name provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match the variable value provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal.
         * @param {string} [taskInvolvedUser] Restrict to tasks with a historic identity link to the given user.
         * @param {string} [taskInvolvedGroup] Restrict to tasks with a historic identity link to the given group.
         * @param {string} [taskHadCandidateUser] Restrict to tasks with a historic identity link to the given candidate user.
         * @param {string} [taskHadCandidateGroup] Restrict to tasks with a historic identity link to the given candidate group.
         * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricTaskInstances: async (taskId?: string, taskParentTaskId?: string, processInstanceId?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, executionId?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionName?: string, caseInstanceId?: string, caseExecutionId?: string, caseDefinitionId?: string, caseDefinitionKey?: string, caseDefinitionName?: string, activityInstanceIdIn?: string, taskName?: string, taskNameLike?: string, taskDescription?: string, taskDescriptionLike?: string, taskDefinitionKey?: string, taskDefinitionKeyIn?: string, taskDeleteReason?: string, taskDeleteReasonLike?: string, taskAssignee?: string, taskAssigneeLike?: string, taskOwner?: string, taskOwnerLike?: string, taskPriority?: number, assigned?: boolean, unassigned?: boolean, finished?: boolean, unfinished?: boolean, processFinished?: boolean, processUnfinished?: boolean, taskDueDate?: Date, taskDueDateBefore?: Date, taskDueDateAfter?: Date, withoutTaskDueDate?: boolean, taskFollowUpDate?: Date, taskFollowUpDateBefore?: Date, taskFollowUpDateAfter?: Date, startedBefore?: Date, startedAfter?: Date, finishedBefore?: Date, finishedAfter?: Date, tenantIdIn?: string, withoutTenantId?: boolean, taskVariables?: string, processVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, taskInvolvedUser?: string, taskInvolvedGroup?: string, taskHadCandidateUser?: string, taskHadCandidateGroup?: string, withCandidateGroups?: boolean, withoutCandidateGroups?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/history/task`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (taskId !== undefined) {
                localVarQueryParameter['taskId'] = taskId;
            }

            if (taskParentTaskId !== undefined) {
                localVarQueryParameter['taskParentTaskId'] = taskParentTaskId;
            }

            if (processInstanceId !== undefined) {
                localVarQueryParameter['processInstanceId'] = processInstanceId;
            }

            if (processInstanceBusinessKey !== undefined) {
                localVarQueryParameter['processInstanceBusinessKey'] = processInstanceBusinessKey;
            }

            if (processInstanceBusinessKeyIn !== undefined) {
                localVarQueryParameter['processInstanceBusinessKeyIn'] = processInstanceBusinessKeyIn;
            }

            if (processInstanceBusinessKeyLike !== undefined) {
                localVarQueryParameter['processInstanceBusinessKeyLike'] = processInstanceBusinessKeyLike;
            }

            if (executionId !== undefined) {
                localVarQueryParameter['executionId'] = executionId;
            }

            if (processDefinitionId !== undefined) {
                localVarQueryParameter['processDefinitionId'] = processDefinitionId;
            }

            if (processDefinitionKey !== undefined) {
                localVarQueryParameter['processDefinitionKey'] = processDefinitionKey;
            }

            if (processDefinitionName !== undefined) {
                localVarQueryParameter['processDefinitionName'] = processDefinitionName;
            }

            if (caseInstanceId !== undefined) {
                localVarQueryParameter['caseInstanceId'] = caseInstanceId;
            }

            if (caseExecutionId !== undefined) {
                localVarQueryParameter['caseExecutionId'] = caseExecutionId;
            }

            if (caseDefinitionId !== undefined) {
                localVarQueryParameter['caseDefinitionId'] = caseDefinitionId;
            }

            if (caseDefinitionKey !== undefined) {
                localVarQueryParameter['caseDefinitionKey'] = caseDefinitionKey;
            }

            if (caseDefinitionName !== undefined) {
                localVarQueryParameter['caseDefinitionName'] = caseDefinitionName;
            }

            if (activityInstanceIdIn !== undefined) {
                localVarQueryParameter['activityInstanceIdIn'] = activityInstanceIdIn;
            }

            if (taskName !== undefined) {
                localVarQueryParameter['taskName'] = taskName;
            }

            if (taskNameLike !== undefined) {
                localVarQueryParameter['taskNameLike'] = taskNameLike;
            }

            if (taskDescription !== undefined) {
                localVarQueryParameter['taskDescription'] = taskDescription;
            }

            if (taskDescriptionLike !== undefined) {
                localVarQueryParameter['taskDescriptionLike'] = taskDescriptionLike;
            }

            if (taskDefinitionKey !== undefined) {
                localVarQueryParameter['taskDefinitionKey'] = taskDefinitionKey;
            }

            if (taskDefinitionKeyIn !== undefined) {
                localVarQueryParameter['taskDefinitionKeyIn'] = taskDefinitionKeyIn;
            }

            if (taskDeleteReason !== undefined) {
                localVarQueryParameter['taskDeleteReason'] = taskDeleteReason;
            }

            if (taskDeleteReasonLike !== undefined) {
                localVarQueryParameter['taskDeleteReasonLike'] = taskDeleteReasonLike;
            }

            if (taskAssignee !== undefined) {
                localVarQueryParameter['taskAssignee'] = taskAssignee;
            }

            if (taskAssigneeLike !== undefined) {
                localVarQueryParameter['taskAssigneeLike'] = taskAssigneeLike;
            }

            if (taskOwner !== undefined) {
                localVarQueryParameter['taskOwner'] = taskOwner;
            }

            if (taskOwnerLike !== undefined) {
                localVarQueryParameter['taskOwnerLike'] = taskOwnerLike;
            }

            if (taskPriority !== undefined) {
                localVarQueryParameter['taskPriority'] = taskPriority;
            }

            if (assigned !== undefined) {
                localVarQueryParameter['assigned'] = assigned;
            }

            if (unassigned !== undefined) {
                localVarQueryParameter['unassigned'] = unassigned;
            }

            if (finished !== undefined) {
                localVarQueryParameter['finished'] = finished;
            }

            if (unfinished !== undefined) {
                localVarQueryParameter['unfinished'] = unfinished;
            }

            if (processFinished !== undefined) {
                localVarQueryParameter['processFinished'] = processFinished;
            }

            if (processUnfinished !== undefined) {
                localVarQueryParameter['processUnfinished'] = processUnfinished;
            }

            if (taskDueDate !== undefined) {
                localVarQueryParameter['taskDueDate'] = (taskDueDate as any instanceof Date) ?
                    (taskDueDate as any).toISOString() :
                    taskDueDate;
            }

            if (taskDueDateBefore !== undefined) {
                localVarQueryParameter['taskDueDateBefore'] = (taskDueDateBefore as any instanceof Date) ?
                    (taskDueDateBefore as any).toISOString() :
                    taskDueDateBefore;
            }

            if (taskDueDateAfter !== undefined) {
                localVarQueryParameter['taskDueDateAfter'] = (taskDueDateAfter as any instanceof Date) ?
                    (taskDueDateAfter as any).toISOString() :
                    taskDueDateAfter;
            }

            if (withoutTaskDueDate !== undefined) {
                localVarQueryParameter['withoutTaskDueDate'] = withoutTaskDueDate;
            }

            if (taskFollowUpDate !== undefined) {
                localVarQueryParameter['taskFollowUpDate'] = (taskFollowUpDate as any instanceof Date) ?
                    (taskFollowUpDate as any).toISOString() :
                    taskFollowUpDate;
            }

            if (taskFollowUpDateBefore !== undefined) {
                localVarQueryParameter['taskFollowUpDateBefore'] = (taskFollowUpDateBefore as any instanceof Date) ?
                    (taskFollowUpDateBefore as any).toISOString() :
                    taskFollowUpDateBefore;
            }

            if (taskFollowUpDateAfter !== undefined) {
                localVarQueryParameter['taskFollowUpDateAfter'] = (taskFollowUpDateAfter as any instanceof Date) ?
                    (taskFollowUpDateAfter as any).toISOString() :
                    taskFollowUpDateAfter;
            }

            if (startedBefore !== undefined) {
                localVarQueryParameter['startedBefore'] = (startedBefore as any instanceof Date) ?
                    (startedBefore as any).toISOString() :
                    startedBefore;
            }

            if (startedAfter !== undefined) {
                localVarQueryParameter['startedAfter'] = (startedAfter as any instanceof Date) ?
                    (startedAfter as any).toISOString() :
                    startedAfter;
            }

            if (finishedBefore !== undefined) {
                localVarQueryParameter['finishedBefore'] = (finishedBefore as any instanceof Date) ?
                    (finishedBefore as any).toISOString() :
                    finishedBefore;
            }

            if (finishedAfter !== undefined) {
                localVarQueryParameter['finishedAfter'] = (finishedAfter as any instanceof Date) ?
                    (finishedAfter as any).toISOString() :
                    finishedAfter;
            }

            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }

            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }

            if (taskVariables !== undefined) {
                localVarQueryParameter['taskVariables'] = taskVariables;
            }

            if (processVariables !== undefined) {
                localVarQueryParameter['processVariables'] = processVariables;
            }

            if (variableNamesIgnoreCase !== undefined) {
                localVarQueryParameter['variableNamesIgnoreCase'] = variableNamesIgnoreCase;
            }

            if (variableValuesIgnoreCase !== undefined) {
                localVarQueryParameter['variableValuesIgnoreCase'] = variableValuesIgnoreCase;
            }

            if (taskInvolvedUser !== undefined) {
                localVarQueryParameter['taskInvolvedUser'] = taskInvolvedUser;
            }

            if (taskInvolvedGroup !== undefined) {
                localVarQueryParameter['taskInvolvedGroup'] = taskInvolvedGroup;
            }

            if (taskHadCandidateUser !== undefined) {
                localVarQueryParameter['taskHadCandidateUser'] = taskHadCandidateUser;
            }

            if (taskHadCandidateGroup !== undefined) {
                localVarQueryParameter['taskHadCandidateGroup'] = taskHadCandidateGroup;
            }

            if (withCandidateGroups !== undefined) {
                localVarQueryParameter['withCandidateGroups'] = withCandidateGroups;
            }

            if (withoutCandidateGroups !== undefined) {
                localVarQueryParameter['withoutCandidateGroups'] = withoutCandidateGroups;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for the number of historic tasks that fulfill the given parameters. Takes the same parameters as the [Get Tasks (Historic)](https://docs.camunda.org/manual/7.18/reference/rest/history/task/get-task-query/) method.
         * @summary Get Task Count
         * @param {string} [taskId] Filter by task id.
         * @param {string} [taskParentTaskId] Filter by parent task id.
         * @param {string} [processInstanceId] Filter by process instance id.
         * @param {string} [processInstanceBusinessKey] Filter by process instance business key.
         * @param {string} [processInstanceBusinessKeyIn] Filter by process instances with one of the give business keys. The keys need to be in a comma-separated list.
         * @param {string} [processInstanceBusinessKeyLike] Filter by  process instance business key that has the parameter value as a substring.
         * @param {string} [executionId] Filter by the id of the execution that executed the task.
         * @param {string} [processDefinitionId] Filter by process definition id.
         * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
         * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
         * @param {string} [caseInstanceId] Filter by case instance id.
         * @param {string} [caseExecutionId] Filter by the id of the case execution that executed the task.
         * @param {string} [caseDefinitionId] Filter by case definition id.
         * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
         * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
         * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed comma-separated activity instance ids.
         * @param {string} [taskName] Restrict to tasks that have the given name.
         * @param {string} [taskNameLike] Restrict to tasks that have a name with the given parameter value as substring.
         * @param {string} [taskDescription] Restrict to tasks that have the given description.
         * @param {string} [taskDescriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
         * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
         * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the passed comma-separated task definition keys.
         * @param {string} [taskDeleteReason] Restrict to tasks that have the given delete reason.
         * @param {string} [taskDeleteReasonLike] Restrict to tasks that have a delete reason that has the parameter value as a substring.
         * @param {string} [taskAssignee] Restrict to tasks that the given user is assigned to.
         * @param {string} [taskAssigneeLike] Restrict to tasks that are assigned to users with the parameter value as a substring.
         * @param {string} [taskOwner] Restrict to tasks that the given user owns.
         * @param {string} [taskOwnerLike] Restrict to tasks that are owned by users with the parameter value as a substring.
         * @param {number} [taskPriority] Restrict to tasks that have the given priority.
         * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
         * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
         * @param {boolean} [finished] Only include finished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [unfinished] Only include unfinished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [processFinished] Only include tasks of finished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [processUnfinished] Only include tasks of unfinished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {Date} [taskDueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [taskDueDateBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [taskDueDateAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {boolean} [withoutTaskDueDate] Only include tasks which have no due date. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {Date} [taskFollowUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [taskFollowUpDateBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [taskFollowUpDateAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [startedBefore] Restrict to tasks that were started before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [startedAfter] Restrict to tasks that were started after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [finishedBefore] Restrict to tasks that were finished before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [finishedAfter] Restrict to tasks that were finished after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A task instance must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include historic task instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;; * &#x60;notLike&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match the variable name provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match the variable value provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal.
         * @param {string} [taskInvolvedUser] Restrict to tasks with a historic identity link to the given user.
         * @param {string} [taskInvolvedGroup] Restrict to tasks with a historic identity link to the given group.
         * @param {string} [taskHadCandidateUser] Restrict to tasks with a historic identity link to the given candidate user.
         * @param {string} [taskHadCandidateGroup] Restrict to tasks with a historic identity link to the given candidate group.
         * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricTaskInstancesCount: async (taskId?: string, taskParentTaskId?: string, processInstanceId?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, executionId?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionName?: string, caseInstanceId?: string, caseExecutionId?: string, caseDefinitionId?: string, caseDefinitionKey?: string, caseDefinitionName?: string, activityInstanceIdIn?: string, taskName?: string, taskNameLike?: string, taskDescription?: string, taskDescriptionLike?: string, taskDefinitionKey?: string, taskDefinitionKeyIn?: string, taskDeleteReason?: string, taskDeleteReasonLike?: string, taskAssignee?: string, taskAssigneeLike?: string, taskOwner?: string, taskOwnerLike?: string, taskPriority?: number, assigned?: boolean, unassigned?: boolean, finished?: boolean, unfinished?: boolean, processFinished?: boolean, processUnfinished?: boolean, taskDueDate?: Date, taskDueDateBefore?: Date, taskDueDateAfter?: Date, withoutTaskDueDate?: boolean, taskFollowUpDate?: Date, taskFollowUpDateBefore?: Date, taskFollowUpDateAfter?: Date, startedBefore?: Date, startedAfter?: Date, finishedBefore?: Date, finishedAfter?: Date, tenantIdIn?: string, withoutTenantId?: boolean, taskVariables?: string, processVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, taskInvolvedUser?: string, taskInvolvedGroup?: string, taskHadCandidateUser?: string, taskHadCandidateGroup?: string, withCandidateGroups?: boolean, withoutCandidateGroups?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/history/task/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (taskId !== undefined) {
                localVarQueryParameter['taskId'] = taskId;
            }

            if (taskParentTaskId !== undefined) {
                localVarQueryParameter['taskParentTaskId'] = taskParentTaskId;
            }

            if (processInstanceId !== undefined) {
                localVarQueryParameter['processInstanceId'] = processInstanceId;
            }

            if (processInstanceBusinessKey !== undefined) {
                localVarQueryParameter['processInstanceBusinessKey'] = processInstanceBusinessKey;
            }

            if (processInstanceBusinessKeyIn !== undefined) {
                localVarQueryParameter['processInstanceBusinessKeyIn'] = processInstanceBusinessKeyIn;
            }

            if (processInstanceBusinessKeyLike !== undefined) {
                localVarQueryParameter['processInstanceBusinessKeyLike'] = processInstanceBusinessKeyLike;
            }

            if (executionId !== undefined) {
                localVarQueryParameter['executionId'] = executionId;
            }

            if (processDefinitionId !== undefined) {
                localVarQueryParameter['processDefinitionId'] = processDefinitionId;
            }

            if (processDefinitionKey !== undefined) {
                localVarQueryParameter['processDefinitionKey'] = processDefinitionKey;
            }

            if (processDefinitionName !== undefined) {
                localVarQueryParameter['processDefinitionName'] = processDefinitionName;
            }

            if (caseInstanceId !== undefined) {
                localVarQueryParameter['caseInstanceId'] = caseInstanceId;
            }

            if (caseExecutionId !== undefined) {
                localVarQueryParameter['caseExecutionId'] = caseExecutionId;
            }

            if (caseDefinitionId !== undefined) {
                localVarQueryParameter['caseDefinitionId'] = caseDefinitionId;
            }

            if (caseDefinitionKey !== undefined) {
                localVarQueryParameter['caseDefinitionKey'] = caseDefinitionKey;
            }

            if (caseDefinitionName !== undefined) {
                localVarQueryParameter['caseDefinitionName'] = caseDefinitionName;
            }

            if (activityInstanceIdIn !== undefined) {
                localVarQueryParameter['activityInstanceIdIn'] = activityInstanceIdIn;
            }

            if (taskName !== undefined) {
                localVarQueryParameter['taskName'] = taskName;
            }

            if (taskNameLike !== undefined) {
                localVarQueryParameter['taskNameLike'] = taskNameLike;
            }

            if (taskDescription !== undefined) {
                localVarQueryParameter['taskDescription'] = taskDescription;
            }

            if (taskDescriptionLike !== undefined) {
                localVarQueryParameter['taskDescriptionLike'] = taskDescriptionLike;
            }

            if (taskDefinitionKey !== undefined) {
                localVarQueryParameter['taskDefinitionKey'] = taskDefinitionKey;
            }

            if (taskDefinitionKeyIn !== undefined) {
                localVarQueryParameter['taskDefinitionKeyIn'] = taskDefinitionKeyIn;
            }

            if (taskDeleteReason !== undefined) {
                localVarQueryParameter['taskDeleteReason'] = taskDeleteReason;
            }

            if (taskDeleteReasonLike !== undefined) {
                localVarQueryParameter['taskDeleteReasonLike'] = taskDeleteReasonLike;
            }

            if (taskAssignee !== undefined) {
                localVarQueryParameter['taskAssignee'] = taskAssignee;
            }

            if (taskAssigneeLike !== undefined) {
                localVarQueryParameter['taskAssigneeLike'] = taskAssigneeLike;
            }

            if (taskOwner !== undefined) {
                localVarQueryParameter['taskOwner'] = taskOwner;
            }

            if (taskOwnerLike !== undefined) {
                localVarQueryParameter['taskOwnerLike'] = taskOwnerLike;
            }

            if (taskPriority !== undefined) {
                localVarQueryParameter['taskPriority'] = taskPriority;
            }

            if (assigned !== undefined) {
                localVarQueryParameter['assigned'] = assigned;
            }

            if (unassigned !== undefined) {
                localVarQueryParameter['unassigned'] = unassigned;
            }

            if (finished !== undefined) {
                localVarQueryParameter['finished'] = finished;
            }

            if (unfinished !== undefined) {
                localVarQueryParameter['unfinished'] = unfinished;
            }

            if (processFinished !== undefined) {
                localVarQueryParameter['processFinished'] = processFinished;
            }

            if (processUnfinished !== undefined) {
                localVarQueryParameter['processUnfinished'] = processUnfinished;
            }

            if (taskDueDate !== undefined) {
                localVarQueryParameter['taskDueDate'] = (taskDueDate as any instanceof Date) ?
                    (taskDueDate as any).toISOString() :
                    taskDueDate;
            }

            if (taskDueDateBefore !== undefined) {
                localVarQueryParameter['taskDueDateBefore'] = (taskDueDateBefore as any instanceof Date) ?
                    (taskDueDateBefore as any).toISOString() :
                    taskDueDateBefore;
            }

            if (taskDueDateAfter !== undefined) {
                localVarQueryParameter['taskDueDateAfter'] = (taskDueDateAfter as any instanceof Date) ?
                    (taskDueDateAfter as any).toISOString() :
                    taskDueDateAfter;
            }

            if (withoutTaskDueDate !== undefined) {
                localVarQueryParameter['withoutTaskDueDate'] = withoutTaskDueDate;
            }

            if (taskFollowUpDate !== undefined) {
                localVarQueryParameter['taskFollowUpDate'] = (taskFollowUpDate as any instanceof Date) ?
                    (taskFollowUpDate as any).toISOString() :
                    taskFollowUpDate;
            }

            if (taskFollowUpDateBefore !== undefined) {
                localVarQueryParameter['taskFollowUpDateBefore'] = (taskFollowUpDateBefore as any instanceof Date) ?
                    (taskFollowUpDateBefore as any).toISOString() :
                    taskFollowUpDateBefore;
            }

            if (taskFollowUpDateAfter !== undefined) {
                localVarQueryParameter['taskFollowUpDateAfter'] = (taskFollowUpDateAfter as any instanceof Date) ?
                    (taskFollowUpDateAfter as any).toISOString() :
                    taskFollowUpDateAfter;
            }

            if (startedBefore !== undefined) {
                localVarQueryParameter['startedBefore'] = (startedBefore as any instanceof Date) ?
                    (startedBefore as any).toISOString() :
                    startedBefore;
            }

            if (startedAfter !== undefined) {
                localVarQueryParameter['startedAfter'] = (startedAfter as any instanceof Date) ?
                    (startedAfter as any).toISOString() :
                    startedAfter;
            }

            if (finishedBefore !== undefined) {
                localVarQueryParameter['finishedBefore'] = (finishedBefore as any instanceof Date) ?
                    (finishedBefore as any).toISOString() :
                    finishedBefore;
            }

            if (finishedAfter !== undefined) {
                localVarQueryParameter['finishedAfter'] = (finishedAfter as any instanceof Date) ?
                    (finishedAfter as any).toISOString() :
                    finishedAfter;
            }

            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }

            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }

            if (taskVariables !== undefined) {
                localVarQueryParameter['taskVariables'] = taskVariables;
            }

            if (processVariables !== undefined) {
                localVarQueryParameter['processVariables'] = processVariables;
            }

            if (variableNamesIgnoreCase !== undefined) {
                localVarQueryParameter['variableNamesIgnoreCase'] = variableNamesIgnoreCase;
            }

            if (variableValuesIgnoreCase !== undefined) {
                localVarQueryParameter['variableValuesIgnoreCase'] = variableValuesIgnoreCase;
            }

            if (taskInvolvedUser !== undefined) {
                localVarQueryParameter['taskInvolvedUser'] = taskInvolvedUser;
            }

            if (taskInvolvedGroup !== undefined) {
                localVarQueryParameter['taskInvolvedGroup'] = taskInvolvedGroup;
            }

            if (taskHadCandidateUser !== undefined) {
                localVarQueryParameter['taskHadCandidateUser'] = taskHadCandidateUser;
            }

            if (taskHadCandidateGroup !== undefined) {
                localVarQueryParameter['taskHadCandidateGroup'] = taskHadCandidateGroup;
            }

            if (withCandidateGroups !== undefined) {
                localVarQueryParameter['withCandidateGroups'] = withCandidateGroups;
            }

            if (withoutCandidateGroups !== undefined) {
                localVarQueryParameter['withoutCandidateGroups'] = withoutCandidateGroups;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for historic tasks that fulfill the given parameters. This method is slightly more powerful than the [Get Tasks (Historic)](https://docs.camunda.org/manual/7.18/reference/rest/history/task/get-task-query/) method because it allows filtering by multiple process or task variables of types `String`, `Number` or `Boolean`. The size of the result set can be retrieved by using the [Get Task Count (POST)](https://docs.camunda.org/manual/7.18/reference/rest/history/task/post-task-query-count/) method.
         * @summary Get Tasks (Historic) (POST)
         * @param {HistoricTaskInstanceQueryDto} [body] 
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryHistoricTaskInstances: async (body?: HistoricTaskInstanceQueryDto, firstResult?: number, maxResults?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/history/task`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for the number of historic tasks that fulfill the given parameters. Takes the same parameters as the [Get Tasks (Historic)](https://docs.camunda.org/manual/7.18/reference/rest/history/task/get-task-query/) method. Corresponds to the size of the result set of the [Get Tasks (Historic) (POST)](https://docs.camunda.org/manual/7.18/reference/rest/history/task/post-task-query/) method and takes the same parameters.
         * @summary Get Task Count (POST)
         * @param {HistoricTaskInstanceQueryDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryHistoricTaskInstancesCount: async (body?: HistoricTaskInstanceQueryDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/history/task/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HistoricTaskInstanceApi - functional programming interface
 * @export
 */
export const HistoricTaskInstanceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieves a report of completed tasks. When the report type is set to `count`, the report contains a list of completed task counts where an entry contains the task name, the definition key of the task, the process definition id, the process definition key, the process definition name and the count of how many tasks were completed for the specified key in a given period. When the report type is set to `duration`, the report contains a minimum, maximum and average duration value of all completed task instances in a given period.
         * @summary Get Task Report (Historic)
         * @param {string} [reportType] **Mandatory.** Specifies the kind of the report to execute. To retrieve a report about the duration of process instances the value must be set to &#x60;duration&#x60;. For a report of the completed tasks in a specific timespan the value must be set to &#x60;count&#x60;.
         * @param {string} [periodUnit] When the report type is set to &#x60;duration&#x60;, this parameter is **mandatory**. Specifies the granularity of the report. Valid values are &#x60;month&#x60; and &#x60;quarter&#x60;.
         * @param {Date} [completedBefore] Restrict to tasks that were completed before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [completedAfter] Restrict to tasks that were completed after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [groupBy] When the report type is set to &#x60;count&#x60;, this parameter is **mandatory**. Groups the tasks report by a given criterion. Valid values are &#x60;taskName&#x60; and &#x60;processDefinition&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHistoricTaskInstanceReport(reportType?: string, periodUnit?: string, completedBefore?: Date, completedAfter?: Date, groupBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<HistoricTaskInstanceReportResultDto>>>> {
            const localVarAxiosArgs = await HistoricTaskInstanceApiAxiosParamCreator(configuration).getHistoricTaskInstanceReport(reportType, periodUnit, completedBefore, completedAfter, groupBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Queries for historic tasks that fulfill the given parameters. The size of the result set can be retrieved by using the [Get Task Count](https://docs.camunda.org/manual/7.18/reference/rest/history/task/get-task-query-count/) method.
         * @summary Get Tasks (Historic)
         * @param {string} [taskId] Filter by task id.
         * @param {string} [taskParentTaskId] Filter by parent task id.
         * @param {string} [processInstanceId] Filter by process instance id.
         * @param {string} [processInstanceBusinessKey] Filter by process instance business key.
         * @param {string} [processInstanceBusinessKeyIn] Filter by process instances with one of the give business keys. The keys need to be in a comma-separated list.
         * @param {string} [processInstanceBusinessKeyLike] Filter by  process instance business key that has the parameter value as a substring.
         * @param {string} [executionId] Filter by the id of the execution that executed the task.
         * @param {string} [processDefinitionId] Filter by process definition id.
         * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
         * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
         * @param {string} [caseInstanceId] Filter by case instance id.
         * @param {string} [caseExecutionId] Filter by the id of the case execution that executed the task.
         * @param {string} [caseDefinitionId] Filter by case definition id.
         * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
         * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
         * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed comma-separated activity instance ids.
         * @param {string} [taskName] Restrict to tasks that have the given name.
         * @param {string} [taskNameLike] Restrict to tasks that have a name with the given parameter value as substring.
         * @param {string} [taskDescription] Restrict to tasks that have the given description.
         * @param {string} [taskDescriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
         * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
         * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the passed comma-separated task definition keys.
         * @param {string} [taskDeleteReason] Restrict to tasks that have the given delete reason.
         * @param {string} [taskDeleteReasonLike] Restrict to tasks that have a delete reason that has the parameter value as a substring.
         * @param {string} [taskAssignee] Restrict to tasks that the given user is assigned to.
         * @param {string} [taskAssigneeLike] Restrict to tasks that are assigned to users with the parameter value as a substring.
         * @param {string} [taskOwner] Restrict to tasks that the given user owns.
         * @param {string} [taskOwnerLike] Restrict to tasks that are owned by users with the parameter value as a substring.
         * @param {number} [taskPriority] Restrict to tasks that have the given priority.
         * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
         * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
         * @param {boolean} [finished] Only include finished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [unfinished] Only include unfinished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [processFinished] Only include tasks of finished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [processUnfinished] Only include tasks of unfinished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {Date} [taskDueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [taskDueDateBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [taskDueDateAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {boolean} [withoutTaskDueDate] Only include tasks which have no due date. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {Date} [taskFollowUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [taskFollowUpDateBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [taskFollowUpDateAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [startedBefore] Restrict to tasks that were started before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [startedAfter] Restrict to tasks that were started after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [finishedBefore] Restrict to tasks that were finished before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [finishedAfter] Restrict to tasks that were finished after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A task instance must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include historic task instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;; * &#x60;notLike&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match the variable name provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match the variable value provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal.
         * @param {string} [taskInvolvedUser] Restrict to tasks with a historic identity link to the given user.
         * @param {string} [taskInvolvedGroup] Restrict to tasks with a historic identity link to the given group.
         * @param {string} [taskHadCandidateUser] Restrict to tasks with a historic identity link to the given candidate user.
         * @param {string} [taskHadCandidateGroup] Restrict to tasks with a historic identity link to the given candidate group.
         * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHistoricTaskInstances(taskId?: string, taskParentTaskId?: string, processInstanceId?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, executionId?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionName?: string, caseInstanceId?: string, caseExecutionId?: string, caseDefinitionId?: string, caseDefinitionKey?: string, caseDefinitionName?: string, activityInstanceIdIn?: string, taskName?: string, taskNameLike?: string, taskDescription?: string, taskDescriptionLike?: string, taskDefinitionKey?: string, taskDefinitionKeyIn?: string, taskDeleteReason?: string, taskDeleteReasonLike?: string, taskAssignee?: string, taskAssigneeLike?: string, taskOwner?: string, taskOwnerLike?: string, taskPriority?: number, assigned?: boolean, unassigned?: boolean, finished?: boolean, unfinished?: boolean, processFinished?: boolean, processUnfinished?: boolean, taskDueDate?: Date, taskDueDateBefore?: Date, taskDueDateAfter?: Date, withoutTaskDueDate?: boolean, taskFollowUpDate?: Date, taskFollowUpDateBefore?: Date, taskFollowUpDateAfter?: Date, startedBefore?: Date, startedAfter?: Date, finishedBefore?: Date, finishedAfter?: Date, tenantIdIn?: string, withoutTenantId?: boolean, taskVariables?: string, processVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, taskInvolvedUser?: string, taskInvolvedGroup?: string, taskHadCandidateUser?: string, taskHadCandidateGroup?: string, withCandidateGroups?: boolean, withoutCandidateGroups?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<HistoricTaskInstanceDto>>>> {
            const localVarAxiosArgs = await HistoricTaskInstanceApiAxiosParamCreator(configuration).getHistoricTaskInstances(taskId, taskParentTaskId, processInstanceId, processInstanceBusinessKey, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, executionId, processDefinitionId, processDefinitionKey, processDefinitionName, caseInstanceId, caseExecutionId, caseDefinitionId, caseDefinitionKey, caseDefinitionName, activityInstanceIdIn, taskName, taskNameLike, taskDescription, taskDescriptionLike, taskDefinitionKey, taskDefinitionKeyIn, taskDeleteReason, taskDeleteReasonLike, taskAssignee, taskAssigneeLike, taskOwner, taskOwnerLike, taskPriority, assigned, unassigned, finished, unfinished, processFinished, processUnfinished, taskDueDate, taskDueDateBefore, taskDueDateAfter, withoutTaskDueDate, taskFollowUpDate, taskFollowUpDateBefore, taskFollowUpDateAfter, startedBefore, startedAfter, finishedBefore, finishedAfter, tenantIdIn, withoutTenantId, taskVariables, processVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, taskInvolvedUser, taskInvolvedGroup, taskHadCandidateUser, taskHadCandidateGroup, withCandidateGroups, withoutCandidateGroups, sortBy, sortOrder, firstResult, maxResults, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Queries for the number of historic tasks that fulfill the given parameters. Takes the same parameters as the [Get Tasks (Historic)](https://docs.camunda.org/manual/7.18/reference/rest/history/task/get-task-query/) method.
         * @summary Get Task Count
         * @param {string} [taskId] Filter by task id.
         * @param {string} [taskParentTaskId] Filter by parent task id.
         * @param {string} [processInstanceId] Filter by process instance id.
         * @param {string} [processInstanceBusinessKey] Filter by process instance business key.
         * @param {string} [processInstanceBusinessKeyIn] Filter by process instances with one of the give business keys. The keys need to be in a comma-separated list.
         * @param {string} [processInstanceBusinessKeyLike] Filter by  process instance business key that has the parameter value as a substring.
         * @param {string} [executionId] Filter by the id of the execution that executed the task.
         * @param {string} [processDefinitionId] Filter by process definition id.
         * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
         * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
         * @param {string} [caseInstanceId] Filter by case instance id.
         * @param {string} [caseExecutionId] Filter by the id of the case execution that executed the task.
         * @param {string} [caseDefinitionId] Filter by case definition id.
         * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
         * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
         * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed comma-separated activity instance ids.
         * @param {string} [taskName] Restrict to tasks that have the given name.
         * @param {string} [taskNameLike] Restrict to tasks that have a name with the given parameter value as substring.
         * @param {string} [taskDescription] Restrict to tasks that have the given description.
         * @param {string} [taskDescriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
         * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
         * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the passed comma-separated task definition keys.
         * @param {string} [taskDeleteReason] Restrict to tasks that have the given delete reason.
         * @param {string} [taskDeleteReasonLike] Restrict to tasks that have a delete reason that has the parameter value as a substring.
         * @param {string} [taskAssignee] Restrict to tasks that the given user is assigned to.
         * @param {string} [taskAssigneeLike] Restrict to tasks that are assigned to users with the parameter value as a substring.
         * @param {string} [taskOwner] Restrict to tasks that the given user owns.
         * @param {string} [taskOwnerLike] Restrict to tasks that are owned by users with the parameter value as a substring.
         * @param {number} [taskPriority] Restrict to tasks that have the given priority.
         * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
         * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
         * @param {boolean} [finished] Only include finished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [unfinished] Only include unfinished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [processFinished] Only include tasks of finished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [processUnfinished] Only include tasks of unfinished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {Date} [taskDueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [taskDueDateBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [taskDueDateAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {boolean} [withoutTaskDueDate] Only include tasks which have no due date. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {Date} [taskFollowUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [taskFollowUpDateBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [taskFollowUpDateAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [startedBefore] Restrict to tasks that were started before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [startedAfter] Restrict to tasks that were started after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [finishedBefore] Restrict to tasks that were finished before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [finishedAfter] Restrict to tasks that were finished after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A task instance must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include historic task instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;; * &#x60;notLike&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match the variable name provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match the variable value provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal.
         * @param {string} [taskInvolvedUser] Restrict to tasks with a historic identity link to the given user.
         * @param {string} [taskInvolvedGroup] Restrict to tasks with a historic identity link to the given group.
         * @param {string} [taskHadCandidateUser] Restrict to tasks with a historic identity link to the given candidate user.
         * @param {string} [taskHadCandidateGroup] Restrict to tasks with a historic identity link to the given candidate group.
         * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHistoricTaskInstancesCount(taskId?: string, taskParentTaskId?: string, processInstanceId?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, executionId?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionName?: string, caseInstanceId?: string, caseExecutionId?: string, caseDefinitionId?: string, caseDefinitionKey?: string, caseDefinitionName?: string, activityInstanceIdIn?: string, taskName?: string, taskNameLike?: string, taskDescription?: string, taskDescriptionLike?: string, taskDefinitionKey?: string, taskDefinitionKeyIn?: string, taskDeleteReason?: string, taskDeleteReasonLike?: string, taskAssignee?: string, taskAssigneeLike?: string, taskOwner?: string, taskOwnerLike?: string, taskPriority?: number, assigned?: boolean, unassigned?: boolean, finished?: boolean, unfinished?: boolean, processFinished?: boolean, processUnfinished?: boolean, taskDueDate?: Date, taskDueDateBefore?: Date, taskDueDateAfter?: Date, withoutTaskDueDate?: boolean, taskFollowUpDate?: Date, taskFollowUpDateBefore?: Date, taskFollowUpDateAfter?: Date, startedBefore?: Date, startedAfter?: Date, finishedBefore?: Date, finishedAfter?: Date, tenantIdIn?: string, withoutTenantId?: boolean, taskVariables?: string, processVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, taskInvolvedUser?: string, taskInvolvedGroup?: string, taskHadCandidateUser?: string, taskHadCandidateGroup?: string, withCandidateGroups?: boolean, withoutCandidateGroups?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<CountResultDto>>> {
            const localVarAxiosArgs = await HistoricTaskInstanceApiAxiosParamCreator(configuration).getHistoricTaskInstancesCount(taskId, taskParentTaskId, processInstanceId, processInstanceBusinessKey, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, executionId, processDefinitionId, processDefinitionKey, processDefinitionName, caseInstanceId, caseExecutionId, caseDefinitionId, caseDefinitionKey, caseDefinitionName, activityInstanceIdIn, taskName, taskNameLike, taskDescription, taskDescriptionLike, taskDefinitionKey, taskDefinitionKeyIn, taskDeleteReason, taskDeleteReasonLike, taskAssignee, taskAssigneeLike, taskOwner, taskOwnerLike, taskPriority, assigned, unassigned, finished, unfinished, processFinished, processUnfinished, taskDueDate, taskDueDateBefore, taskDueDateAfter, withoutTaskDueDate, taskFollowUpDate, taskFollowUpDateBefore, taskFollowUpDateAfter, startedBefore, startedAfter, finishedBefore, finishedAfter, tenantIdIn, withoutTenantId, taskVariables, processVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, taskInvolvedUser, taskInvolvedGroup, taskHadCandidateUser, taskHadCandidateGroup, withCandidateGroups, withoutCandidateGroups, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Queries for historic tasks that fulfill the given parameters. This method is slightly more powerful than the [Get Tasks (Historic)](https://docs.camunda.org/manual/7.18/reference/rest/history/task/get-task-query/) method because it allows filtering by multiple process or task variables of types `String`, `Number` or `Boolean`. The size of the result set can be retrieved by using the [Get Task Count (POST)](https://docs.camunda.org/manual/7.18/reference/rest/history/task/post-task-query-count/) method.
         * @summary Get Tasks (Historic) (POST)
         * @param {HistoricTaskInstanceQueryDto} [body] 
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryHistoricTaskInstances(body?: HistoricTaskInstanceQueryDto, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<HistoricTaskInstanceDto>>>> {
            const localVarAxiosArgs = await HistoricTaskInstanceApiAxiosParamCreator(configuration).queryHistoricTaskInstances(body, firstResult, maxResults, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Queries for the number of historic tasks that fulfill the given parameters. Takes the same parameters as the [Get Tasks (Historic)](https://docs.camunda.org/manual/7.18/reference/rest/history/task/get-task-query/) method. Corresponds to the size of the result set of the [Get Tasks (Historic) (POST)](https://docs.camunda.org/manual/7.18/reference/rest/history/task/post-task-query/) method and takes the same parameters.
         * @summary Get Task Count (POST)
         * @param {HistoricTaskInstanceQueryDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryHistoricTaskInstancesCount(body?: HistoricTaskInstanceQueryDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<CountResultDto>>> {
            const localVarAxiosArgs = await HistoricTaskInstanceApiAxiosParamCreator(configuration).queryHistoricTaskInstancesCount(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * HistoricTaskInstanceApi - factory interface
 * @export
 */
export const HistoricTaskInstanceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Retrieves a report of completed tasks. When the report type is set to `count`, the report contains a list of completed task counts where an entry contains the task name, the definition key of the task, the process definition id, the process definition key, the process definition name and the count of how many tasks were completed for the specified key in a given period. When the report type is set to `duration`, the report contains a minimum, maximum and average duration value of all completed task instances in a given period.
         * @summary Get Task Report (Historic)
         * @param {string} [reportType] **Mandatory.** Specifies the kind of the report to execute. To retrieve a report about the duration of process instances the value must be set to &#x60;duration&#x60;. For a report of the completed tasks in a specific timespan the value must be set to &#x60;count&#x60;.
         * @param {string} [periodUnit] When the report type is set to &#x60;duration&#x60;, this parameter is **mandatory**. Specifies the granularity of the report. Valid values are &#x60;month&#x60; and &#x60;quarter&#x60;.
         * @param {Date} [completedBefore] Restrict to tasks that were completed before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [completedAfter] Restrict to tasks that were completed after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [groupBy] When the report type is set to &#x60;count&#x60;, this parameter is **mandatory**. Groups the tasks report by a given criterion. Valid values are &#x60;taskName&#x60; and &#x60;processDefinition&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHistoricTaskInstanceReport(reportType?: string, periodUnit?: string, completedBefore?: Date, completedAfter?: Date, groupBy?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<HistoricTaskInstanceReportResultDto>>> {
            return HistoricTaskInstanceApiFp(configuration).getHistoricTaskInstanceReport(reportType, periodUnit, completedBefore, completedAfter, groupBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for historic tasks that fulfill the given parameters. The size of the result set can be retrieved by using the [Get Task Count](https://docs.camunda.org/manual/7.18/reference/rest/history/task/get-task-query-count/) method.
         * @summary Get Tasks (Historic)
         * @param {string} [taskId] Filter by task id.
         * @param {string} [taskParentTaskId] Filter by parent task id.
         * @param {string} [processInstanceId] Filter by process instance id.
         * @param {string} [processInstanceBusinessKey] Filter by process instance business key.
         * @param {string} [processInstanceBusinessKeyIn] Filter by process instances with one of the give business keys. The keys need to be in a comma-separated list.
         * @param {string} [processInstanceBusinessKeyLike] Filter by  process instance business key that has the parameter value as a substring.
         * @param {string} [executionId] Filter by the id of the execution that executed the task.
         * @param {string} [processDefinitionId] Filter by process definition id.
         * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
         * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
         * @param {string} [caseInstanceId] Filter by case instance id.
         * @param {string} [caseExecutionId] Filter by the id of the case execution that executed the task.
         * @param {string} [caseDefinitionId] Filter by case definition id.
         * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
         * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
         * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed comma-separated activity instance ids.
         * @param {string} [taskName] Restrict to tasks that have the given name.
         * @param {string} [taskNameLike] Restrict to tasks that have a name with the given parameter value as substring.
         * @param {string} [taskDescription] Restrict to tasks that have the given description.
         * @param {string} [taskDescriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
         * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
         * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the passed comma-separated task definition keys.
         * @param {string} [taskDeleteReason] Restrict to tasks that have the given delete reason.
         * @param {string} [taskDeleteReasonLike] Restrict to tasks that have a delete reason that has the parameter value as a substring.
         * @param {string} [taskAssignee] Restrict to tasks that the given user is assigned to.
         * @param {string} [taskAssigneeLike] Restrict to tasks that are assigned to users with the parameter value as a substring.
         * @param {string} [taskOwner] Restrict to tasks that the given user owns.
         * @param {string} [taskOwnerLike] Restrict to tasks that are owned by users with the parameter value as a substring.
         * @param {number} [taskPriority] Restrict to tasks that have the given priority.
         * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
         * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
         * @param {boolean} [finished] Only include finished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [unfinished] Only include unfinished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [processFinished] Only include tasks of finished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [processUnfinished] Only include tasks of unfinished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {Date} [taskDueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [taskDueDateBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [taskDueDateAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {boolean} [withoutTaskDueDate] Only include tasks which have no due date. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {Date} [taskFollowUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [taskFollowUpDateBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [taskFollowUpDateAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [startedBefore] Restrict to tasks that were started before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [startedAfter] Restrict to tasks that were started after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [finishedBefore] Restrict to tasks that were finished before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [finishedAfter] Restrict to tasks that were finished after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A task instance must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include historic task instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;; * &#x60;notLike&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match the variable name provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match the variable value provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal.
         * @param {string} [taskInvolvedUser] Restrict to tasks with a historic identity link to the given user.
         * @param {string} [taskInvolvedGroup] Restrict to tasks with a historic identity link to the given group.
         * @param {string} [taskHadCandidateUser] Restrict to tasks with a historic identity link to the given candidate user.
         * @param {string} [taskHadCandidateGroup] Restrict to tasks with a historic identity link to the given candidate group.
         * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHistoricTaskInstances(taskId?: string, taskParentTaskId?: string, processInstanceId?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, executionId?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionName?: string, caseInstanceId?: string, caseExecutionId?: string, caseDefinitionId?: string, caseDefinitionKey?: string, caseDefinitionName?: string, activityInstanceIdIn?: string, taskName?: string, taskNameLike?: string, taskDescription?: string, taskDescriptionLike?: string, taskDefinitionKey?: string, taskDefinitionKeyIn?: string, taskDeleteReason?: string, taskDeleteReasonLike?: string, taskAssignee?: string, taskAssigneeLike?: string, taskOwner?: string, taskOwnerLike?: string, taskPriority?: number, assigned?: boolean, unassigned?: boolean, finished?: boolean, unfinished?: boolean, processFinished?: boolean, processUnfinished?: boolean, taskDueDate?: Date, taskDueDateBefore?: Date, taskDueDateAfter?: Date, withoutTaskDueDate?: boolean, taskFollowUpDate?: Date, taskFollowUpDateBefore?: Date, taskFollowUpDateAfter?: Date, startedBefore?: Date, startedAfter?: Date, finishedBefore?: Date, finishedAfter?: Date, tenantIdIn?: string, withoutTenantId?: boolean, taskVariables?: string, processVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, taskInvolvedUser?: string, taskInvolvedGroup?: string, taskHadCandidateUser?: string, taskHadCandidateGroup?: string, withCandidateGroups?: boolean, withoutCandidateGroups?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<HistoricTaskInstanceDto>>> {
            return HistoricTaskInstanceApiFp(configuration).getHistoricTaskInstances(taskId, taskParentTaskId, processInstanceId, processInstanceBusinessKey, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, executionId, processDefinitionId, processDefinitionKey, processDefinitionName, caseInstanceId, caseExecutionId, caseDefinitionId, caseDefinitionKey, caseDefinitionName, activityInstanceIdIn, taskName, taskNameLike, taskDescription, taskDescriptionLike, taskDefinitionKey, taskDefinitionKeyIn, taskDeleteReason, taskDeleteReasonLike, taskAssignee, taskAssigneeLike, taskOwner, taskOwnerLike, taskPriority, assigned, unassigned, finished, unfinished, processFinished, processUnfinished, taskDueDate, taskDueDateBefore, taskDueDateAfter, withoutTaskDueDate, taskFollowUpDate, taskFollowUpDateBefore, taskFollowUpDateAfter, startedBefore, startedAfter, finishedBefore, finishedAfter, tenantIdIn, withoutTenantId, taskVariables, processVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, taskInvolvedUser, taskInvolvedGroup, taskHadCandidateUser, taskHadCandidateGroup, withCandidateGroups, withoutCandidateGroups, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for the number of historic tasks that fulfill the given parameters. Takes the same parameters as the [Get Tasks (Historic)](https://docs.camunda.org/manual/7.18/reference/rest/history/task/get-task-query/) method.
         * @summary Get Task Count
         * @param {string} [taskId] Filter by task id.
         * @param {string} [taskParentTaskId] Filter by parent task id.
         * @param {string} [processInstanceId] Filter by process instance id.
         * @param {string} [processInstanceBusinessKey] Filter by process instance business key.
         * @param {string} [processInstanceBusinessKeyIn] Filter by process instances with one of the give business keys. The keys need to be in a comma-separated list.
         * @param {string} [processInstanceBusinessKeyLike] Filter by  process instance business key that has the parameter value as a substring.
         * @param {string} [executionId] Filter by the id of the execution that executed the task.
         * @param {string} [processDefinitionId] Filter by process definition id.
         * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
         * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
         * @param {string} [caseInstanceId] Filter by case instance id.
         * @param {string} [caseExecutionId] Filter by the id of the case execution that executed the task.
         * @param {string} [caseDefinitionId] Filter by case definition id.
         * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
         * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
         * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed comma-separated activity instance ids.
         * @param {string} [taskName] Restrict to tasks that have the given name.
         * @param {string} [taskNameLike] Restrict to tasks that have a name with the given parameter value as substring.
         * @param {string} [taskDescription] Restrict to tasks that have the given description.
         * @param {string} [taskDescriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
         * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
         * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the passed comma-separated task definition keys.
         * @param {string} [taskDeleteReason] Restrict to tasks that have the given delete reason.
         * @param {string} [taskDeleteReasonLike] Restrict to tasks that have a delete reason that has the parameter value as a substring.
         * @param {string} [taskAssignee] Restrict to tasks that the given user is assigned to.
         * @param {string} [taskAssigneeLike] Restrict to tasks that are assigned to users with the parameter value as a substring.
         * @param {string} [taskOwner] Restrict to tasks that the given user owns.
         * @param {string} [taskOwnerLike] Restrict to tasks that are owned by users with the parameter value as a substring.
         * @param {number} [taskPriority] Restrict to tasks that have the given priority.
         * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
         * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
         * @param {boolean} [finished] Only include finished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [unfinished] Only include unfinished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [processFinished] Only include tasks of finished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [processUnfinished] Only include tasks of unfinished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {Date} [taskDueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [taskDueDateBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [taskDueDateAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {boolean} [withoutTaskDueDate] Only include tasks which have no due date. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {Date} [taskFollowUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [taskFollowUpDateBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [taskFollowUpDateAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [startedBefore] Restrict to tasks that were started before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [startedAfter] Restrict to tasks that were started after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [finishedBefore] Restrict to tasks that were finished before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [finishedAfter] Restrict to tasks that were finished after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A task instance must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include historic task instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;; * &#x60;notLike&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match the variable name provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match the variable value provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal.
         * @param {string} [taskInvolvedUser] Restrict to tasks with a historic identity link to the given user.
         * @param {string} [taskInvolvedGroup] Restrict to tasks with a historic identity link to the given group.
         * @param {string} [taskHadCandidateUser] Restrict to tasks with a historic identity link to the given candidate user.
         * @param {string} [taskHadCandidateGroup] Restrict to tasks with a historic identity link to the given candidate group.
         * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHistoricTaskInstancesCount(taskId?: string, taskParentTaskId?: string, processInstanceId?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, executionId?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionName?: string, caseInstanceId?: string, caseExecutionId?: string, caseDefinitionId?: string, caseDefinitionKey?: string, caseDefinitionName?: string, activityInstanceIdIn?: string, taskName?: string, taskNameLike?: string, taskDescription?: string, taskDescriptionLike?: string, taskDefinitionKey?: string, taskDefinitionKeyIn?: string, taskDeleteReason?: string, taskDeleteReasonLike?: string, taskAssignee?: string, taskAssigneeLike?: string, taskOwner?: string, taskOwnerLike?: string, taskPriority?: number, assigned?: boolean, unassigned?: boolean, finished?: boolean, unfinished?: boolean, processFinished?: boolean, processUnfinished?: boolean, taskDueDate?: Date, taskDueDateBefore?: Date, taskDueDateAfter?: Date, withoutTaskDueDate?: boolean, taskFollowUpDate?: Date, taskFollowUpDateBefore?: Date, taskFollowUpDateAfter?: Date, startedBefore?: Date, startedAfter?: Date, finishedBefore?: Date, finishedAfter?: Date, tenantIdIn?: string, withoutTenantId?: boolean, taskVariables?: string, processVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, taskInvolvedUser?: string, taskInvolvedGroup?: string, taskHadCandidateUser?: string, taskHadCandidateGroup?: string, withCandidateGroups?: boolean, withoutCandidateGroups?: boolean, options?: AxiosRequestConfig): Promise<AxiosResponse<CountResultDto>> {
            return HistoricTaskInstanceApiFp(configuration).getHistoricTaskInstancesCount(taskId, taskParentTaskId, processInstanceId, processInstanceBusinessKey, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, executionId, processDefinitionId, processDefinitionKey, processDefinitionName, caseInstanceId, caseExecutionId, caseDefinitionId, caseDefinitionKey, caseDefinitionName, activityInstanceIdIn, taskName, taskNameLike, taskDescription, taskDescriptionLike, taskDefinitionKey, taskDefinitionKeyIn, taskDeleteReason, taskDeleteReasonLike, taskAssignee, taskAssigneeLike, taskOwner, taskOwnerLike, taskPriority, assigned, unassigned, finished, unfinished, processFinished, processUnfinished, taskDueDate, taskDueDateBefore, taskDueDateAfter, withoutTaskDueDate, taskFollowUpDate, taskFollowUpDateBefore, taskFollowUpDateAfter, startedBefore, startedAfter, finishedBefore, finishedAfter, tenantIdIn, withoutTenantId, taskVariables, processVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, taskInvolvedUser, taskInvolvedGroup, taskHadCandidateUser, taskHadCandidateGroup, withCandidateGroups, withoutCandidateGroups, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for historic tasks that fulfill the given parameters. This method is slightly more powerful than the [Get Tasks (Historic)](https://docs.camunda.org/manual/7.18/reference/rest/history/task/get-task-query/) method because it allows filtering by multiple process or task variables of types `String`, `Number` or `Boolean`. The size of the result set can be retrieved by using the [Get Task Count (POST)](https://docs.camunda.org/manual/7.18/reference/rest/history/task/post-task-query-count/) method.
         * @summary Get Tasks (Historic) (POST)
         * @param {HistoricTaskInstanceQueryDto} [body] 
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryHistoricTaskInstances(body?: HistoricTaskInstanceQueryDto, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<HistoricTaskInstanceDto>>> {
            return HistoricTaskInstanceApiFp(configuration).queryHistoricTaskInstances(body, firstResult, maxResults, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for the number of historic tasks that fulfill the given parameters. Takes the same parameters as the [Get Tasks (Historic)](https://docs.camunda.org/manual/7.18/reference/rest/history/task/get-task-query/) method. Corresponds to the size of the result set of the [Get Tasks (Historic) (POST)](https://docs.camunda.org/manual/7.18/reference/rest/history/task/post-task-query/) method and takes the same parameters.
         * @summary Get Task Count (POST)
         * @param {HistoricTaskInstanceQueryDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryHistoricTaskInstancesCount(body?: HistoricTaskInstanceQueryDto, options?: AxiosRequestConfig): Promise<AxiosResponse<CountResultDto>> {
            return HistoricTaskInstanceApiFp(configuration).queryHistoricTaskInstancesCount(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HistoricTaskInstanceApi - object-oriented interface
 * @export
 * @class HistoricTaskInstanceApi
 * @extends {BaseAPI}
 */
export class HistoricTaskInstanceApi extends BaseAPI {
    /**
     * Retrieves a report of completed tasks. When the report type is set to `count`, the report contains a list of completed task counts where an entry contains the task name, the definition key of the task, the process definition id, the process definition key, the process definition name and the count of how many tasks were completed for the specified key in a given period. When the report type is set to `duration`, the report contains a minimum, maximum and average duration value of all completed task instances in a given period.
     * @summary Get Task Report (Historic)
     * @param {string} [reportType] **Mandatory.** Specifies the kind of the report to execute. To retrieve a report about the duration of process instances the value must be set to &#x60;duration&#x60;. For a report of the completed tasks in a specific timespan the value must be set to &#x60;count&#x60;.
     * @param {string} [periodUnit] When the report type is set to &#x60;duration&#x60;, this parameter is **mandatory**. Specifies the granularity of the report. Valid values are &#x60;month&#x60; and &#x60;quarter&#x60;.
     * @param {Date} [completedBefore] Restrict to tasks that were completed before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {Date} [completedAfter] Restrict to tasks that were completed after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {string} [groupBy] When the report type is set to &#x60;count&#x60;, this parameter is **mandatory**. Groups the tasks report by a given criterion. Valid values are &#x60;taskName&#x60; and &#x60;processDefinition&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoricTaskInstanceApi
     */
    public async getHistoricTaskInstanceReport(reportType?: string, periodUnit?: string, completedBefore?: Date, completedAfter?: Date, groupBy?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<HistoricTaskInstanceReportResultDto>>> {
        return HistoricTaskInstanceApiFp(this.configuration).getHistoricTaskInstanceReport(reportType, periodUnit, completedBefore, completedAfter, groupBy, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Queries for historic tasks that fulfill the given parameters. The size of the result set can be retrieved by using the [Get Task Count](https://docs.camunda.org/manual/7.18/reference/rest/history/task/get-task-query-count/) method.
     * @summary Get Tasks (Historic)
     * @param {string} [taskId] Filter by task id.
     * @param {string} [taskParentTaskId] Filter by parent task id.
     * @param {string} [processInstanceId] Filter by process instance id.
     * @param {string} [processInstanceBusinessKey] Filter by process instance business key.
     * @param {string} [processInstanceBusinessKeyIn] Filter by process instances with one of the give business keys. The keys need to be in a comma-separated list.
     * @param {string} [processInstanceBusinessKeyLike] Filter by  process instance business key that has the parameter value as a substring.
     * @param {string} [executionId] Filter by the id of the execution that executed the task.
     * @param {string} [processDefinitionId] Filter by process definition id.
     * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
     * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
     * @param {string} [caseInstanceId] Filter by case instance id.
     * @param {string} [caseExecutionId] Filter by the id of the case execution that executed the task.
     * @param {string} [caseDefinitionId] Filter by case definition id.
     * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
     * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
     * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed comma-separated activity instance ids.
     * @param {string} [taskName] Restrict to tasks that have the given name.
     * @param {string} [taskNameLike] Restrict to tasks that have a name with the given parameter value as substring.
     * @param {string} [taskDescription] Restrict to tasks that have the given description.
     * @param {string} [taskDescriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
     * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
     * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the passed comma-separated task definition keys.
     * @param {string} [taskDeleteReason] Restrict to tasks that have the given delete reason.
     * @param {string} [taskDeleteReasonLike] Restrict to tasks that have a delete reason that has the parameter value as a substring.
     * @param {string} [taskAssignee] Restrict to tasks that the given user is assigned to.
     * @param {string} [taskAssigneeLike] Restrict to tasks that are assigned to users with the parameter value as a substring.
     * @param {string} [taskOwner] Restrict to tasks that the given user owns.
     * @param {string} [taskOwnerLike] Restrict to tasks that are owned by users with the parameter value as a substring.
     * @param {number} [taskPriority] Restrict to tasks that have the given priority.
     * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
     * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
     * @param {boolean} [finished] Only include finished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [unfinished] Only include unfinished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [processFinished] Only include tasks of finished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [processUnfinished] Only include tasks of unfinished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {Date} [taskDueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {Date} [taskDueDateBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {Date} [taskDueDateAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {boolean} [withoutTaskDueDate] Only include tasks which have no due date. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {Date} [taskFollowUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {Date} [taskFollowUpDateBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {Date} [taskFollowUpDateAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {Date} [startedBefore] Restrict to tasks that were started before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {Date} [startedAfter] Restrict to tasks that were started after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {Date} [finishedBefore] Restrict to tasks that were finished before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {Date} [finishedAfter] Restrict to tasks that were finished after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A task instance must have one of the given tenant ids.
     * @param {boolean} [withoutTenantId] Only include historic task instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;; * &#x60;notLike&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {boolean} [variableNamesIgnoreCase] Match the variable name provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal.
     * @param {boolean} [variableValuesIgnoreCase] Match the variable value provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal.
     * @param {string} [taskInvolvedUser] Restrict to tasks with a historic identity link to the given user.
     * @param {string} [taskInvolvedGroup] Restrict to tasks with a historic identity link to the given group.
     * @param {string} [taskHadCandidateUser] Restrict to tasks with a historic identity link to the given candidate user.
     * @param {string} [taskHadCandidateGroup] Restrict to tasks with a historic identity link to the given candidate group.
     * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoricTaskInstanceApi
     */
    public async getHistoricTaskInstances(taskId?: string, taskParentTaskId?: string, processInstanceId?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, executionId?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionName?: string, caseInstanceId?: string, caseExecutionId?: string, caseDefinitionId?: string, caseDefinitionKey?: string, caseDefinitionName?: string, activityInstanceIdIn?: string, taskName?: string, taskNameLike?: string, taskDescription?: string, taskDescriptionLike?: string, taskDefinitionKey?: string, taskDefinitionKeyIn?: string, taskDeleteReason?: string, taskDeleteReasonLike?: string, taskAssignee?: string, taskAssigneeLike?: string, taskOwner?: string, taskOwnerLike?: string, taskPriority?: number, assigned?: boolean, unassigned?: boolean, finished?: boolean, unfinished?: boolean, processFinished?: boolean, processUnfinished?: boolean, taskDueDate?: Date, taskDueDateBefore?: Date, taskDueDateAfter?: Date, withoutTaskDueDate?: boolean, taskFollowUpDate?: Date, taskFollowUpDateBefore?: Date, taskFollowUpDateAfter?: Date, startedBefore?: Date, startedAfter?: Date, finishedBefore?: Date, finishedAfter?: Date, tenantIdIn?: string, withoutTenantId?: boolean, taskVariables?: string, processVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, taskInvolvedUser?: string, taskInvolvedGroup?: string, taskHadCandidateUser?: string, taskHadCandidateGroup?: string, withCandidateGroups?: boolean, withoutCandidateGroups?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<HistoricTaskInstanceDto>>> {
        return HistoricTaskInstanceApiFp(this.configuration).getHistoricTaskInstances(taskId, taskParentTaskId, processInstanceId, processInstanceBusinessKey, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, executionId, processDefinitionId, processDefinitionKey, processDefinitionName, caseInstanceId, caseExecutionId, caseDefinitionId, caseDefinitionKey, caseDefinitionName, activityInstanceIdIn, taskName, taskNameLike, taskDescription, taskDescriptionLike, taskDefinitionKey, taskDefinitionKeyIn, taskDeleteReason, taskDeleteReasonLike, taskAssignee, taskAssigneeLike, taskOwner, taskOwnerLike, taskPriority, assigned, unassigned, finished, unfinished, processFinished, processUnfinished, taskDueDate, taskDueDateBefore, taskDueDateAfter, withoutTaskDueDate, taskFollowUpDate, taskFollowUpDateBefore, taskFollowUpDateAfter, startedBefore, startedAfter, finishedBefore, finishedAfter, tenantIdIn, withoutTenantId, taskVariables, processVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, taskInvolvedUser, taskInvolvedGroup, taskHadCandidateUser, taskHadCandidateGroup, withCandidateGroups, withoutCandidateGroups, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Queries for the number of historic tasks that fulfill the given parameters. Takes the same parameters as the [Get Tasks (Historic)](https://docs.camunda.org/manual/7.18/reference/rest/history/task/get-task-query/) method.
     * @summary Get Task Count
     * @param {string} [taskId] Filter by task id.
     * @param {string} [taskParentTaskId] Filter by parent task id.
     * @param {string} [processInstanceId] Filter by process instance id.
     * @param {string} [processInstanceBusinessKey] Filter by process instance business key.
     * @param {string} [processInstanceBusinessKeyIn] Filter by process instances with one of the give business keys. The keys need to be in a comma-separated list.
     * @param {string} [processInstanceBusinessKeyLike] Filter by  process instance business key that has the parameter value as a substring.
     * @param {string} [executionId] Filter by the id of the execution that executed the task.
     * @param {string} [processDefinitionId] Filter by process definition id.
     * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
     * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
     * @param {string} [caseInstanceId] Filter by case instance id.
     * @param {string} [caseExecutionId] Filter by the id of the case execution that executed the task.
     * @param {string} [caseDefinitionId] Filter by case definition id.
     * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
     * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
     * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed comma-separated activity instance ids.
     * @param {string} [taskName] Restrict to tasks that have the given name.
     * @param {string} [taskNameLike] Restrict to tasks that have a name with the given parameter value as substring.
     * @param {string} [taskDescription] Restrict to tasks that have the given description.
     * @param {string} [taskDescriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
     * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
     * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the passed comma-separated task definition keys.
     * @param {string} [taskDeleteReason] Restrict to tasks that have the given delete reason.
     * @param {string} [taskDeleteReasonLike] Restrict to tasks that have a delete reason that has the parameter value as a substring.
     * @param {string} [taskAssignee] Restrict to tasks that the given user is assigned to.
     * @param {string} [taskAssigneeLike] Restrict to tasks that are assigned to users with the parameter value as a substring.
     * @param {string} [taskOwner] Restrict to tasks that the given user owns.
     * @param {string} [taskOwnerLike] Restrict to tasks that are owned by users with the parameter value as a substring.
     * @param {number} [taskPriority] Restrict to tasks that have the given priority.
     * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
     * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
     * @param {boolean} [finished] Only include finished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [unfinished] Only include unfinished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [processFinished] Only include tasks of finished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [processUnfinished] Only include tasks of unfinished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {Date} [taskDueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {Date} [taskDueDateBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {Date} [taskDueDateAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {boolean} [withoutTaskDueDate] Only include tasks which have no due date. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {Date} [taskFollowUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {Date} [taskFollowUpDateBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {Date} [taskFollowUpDateAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {Date} [startedBefore] Restrict to tasks that were started before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {Date} [startedAfter] Restrict to tasks that were started after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {Date} [finishedBefore] Restrict to tasks that were finished before the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {Date} [finishedAfter] Restrict to tasks that were finished after the given date. By [default](https://docs.camunda.org/manual/7.18/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A task instance must have one of the given tenant ids.
     * @param {boolean} [withoutTenantId] Only include historic task instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;; * &#x60;notLike&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {boolean} [variableNamesIgnoreCase] Match the variable name provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal.
     * @param {boolean} [variableValuesIgnoreCase] Match the variable value provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal.
     * @param {string} [taskInvolvedUser] Restrict to tasks with a historic identity link to the given user.
     * @param {string} [taskInvolvedGroup] Restrict to tasks with a historic identity link to the given group.
     * @param {string} [taskHadCandidateUser] Restrict to tasks with a historic identity link to the given candidate user.
     * @param {string} [taskHadCandidateGroup] Restrict to tasks with a historic identity link to the given candidate group.
     * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoricTaskInstanceApi
     */
    public async getHistoricTaskInstancesCount(taskId?: string, taskParentTaskId?: string, processInstanceId?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, executionId?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionName?: string, caseInstanceId?: string, caseExecutionId?: string, caseDefinitionId?: string, caseDefinitionKey?: string, caseDefinitionName?: string, activityInstanceIdIn?: string, taskName?: string, taskNameLike?: string, taskDescription?: string, taskDescriptionLike?: string, taskDefinitionKey?: string, taskDefinitionKeyIn?: string, taskDeleteReason?: string, taskDeleteReasonLike?: string, taskAssignee?: string, taskAssigneeLike?: string, taskOwner?: string, taskOwnerLike?: string, taskPriority?: number, assigned?: boolean, unassigned?: boolean, finished?: boolean, unfinished?: boolean, processFinished?: boolean, processUnfinished?: boolean, taskDueDate?: Date, taskDueDateBefore?: Date, taskDueDateAfter?: Date, withoutTaskDueDate?: boolean, taskFollowUpDate?: Date, taskFollowUpDateBefore?: Date, taskFollowUpDateAfter?: Date, startedBefore?: Date, startedAfter?: Date, finishedBefore?: Date, finishedAfter?: Date, tenantIdIn?: string, withoutTenantId?: boolean, taskVariables?: string, processVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, taskInvolvedUser?: string, taskInvolvedGroup?: string, taskHadCandidateUser?: string, taskHadCandidateGroup?: string, withCandidateGroups?: boolean, withoutCandidateGroups?: boolean, options?: AxiosRequestConfig) : Promise<AxiosResponse<CountResultDto>> {
        return HistoricTaskInstanceApiFp(this.configuration).getHistoricTaskInstancesCount(taskId, taskParentTaskId, processInstanceId, processInstanceBusinessKey, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, executionId, processDefinitionId, processDefinitionKey, processDefinitionName, caseInstanceId, caseExecutionId, caseDefinitionId, caseDefinitionKey, caseDefinitionName, activityInstanceIdIn, taskName, taskNameLike, taskDescription, taskDescriptionLike, taskDefinitionKey, taskDefinitionKeyIn, taskDeleteReason, taskDeleteReasonLike, taskAssignee, taskAssigneeLike, taskOwner, taskOwnerLike, taskPriority, assigned, unassigned, finished, unfinished, processFinished, processUnfinished, taskDueDate, taskDueDateBefore, taskDueDateAfter, withoutTaskDueDate, taskFollowUpDate, taskFollowUpDateBefore, taskFollowUpDateAfter, startedBefore, startedAfter, finishedBefore, finishedAfter, tenantIdIn, withoutTenantId, taskVariables, processVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, taskInvolvedUser, taskInvolvedGroup, taskHadCandidateUser, taskHadCandidateGroup, withCandidateGroups, withoutCandidateGroups, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Queries for historic tasks that fulfill the given parameters. This method is slightly more powerful than the [Get Tasks (Historic)](https://docs.camunda.org/manual/7.18/reference/rest/history/task/get-task-query/) method because it allows filtering by multiple process or task variables of types `String`, `Number` or `Boolean`. The size of the result set can be retrieved by using the [Get Task Count (POST)](https://docs.camunda.org/manual/7.18/reference/rest/history/task/post-task-query-count/) method.
     * @summary Get Tasks (Historic) (POST)
     * @param {HistoricTaskInstanceQueryDto} [body] 
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoricTaskInstanceApi
     */
    public async queryHistoricTaskInstances(body?: HistoricTaskInstanceQueryDto, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<HistoricTaskInstanceDto>>> {
        return HistoricTaskInstanceApiFp(this.configuration).queryHistoricTaskInstances(body, firstResult, maxResults, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Queries for the number of historic tasks that fulfill the given parameters. Takes the same parameters as the [Get Tasks (Historic)](https://docs.camunda.org/manual/7.18/reference/rest/history/task/get-task-query/) method. Corresponds to the size of the result set of the [Get Tasks (Historic) (POST)](https://docs.camunda.org/manual/7.18/reference/rest/history/task/post-task-query/) method and takes the same parameters.
     * @summary Get Task Count (POST)
     * @param {HistoricTaskInstanceQueryDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoricTaskInstanceApi
     */
    public async queryHistoricTaskInstancesCount(body?: HistoricTaskInstanceQueryDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<CountResultDto>> {
        return HistoricTaskInstanceApiFp(this.configuration).queryHistoricTaskInstancesCount(body, options).then((request) => request(this.axios, this.basePath));
    }
}

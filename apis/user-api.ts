/* tslint:disable */
/* eslint-disable */
/**
 * Camunda Platform REST API
 * OpenApi Spec for Camunda Platform REST API.
 *
 * OpenAPI spec version: 7.18.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { CountResultDto } from '../models';
import { ExceptionDto } from '../models';
import { ResourceOptionsDto } from '../models';
import { UserCredentialsDto } from '../models';
import { UserDto } from '../models';
import { UserProfileDto } from '../models';
/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The `/user` resource supports two custom `OPTIONS` requests, one for the resource as such and one for individual user instances. The `OPTIONS` request allows checking for the set of available operations that the currently authenticated user can perform on the /user resource. If the user can perform an operation or not may depend on various things, including the user's authorizations to interact with this resource and the internal configuration of the process engine. `OPTIONS /user` returns available interactions on the resource.
         * @summary Options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableOperations: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * The `/user` resource supports two custom `OPTIONS` requests, one for the resource as such and one for individual user instances. The `OPTIONS` request allows checking for the set of available operations that the currently authenticated user can perform on the /user resource. If the user can perform an operation or not may depend on various things, including the user's authorizations to interact with this resource and the internal configuration of the process engine. `OPTIONS /user/{id}` returns available interactions on a resource instance.
         * @summary Options
         * @param {string} id The id of the user to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableUserOperations: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling availableUserOperations.');
            }
            const localVarPath = `/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user.
         * @summary Create
         * @param {UserDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (body?: UserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a user by id.
         * @summary Delete
         * @param {string} id The id of the user to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteUser.');
            }
            const localVarPath = `/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for the number of deployments that fulfill given parameters. Takes the same parameters as the [Get Users](https://docs.camunda.org/manual/7.18/reference/rest/user/get-query/) method.
         * @summary Get List Count
         * @param {string} [id] Filter by user id
         * @param {string} [idIn] Filter by a comma-separated list of user ids.
         * @param {string} [firstName] Filter by the first name of the user. Exact match.
         * @param {string} [firstNameLike] Filter by the first name that the parameter is a substring of.
         * @param {string} [lastName] Filter by the last name of the user. Exact match.
         * @param {string} [lastNameLike] Filter by the last name that the parameter is a substring of.
         * @param {string} [email] Filter by the email of the user. Exact match.
         * @param {string} [emailLike] Filter by the email that the parameter is a substring of.
         * @param {string} [memberOfGroup] Filter for users which are members of the given group.
         * @param {string} [memberOfTenant] Filter for users which are members of the given tenant.
         * @param {string} [potentialStarter] Only select Users that are potential starter for the given process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCount: async (id?: string, idIn?: string, firstName?: string, firstNameLike?: string, lastName?: string, lastNameLike?: string, email?: string, emailLike?: string, memberOfGroup?: string, memberOfTenant?: string, potentialStarter?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (idIn !== undefined) {
                localVarQueryParameter['idIn'] = idIn;
            }

            if (firstName !== undefined) {
                localVarQueryParameter['firstName'] = firstName;
            }

            if (firstNameLike !== undefined) {
                localVarQueryParameter['firstNameLike'] = firstNameLike;
            }

            if (lastName !== undefined) {
                localVarQueryParameter['lastName'] = lastName;
            }

            if (lastNameLike !== undefined) {
                localVarQueryParameter['lastNameLike'] = lastNameLike;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (emailLike !== undefined) {
                localVarQueryParameter['emailLike'] = emailLike;
            }

            if (memberOfGroup !== undefined) {
                localVarQueryParameter['memberOfGroup'] = memberOfGroup;
            }

            if (memberOfTenant !== undefined) {
                localVarQueryParameter['memberOfTenant'] = memberOfTenant;
            }

            if (potentialStarter !== undefined) {
                localVarQueryParameter['potentialStarter'] = potentialStarter;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a user's profile.
         * @summary Get Profile
         * @param {string} id The id of the user to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProfile: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getUserProfile.');
            }
            const localVarPath = `/user/{id}/profile`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Query for a list of users using a list of parameters. The size of the result set can be retrieved by using the Get User Count method. [Get User Count](https://docs.camunda.org/manual/7.18/reference/rest/user/get-query-count/) method.
         * @summary Get List
         * @param {string} [id] Filter by user id
         * @param {string} [idIn] Filter by a comma-separated list of user ids.
         * @param {string} [firstName] Filter by the first name of the user. Exact match.
         * @param {string} [firstNameLike] Filter by the first name that the parameter is a substring of.
         * @param {string} [lastName] Filter by the last name of the user. Exact match.
         * @param {string} [lastNameLike] Filter by the last name that the parameter is a substring of.
         * @param {string} [email] Filter by the email of the user. Exact match.
         * @param {string} [emailLike] Filter by the email that the parameter is a substring of.
         * @param {string} [memberOfGroup] Filter for users which are members of the given group.
         * @param {string} [memberOfTenant] Filter for users which are members of the given tenant.
         * @param {string} [potentialStarter] Only select Users that are potential starter for the given process definition.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (id?: string, idIn?: string, firstName?: string, firstNameLike?: string, lastName?: string, lastNameLike?: string, email?: string, emailLike?: string, memberOfGroup?: string, memberOfTenant?: string, potentialStarter?: string, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (idIn !== undefined) {
                localVarQueryParameter['idIn'] = idIn;
            }

            if (firstName !== undefined) {
                localVarQueryParameter['firstName'] = firstName;
            }

            if (firstNameLike !== undefined) {
                localVarQueryParameter['firstNameLike'] = firstNameLike;
            }

            if (lastName !== undefined) {
                localVarQueryParameter['lastName'] = lastName;
            }

            if (lastNameLike !== undefined) {
                localVarQueryParameter['lastNameLike'] = lastNameLike;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (emailLike !== undefined) {
                localVarQueryParameter['emailLike'] = emailLike;
            }

            if (memberOfGroup !== undefined) {
                localVarQueryParameter['memberOfGroup'] = memberOfGroup;
            }

            if (memberOfTenant !== undefined) {
                localVarQueryParameter['memberOfTenant'] = memberOfTenant;
            }

            if (potentialStarter !== undefined) {
                localVarQueryParameter['potentialStarter'] = potentialStarter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Unlocks a user by id.
         * @summary Unlock User
         * @param {string} id The id of the user to be unlocked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockUser: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling unlockUser.');
            }
            const localVarPath = `/user/{id}/unlock`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a user's credentials (password)
         * @summary Update Credentials
         * @param {string} id The id of the user to be updated.
         * @param {UserCredentialsDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredentials: async (id: string, body?: UserCredentialsDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateCredentials.');
            }
            const localVarPath = `/user/{id}/credentials`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the profile information of an already existing user.
         * @summary Update User Profile
         * @param {string} id The id of the user.
         * @param {UserProfileDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfile: async (id: string, body?: UserProfileDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateProfile.');
            }
            const localVarPath = `/user/{id}/profile`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * The `/user` resource supports two custom `OPTIONS` requests, one for the resource as such and one for individual user instances. The `OPTIONS` request allows checking for the set of available operations that the currently authenticated user can perform on the /user resource. If the user can perform an operation or not may depend on various things, including the user's authorizations to interact with this resource and the internal configuration of the process engine. `OPTIONS /user` returns available interactions on the resource.
         * @summary Options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableOperations(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResourceOptionsDto>>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).availableOperations(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * The `/user` resource supports two custom `OPTIONS` requests, one for the resource as such and one for individual user instances. The `OPTIONS` request allows checking for the set of available operations that the currently authenticated user can perform on the /user resource. If the user can perform an operation or not may depend on various things, including the user's authorizations to interact with this resource and the internal configuration of the process engine. `OPTIONS /user/{id}` returns available interactions on a resource instance.
         * @summary Options
         * @param {string} id The id of the user to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableUserOperations(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ResourceOptionsDto>>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).availableUserOperations(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a new user.
         * @summary Create
         * @param {UserDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(body?: UserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).createUser(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes a user by id.
         * @summary Delete
         * @param {string} id The id of the user to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).deleteUser(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Queries for the number of deployments that fulfill given parameters. Takes the same parameters as the [Get Users](https://docs.camunda.org/manual/7.18/reference/rest/user/get-query/) method.
         * @summary Get List Count
         * @param {string} [id] Filter by user id
         * @param {string} [idIn] Filter by a comma-separated list of user ids.
         * @param {string} [firstName] Filter by the first name of the user. Exact match.
         * @param {string} [firstNameLike] Filter by the first name that the parameter is a substring of.
         * @param {string} [lastName] Filter by the last name of the user. Exact match.
         * @param {string} [lastNameLike] Filter by the last name that the parameter is a substring of.
         * @param {string} [email] Filter by the email of the user. Exact match.
         * @param {string} [emailLike] Filter by the email that the parameter is a substring of.
         * @param {string} [memberOfGroup] Filter for users which are members of the given group.
         * @param {string} [memberOfTenant] Filter for users which are members of the given tenant.
         * @param {string} [potentialStarter] Only select Users that are potential starter for the given process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserCount(id?: string, idIn?: string, firstName?: string, firstNameLike?: string, lastName?: string, lastNameLike?: string, email?: string, emailLike?: string, memberOfGroup?: string, memberOfTenant?: string, potentialStarter?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<CountResultDto>>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).getUserCount(id, idIn, firstName, firstNameLike, lastName, lastNameLike, email, emailLike, memberOfGroup, memberOfTenant, potentialStarter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves a user's profile.
         * @summary Get Profile
         * @param {string} id The id of the user to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserProfile(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<UserProfileDto>>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).getUserProfile(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Query for a list of users using a list of parameters. The size of the result set can be retrieved by using the Get User Count method. [Get User Count](https://docs.camunda.org/manual/7.18/reference/rest/user/get-query-count/) method.
         * @summary Get List
         * @param {string} [id] Filter by user id
         * @param {string} [idIn] Filter by a comma-separated list of user ids.
         * @param {string} [firstName] Filter by the first name of the user. Exact match.
         * @param {string} [firstNameLike] Filter by the first name that the parameter is a substring of.
         * @param {string} [lastName] Filter by the last name of the user. Exact match.
         * @param {string} [lastNameLike] Filter by the last name that the parameter is a substring of.
         * @param {string} [email] Filter by the email of the user. Exact match.
         * @param {string} [emailLike] Filter by the email that the parameter is a substring of.
         * @param {string} [memberOfGroup] Filter for users which are members of the given group.
         * @param {string} [memberOfTenant] Filter for users which are members of the given tenant.
         * @param {string} [potentialStarter] Only select Users that are potential starter for the given process definition.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(id?: string, idIn?: string, firstName?: string, firstNameLike?: string, lastName?: string, lastNameLike?: string, email?: string, emailLike?: string, memberOfGroup?: string, memberOfTenant?: string, potentialStarter?: string, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<UserProfileDto>>>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).getUsers(id, idIn, firstName, firstNameLike, lastName, lastNameLike, email, emailLike, memberOfGroup, memberOfTenant, potentialStarter, sortBy, sortOrder, firstResult, maxResults, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Unlocks a user by id.
         * @summary Unlock User
         * @param {string} id The id of the user to be unlocked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlockUser(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).unlockUser(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates a user's credentials (password)
         * @summary Update Credentials
         * @param {string} id The id of the user to be updated.
         * @param {UserCredentialsDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCredentials(id: string, body?: UserCredentialsDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).updateCredentials(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates the profile information of an already existing user.
         * @summary Update User Profile
         * @param {string} id The id of the user.
         * @param {UserProfileDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProfile(id: string, body?: UserProfileDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).updateProfile(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * The `/user` resource supports two custom `OPTIONS` requests, one for the resource as such and one for individual user instances. The `OPTIONS` request allows checking for the set of available operations that the currently authenticated user can perform on the /user resource. If the user can perform an operation or not may depend on various things, including the user's authorizations to interact with this resource and the internal configuration of the process engine. `OPTIONS /user` returns available interactions on the resource.
         * @summary Options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableOperations(options?: AxiosRequestConfig): Promise<AxiosResponse<ResourceOptionsDto>> {
            return UserApiFp(configuration).availableOperations(options).then((request) => request(axios, basePath));
        },
        /**
         * The `/user` resource supports two custom `OPTIONS` requests, one for the resource as such and one for individual user instances. The `OPTIONS` request allows checking for the set of available operations that the currently authenticated user can perform on the /user resource. If the user can perform an operation or not may depend on various things, including the user's authorizations to interact with this resource and the internal configuration of the process engine. `OPTIONS /user/{id}` returns available interactions on a resource instance.
         * @summary Options
         * @param {string} id The id of the user to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableUserOperations(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<ResourceOptionsDto>> {
            return UserApiFp(configuration).availableUserOperations(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user.
         * @summary Create
         * @param {UserDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(body?: UserDto, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return UserApiFp(configuration).createUser(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a user by id.
         * @summary Delete
         * @param {string} id The id of the user to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return UserApiFp(configuration).deleteUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Queries for the number of deployments that fulfill given parameters. Takes the same parameters as the [Get Users](https://docs.camunda.org/manual/7.18/reference/rest/user/get-query/) method.
         * @summary Get List Count
         * @param {string} [id] Filter by user id
         * @param {string} [idIn] Filter by a comma-separated list of user ids.
         * @param {string} [firstName] Filter by the first name of the user. Exact match.
         * @param {string} [firstNameLike] Filter by the first name that the parameter is a substring of.
         * @param {string} [lastName] Filter by the last name of the user. Exact match.
         * @param {string} [lastNameLike] Filter by the last name that the parameter is a substring of.
         * @param {string} [email] Filter by the email of the user. Exact match.
         * @param {string} [emailLike] Filter by the email that the parameter is a substring of.
         * @param {string} [memberOfGroup] Filter for users which are members of the given group.
         * @param {string} [memberOfTenant] Filter for users which are members of the given tenant.
         * @param {string} [potentialStarter] Only select Users that are potential starter for the given process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserCount(id?: string, idIn?: string, firstName?: string, firstNameLike?: string, lastName?: string, lastNameLike?: string, email?: string, emailLike?: string, memberOfGroup?: string, memberOfTenant?: string, potentialStarter?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<CountResultDto>> {
            return UserApiFp(configuration).getUserCount(id, idIn, firstName, firstNameLike, lastName, lastNameLike, email, emailLike, memberOfGroup, memberOfTenant, potentialStarter, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a user's profile.
         * @summary Get Profile
         * @param {string} id The id of the user to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserProfile(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<UserProfileDto>> {
            return UserApiFp(configuration).getUserProfile(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Query for a list of users using a list of parameters. The size of the result set can be retrieved by using the Get User Count method. [Get User Count](https://docs.camunda.org/manual/7.18/reference/rest/user/get-query-count/) method.
         * @summary Get List
         * @param {string} [id] Filter by user id
         * @param {string} [idIn] Filter by a comma-separated list of user ids.
         * @param {string} [firstName] Filter by the first name of the user. Exact match.
         * @param {string} [firstNameLike] Filter by the first name that the parameter is a substring of.
         * @param {string} [lastName] Filter by the last name of the user. Exact match.
         * @param {string} [lastNameLike] Filter by the last name that the parameter is a substring of.
         * @param {string} [email] Filter by the email of the user. Exact match.
         * @param {string} [emailLike] Filter by the email that the parameter is a substring of.
         * @param {string} [memberOfGroup] Filter for users which are members of the given group.
         * @param {string} [memberOfTenant] Filter for users which are members of the given tenant.
         * @param {string} [potentialStarter] Only select Users that are potential starter for the given process definition.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(id?: string, idIn?: string, firstName?: string, firstNameLike?: string, lastName?: string, lastNameLike?: string, email?: string, emailLike?: string, memberOfGroup?: string, memberOfTenant?: string, potentialStarter?: string, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<UserProfileDto>>> {
            return UserApiFp(configuration).getUsers(id, idIn, firstName, firstNameLike, lastName, lastNameLike, email, emailLike, memberOfGroup, memberOfTenant, potentialStarter, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(axios, basePath));
        },
        /**
         * Unlocks a user by id.
         * @summary Unlock User
         * @param {string} id The id of the user to be unlocked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlockUser(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return UserApiFp(configuration).unlockUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a user's credentials (password)
         * @summary Update Credentials
         * @param {string} id The id of the user to be updated.
         * @param {UserCredentialsDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCredentials(id: string, body?: UserCredentialsDto, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return UserApiFp(configuration).updateCredentials(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the profile information of an already existing user.
         * @summary Update User Profile
         * @param {string} id The id of the user.
         * @param {UserProfileDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProfile(id: string, body?: UserProfileDto, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return UserApiFp(configuration).updateProfile(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * The `/user` resource supports two custom `OPTIONS` requests, one for the resource as such and one for individual user instances. The `OPTIONS` request allows checking for the set of available operations that the currently authenticated user can perform on the /user resource. If the user can perform an operation or not may depend on various things, including the user's authorizations to interact with this resource and the internal configuration of the process engine. `OPTIONS /user` returns available interactions on the resource.
     * @summary Options
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public async availableOperations(options?: AxiosRequestConfig) : Promise<AxiosResponse<ResourceOptionsDto>> {
        return UserApiFp(this.configuration).availableOperations(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * The `/user` resource supports two custom `OPTIONS` requests, one for the resource as such and one for individual user instances. The `OPTIONS` request allows checking for the set of available operations that the currently authenticated user can perform on the /user resource. If the user can perform an operation or not may depend on various things, including the user's authorizations to interact with this resource and the internal configuration of the process engine. `OPTIONS /user/{id}` returns available interactions on a resource instance.
     * @summary Options
     * @param {string} id The id of the user to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public async availableUserOperations(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<ResourceOptionsDto>> {
        return UserApiFp(this.configuration).availableUserOperations(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new user.
     * @summary Create
     * @param {UserDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public async createUser(body?: UserDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return UserApiFp(this.configuration).createUser(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes a user by id.
     * @summary Delete
     * @param {string} id The id of the user to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public async deleteUser(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return UserApiFp(this.configuration).deleteUser(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Queries for the number of deployments that fulfill given parameters. Takes the same parameters as the [Get Users](https://docs.camunda.org/manual/7.18/reference/rest/user/get-query/) method.
     * @summary Get List Count
     * @param {string} [id] Filter by user id
     * @param {string} [idIn] Filter by a comma-separated list of user ids.
     * @param {string} [firstName] Filter by the first name of the user. Exact match.
     * @param {string} [firstNameLike] Filter by the first name that the parameter is a substring of.
     * @param {string} [lastName] Filter by the last name of the user. Exact match.
     * @param {string} [lastNameLike] Filter by the last name that the parameter is a substring of.
     * @param {string} [email] Filter by the email of the user. Exact match.
     * @param {string} [emailLike] Filter by the email that the parameter is a substring of.
     * @param {string} [memberOfGroup] Filter for users which are members of the given group.
     * @param {string} [memberOfTenant] Filter for users which are members of the given tenant.
     * @param {string} [potentialStarter] Only select Users that are potential starter for the given process definition.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public async getUserCount(id?: string, idIn?: string, firstName?: string, firstNameLike?: string, lastName?: string, lastNameLike?: string, email?: string, emailLike?: string, memberOfGroup?: string, memberOfTenant?: string, potentialStarter?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<CountResultDto>> {
        return UserApiFp(this.configuration).getUserCount(id, idIn, firstName, firstNameLike, lastName, lastNameLike, email, emailLike, memberOfGroup, memberOfTenant, potentialStarter, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a user's profile.
     * @summary Get Profile
     * @param {string} id The id of the user to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public async getUserProfile(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<UserProfileDto>> {
        return UserApiFp(this.configuration).getUserProfile(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Query for a list of users using a list of parameters. The size of the result set can be retrieved by using the Get User Count method. [Get User Count](https://docs.camunda.org/manual/7.18/reference/rest/user/get-query-count/) method.
     * @summary Get List
     * @param {string} [id] Filter by user id
     * @param {string} [idIn] Filter by a comma-separated list of user ids.
     * @param {string} [firstName] Filter by the first name of the user. Exact match.
     * @param {string} [firstNameLike] Filter by the first name that the parameter is a substring of.
     * @param {string} [lastName] Filter by the last name of the user. Exact match.
     * @param {string} [lastNameLike] Filter by the last name that the parameter is a substring of.
     * @param {string} [email] Filter by the email of the user. Exact match.
     * @param {string} [emailLike] Filter by the email that the parameter is a substring of.
     * @param {string} [memberOfGroup] Filter for users which are members of the given group.
     * @param {string} [memberOfTenant] Filter for users which are members of the given tenant.
     * @param {string} [potentialStarter] Only select Users that are potential starter for the given process definition.
     * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public async getUsers(id?: string, idIn?: string, firstName?: string, firstNameLike?: string, lastName?: string, lastNameLike?: string, email?: string, emailLike?: string, memberOfGroup?: string, memberOfTenant?: string, potentialStarter?: string, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<UserProfileDto>>> {
        return UserApiFp(this.configuration).getUsers(id, idIn, firstName, firstNameLike, lastName, lastNameLike, email, emailLike, memberOfGroup, memberOfTenant, potentialStarter, sortBy, sortOrder, firstResult, maxResults, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Unlocks a user by id.
     * @summary Unlock User
     * @param {string} id The id of the user to be unlocked.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public async unlockUser(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return UserApiFp(this.configuration).unlockUser(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates a user's credentials (password)
     * @summary Update Credentials
     * @param {string} id The id of the user to be updated.
     * @param {UserCredentialsDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public async updateCredentials(id: string, body?: UserCredentialsDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return UserApiFp(this.configuration).updateCredentials(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the profile information of an already existing user.
     * @summary Update User Profile
     * @param {string} id The id of the user.
     * @param {UserProfileDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public async updateProfile(id: string, body?: UserProfileDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return UserApiFp(this.configuration).updateProfile(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}
